; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.30501.0 

	TITLE	C:\Users\Simon\Documents\GitHub\Game-of-Life\Scene.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	?_Min@?$AtlLimits@_J@ATL@@2_JB			; ATL::AtlLimits<__int64>::_Min
PUBLIC	?_Max@?$AtlLimits@_J@ATL@@2_JB			; ATL::AtlLimits<__int64>::_Max
PUBLIC	?_Min@?$AtlLimits@_K@ATL@@2_KB			; ATL::AtlLimits<unsigned __int64>::_Min
PUBLIC	?_Max@?$AtlLimits@_K@ATL@@2_KB			; ATL::AtlLimits<unsigned __int64>::_Max
PUBLIC	__GUID_9b7e4c04_342c_4106_a19f_4f2704f689f0
PUBLIC	_IID_IAxWinAmbientDispatchEx
PUBLIC	_IID_IInternalConnection
PUBLIC	__GUID_0002e012_0000_0000_c000_000000000046
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	__GUID_fc4801a3_2ba9_11cf_a229_00aa003d7352
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	??_C@_1M@KANJNLFF@?$AAC?$AAL?$AAS?$AAI?$AAD?$AA?$AA@ ; `string'
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	??_C@_1M@EJNEECMJ@?$AAA?$AAp?$AAp?$AAI?$AAD?$AA?$AA@ ; `string'
PUBLIC	?MAX_VERTEX_ELTS@CModel@@0HB			; CModel::MAX_VERTEX_ELTS
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?VT@?$CVarTypeInfo@D@ATL@@2GB			; ATL::CVarTypeInfo<char>::VT
PUBLIC	?pmField@?$CVarTypeInfo@D@ATL@@2QQtagVARIANT@@DQ3@ ; ATL::CVarTypeInfo<char>::pmField
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?ATL_CREATE_OBJECT@CComApartment@ATL@@2IA	; ATL::CComApartment::ATL_CREATE_OBJECT
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?VT@?$CVarTypeInfo@E@ATL@@2GB			; ATL::CVarTypeInfo<unsigned char>::VT
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?pmField@?$CVarTypeInfo@E@ATL@@2QQtagVARIANT@@EQ3@ ; ATL::CVarTypeInfo<unsigned char>::pmField
PUBLIC	?value@?$integral_constant@I$07@std@@2IB	; std::integral_constant<unsigned int,8>::value
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?VT@?$CVarTypeInfo@PAD@ATL@@2GB			; ATL::CVarTypeInfo<char *>::VT
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?pmField@?$CVarTypeInfo@PAD@ATL@@2QQtagVARIANT@@PADQ3@ ; ATL::CVarTypeInfo<char *>::pmField
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?chDirSep@ATL@@3_WB				; ATL::chDirSep
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?chRightBracket@ATL@@3_WB			; ATL::chRightBracket
PUBLIC	?chLeftBracket@ATL@@3_WB			; ATL::chLeftBracket
PUBLIC	?chQuote@ATL@@3_WB				; ATL::chQuote
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?chEquals@ATL@@3_WB				; ATL::chEquals
PUBLIC	?szStringVal@ATL@@3QB_WB			; ATL::szStringVal
PUBLIC	??_C@_13HADIAKP@?$AAS?$AA?$AA@			; `string'
PUBLIC	?multiszStringVal@ATL@@3QB_WB			; ATL::multiszStringVal
PUBLIC	?VT@?$CVarTypeInfo@PAE@ATL@@2GB			; ATL::CVarTypeInfo<unsigned char *>::VT
PUBLIC	??_C@_13LHMFKAAD@?$AAM?$AA?$AA@			; `string'
PUBLIC	?szDwordVal@ATL@@3QB_WB				; ATL::szDwordVal
PUBLIC	?pmField@?$CVarTypeInfo@PAE@ATL@@2QQtagVARIANT@@PAEQ3@ ; ATL::CVarTypeInfo<unsigned char *>::pmField
PUBLIC	_CLSID_Registrar
PUBLIC	??_C@_13MKMNOPIJ@?$AAD?$AA?$AA@			; `string'
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?szBinaryVal@ATL@@3QB_WB			; ATL::szBinaryVal
PUBLIC	??_C@_13OPKGLAFF@?$AAB?$AA?$AA@			; `string'
PUBLIC	?szValToken@ATL@@3QB_WB				; ATL::szValToken
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	??_C@_17LLMMEOJD@?$AAV?$AAa?$AAl?$AA?$AA@	; `string'
PUBLIC	?szForceRemove@ATL@@3QB_WB			; ATL::szForceRemove
PUBLIC	??_C@_1BI@JFAIJMHL@?$AAF?$AAo?$AAr?$AAc?$AAe?$AAR?$AAe?$AAm?$AAo?$AAv?$AAe?$AA?$AA@ ; `string'
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?szNoRemove@ATL@@3QB_WB				; ATL::szNoRemove
PUBLIC	??_C@_1BC@GCKHIPE@?$AAN?$AAo?$AAR?$AAe?$AAm?$AAo?$AAv?$AAe?$AA?$AA@ ; `string'
PUBLIC	?szDelete@ATL@@3QB_WB				; ATL::szDelete
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?VT@?$CVarTypeInfo@F@ATL@@2GB			; ATL::CVarTypeInfo<short>::VT
PUBLIC	??_C@_1O@JDLOHAN@?$AAD?$AAe?$AAl?$AAe?$AAt?$AAe?$AA?$AA@ ; `string'
PUBLIC	?pmField@?$CVarTypeInfo@F@ATL@@2QQtagVARIANT@@FQ3@ ; ATL::CVarTypeInfo<short>::pmField
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	__GUID_00000109_0000_0000_c000_000000000046
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	__GUID_7fd52380_4e07_101b_ae2d_08002b2ec713
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?VT@?$CVarTypeInfo@PAF@ATL@@2GB			; ATL::CVarTypeInfo<short *>::VT
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?pmField@?$CVarTypeInfo@PAF@ATL@@2QQtagVARIANT@@PAFQ3@ ; ATL::CVarTypeInfo<short *>::pmField
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	_IID_IRegistrar
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?value@?$integral_constant@I$03@std@@2IB	; std::integral_constant<unsigned int,4>::value
PUBLIC	?VT@?$CVarTypeInfo@G@ATL@@2GB			; ATL::CVarTypeInfo<unsigned short>::VT
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?pmField@?$CVarTypeInfo@G@ATL@@2QQtagVARIANT@@GQ3@ ; ATL::CVarTypeInfo<unsigned short>::pmField
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::hexfloat
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?_pAtlAutoThreadModule@ATL@@3PAUIAtlAutoThreadModule@1@A ; ATL::_pAtlAutoThreadModule
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?VT@?$CVarTypeInfo@PAG@ATL@@2GB			; ATL::CVarTypeInfo<unsigned short *>::VT
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?pmField@?$CVarTypeInfo@PAG@ATL@@2QQtagVARIANT@@PAGQ3@ ; ATL::CVarTypeInfo<unsigned short *>::pmField
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?VT@?$CVarTypeInfo@H@ATL@@2GB			; ATL::CVarTypeInfo<int>::VT
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?pmField@?$CVarTypeInfo@H@ATL@@2QQtagVARIANT@@HQ3@ ; ATL::CVarTypeInfo<int>::pmField
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?VT@?$CVarTypeInfo@PAH@ATL@@2GB			; ATL::CVarTypeInfo<int *>::VT
PUBLIC	?pmField@?$CVarTypeInfo@PAH@ATL@@2QQtagVARIANT@@PAHQ3@ ; ATL::CVarTypeInfo<int *>::pmField
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?VT@?$CVarTypeInfo@I@ATL@@2GB			; ATL::CVarTypeInfo<unsigned int>::VT
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?pmField@?$CVarTypeInfo@I@ATL@@2QQtagVARIANT@@IQ3@ ; ATL::CVarTypeInfo<unsigned int>::pmField
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?value@?$integral_constant@I$01@std@@2IB	; std::integral_constant<unsigned int,2>::value
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?VT@?$CVarTypeInfo@PAI@ATL@@2GB			; ATL::CVarTypeInfo<unsigned int *>::VT
PUBLIC	?pmField@?$CVarTypeInfo@PAI@ATL@@2QQtagVARIANT@@PAIQ3@ ; ATL::CVarTypeInfo<unsigned int *>::pmField
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
PUBLIC	?VT@?$CVarTypeInfo@J@ATL@@2GB			; ATL::CVarTypeInfo<long>::VT
PUBLIC	?pmField@?$CVarTypeInfo@J@ATL@@2QQtagVARIANT@@JQ3@ ; ATL::CVarTypeInfo<long>::pmField
PUBLIC	?VT@?$CVarTypeInfo@PAJ@ATL@@2GB			; ATL::CVarTypeInfo<long *>::VT
PUBLIC	?pmField@?$CVarTypeInfo@PAJ@ATL@@2QQtagVARIANT@@PAJQ3@ ; ATL::CVarTypeInfo<long *>::pmField
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?VT@?$CVarTypeInfo@K@ATL@@2GB			; ATL::CVarTypeInfo<unsigned long>::VT
PUBLIC	?pmField@?$CVarTypeInfo@K@ATL@@2QQtagVARIANT@@KQ3@ ; ATL::CVarTypeInfo<unsigned long>::pmField
PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?VT@?$CVarTypeInfo@PAK@ATL@@2GB			; ATL::CVarTypeInfo<unsigned long *>::VT
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?pmField@?$CVarTypeInfo@PAK@ATL@@2QQtagVARIANT@@PAKQ3@ ; ATL::CVarTypeInfo<unsigned long *>::pmField
PUBLIC	_IID_IDocHostUIHandlerDispatch
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?value@?$integral_constant@I$00@std@@2IB	; std::integral_constant<unsigned int,1>::value
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?VT@?$CVarTypeInfo@_J@ATL@@2GB			; ATL::CVarTypeInfo<__int64>::VT
PUBLIC	?pmField@?$CVarTypeInfo@_J@ATL@@2QQtagVARIANT@@_JQ3@ ; ATL::CVarTypeInfo<__int64>::pmField
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?VT@?$CVarTypeInfo@PA_J@ATL@@2GB		; ATL::CVarTypeInfo<__int64 *>::VT
PUBLIC	?value@?$_Maximum@$S@std@@2IB			; std::_Maximum<>::value
PUBLIC	?pmField@?$CVarTypeInfo@PA_J@ATL@@2QQtagVARIANT@@PA_JQ3@ ; ATL::CVarTypeInfo<__int64 *>::pmField
PUBLIC	?VT@?$CVarTypeInfo@_K@ATL@@2GB			; ATL::CVarTypeInfo<unsigned __int64>::VT
PUBLIC	?pmField@?$CVarTypeInfo@_K@ATL@@2QQtagVARIANT@@_KQ3@ ; ATL::CVarTypeInfo<unsigned __int64>::pmField
PUBLIC	?MAX_VALUE@CRegParser@ATL@@1HB			; ATL::CRegParser::MAX_VALUE
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?VT@?$CVarTypeInfo@PA_K@ATL@@2GB		; ATL::CVarTypeInfo<unsigned __int64 *>::VT
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?pmField@?$CVarTypeInfo@PA_K@ATL@@2QQtagVARIANT@@PA_KQ3@ ; ATL::CVarTypeInfo<unsigned __int64 *>::pmField
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?VT@?$CVarTypeInfo@M@ATL@@2GB			; ATL::CVarTypeInfo<float>::VT
PUBLIC	?pmField@?$CVarTypeInfo@M@ATL@@2QQtagVARIANT@@MQ3@ ; ATL::CVarTypeInfo<float>::pmField
PUBLIC	?VT@?$CVarTypeInfo@PAM@ATL@@2GB			; ATL::CVarTypeInfo<float *>::VT
PUBLIC	?pmField@?$CVarTypeInfo@PAM@ATL@@2QQtagVARIANT@@PAMQ3@ ; ATL::CVarTypeInfo<float *>::pmField
PUBLIC	?rgszNeverDelete@CRegParser@ATL@@1QBQB_WB	; ATL::CRegParser::rgszNeverDelete
PUBLIC	?cbNeverDelete@CRegParser@ATL@@1HB		; ATL::CRegParser::cbNeverDelete
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?MAX_TYPE@CRegParser@ATL@@1HB			; ATL::CRegParser::MAX_TYPE
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?VT@?$CVarTypeInfo@N@ATL@@2GB			; ATL::CVarTypeInfo<double>::VT
PUBLIC	?pmField@?$CVarTypeInfo@N@ATL@@2QQtagVARIANT@@NQ3@ ; ATL::CVarTypeInfo<double>::pmField
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?VT@?$CVarTypeInfo@PAN@ATL@@2GB			; ATL::CVarTypeInfo<double *>::VT
PUBLIC	?pmField@?$CVarTypeInfo@PAN@ATL@@2QQtagVARIANT@@PANQ3@ ; ATL::CVarTypeInfo<double *>::pmField
PUBLIC	?VT@?$CVarTypeInfo@PAUtagVARIANT@@@ATL@@2GB	; ATL::CVarTypeInfo<tagVARIANT *>::VT
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?VT@?$CVarTypeInfo@PA_W@ATL@@2GB		; ATL::CVarTypeInfo<wchar_t *>::VT
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?pmField@?$CVarTypeInfo@PA_W@ATL@@2QQtagVARIANT@@PA_WQ3@ ; ATL::CVarTypeInfo<wchar_t *>::pmField
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?VT@?$CVarTypeInfo@PAPA_W@ATL@@2GB		; ATL::CVarTypeInfo<wchar_t * *>::VT
PUBLIC	?pmField@?$CVarTypeInfo@PAPA_W@ATL@@2QQtagVARIANT@@PAPA_WQ3@ ; ATL::CVarTypeInfo<wchar_t * *>::pmField
PUBLIC	?m_bInitFailed@CAtlBaseModule@ATL@@2_NA		; ATL::CAtlBaseModule::m_bInitFailed
PUBLIC	?VT@?$CVarTypeInfo@PAUIUnknown@@@ATL@@2GB	; ATL::CVarTypeInfo<IUnknown *>::VT
PUBLIC	?pmField@?$CVarTypeInfo@PAUIUnknown@@@ATL@@2QQtagVARIANT@@PAUIUnknown@@Q3@ ; ATL::CVarTypeInfo<IUnknown *>::pmField
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?VT@?$CVarTypeInfo@PAPAUIUnknown@@@ATL@@2GB	; ATL::CVarTypeInfo<IUnknown * *>::VT
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?m_nLevel@CTrace@ATL@@1IA			; ATL::CTrace::m_nLevel
PUBLIC	?pmField@?$CVarTypeInfo@PAPAUIUnknown@@@ATL@@2QQtagVARIANT@@PAPAUIUnknown@@Q3@ ; ATL::CVarTypeInfo<IUnknown * *>::pmField
PUBLIC	?m_nCategory@CTrace@ATL@@1IA			; ATL::CTrace::m_nCategory
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?m_nLastCategory@CTrace@ATL@@1IA		; ATL::CTrace::m_nLastCategory
PUBLIC	?m_nMap@CTrace@ATL@@1PAUCategoryMap@12@A	; ATL::CTrace::m_nMap
PUBLIC	?VT@?$CVarTypeInfo@PAUIDispatch@@@ATL@@2GB	; ATL::CVarTypeInfo<IDispatch *>::VT
PUBLIC	?pmField@?$CVarTypeInfo@PAUIDispatch@@@ATL@@2QQtagVARIANT@@PAUIDispatch@@Q3@ ; ATL::CVarTypeInfo<IDispatch *>::pmField
PUBLIC	__GUID_00000000_0000_0000_c000_000000000046
PUBLIC	?VT@?$CVarTypeInfo@PAPAUIDispatch@@@ATL@@2GB	; ATL::CVarTypeInfo<IDispatch * *>::VT
PUBLIC	?pmField@?$CVarTypeInfo@PAPAUIDispatch@@@ATL@@2QQtagVARIANT@@PAPAUIDispatch@@Q3@ ; ATL::CVarTypeInfo<IDispatch * *>::pmField
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?_pAtlModule@ATL@@3PAVCAtlModule@1@A		; ATL::_pAtlModule
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?VT@?$CVarTypeInfo@TtagCY@@@ATL@@2GB		; ATL::CVarTypeInfo<tagCY>::VT
PUBLIC	?pmField@?$CVarTypeInfo@TtagCY@@@ATL@@2QQtagVARIANT@@TtagCY@@Q3@ ; ATL::CVarTypeInfo<tagCY>::pmField
PUBLIC	__GUID_00020400_0000_0000_c000_000000000046
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?m_libid@CAtlModule@ATL@@2U_GUID@@A		; ATL::CAtlModule::m_libid
PUBLIC	_IID_IAxWinHostWindow
PUBLIC	?VT@?$CVarTypeInfo@PATtagCY@@@ATL@@2GB		; ATL::CVarTypeInfo<tagCY *>::VT
PUBLIC	?pmField@?$CVarTypeInfo@PATtagCY@@@ATL@@2QQtagVARIANT@@PATtagCY@@Q3@ ; ATL::CVarTypeInfo<tagCY *>::pmField
PUBLIC	?table_size@?$ctype@D@std@@2IB			; std::ctype<char>::table_size
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?mViewportWidth@CScene@@0HA			; CScene::mViewportWidth
PUBLIC	?mViewportHeight@CScene@@0HA			; CScene::mViewportHeight
PUBLIC	?MAX_LIGHTS@CScene@@0HB				; CScene::MAX_LIGHTS
PUBLIC	__GUID_00000146_0000_0000_c000_000000000046
PUBLIC	?MAX_SHADER_LIGHTS@CScene@@0HB			; CScene::MAX_SHADER_LIGHTS
PUBLIC	?MAX_OBJECTS@CScene@@0HB			; CScene::MAX_OBJECTS
PUBLIC	?GRIDSIZE@CScene@@0HB				; CScene::GRIDSIZE
PUBLIC	_IID_IAxWinHostWindowLic
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	_IID_IAxWinAmbientDispatch
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	__GUID_b196b284_bab4_101a_b69c_00aa00341d07
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	_LIBID_ATLLib
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?s_pfnPrevHook@CNoUIAssertHook@ATL@@0P6AHHPADPAH@ZA ; ATL::CNoUIAssertHook::s_pfnPrevHook
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?_pModule@ATL@@3PAVCComModule@1@A		; ATL::_pModule
PUBLIC	___pobjMapEntryFirst
PUBLIC	___pobjMapEntryLast
PUBLIC	?_pPerfRegFunc@ATL@@3P6AJPAUHINSTANCE__@@@ZA	; ATL::_pPerfRegFunc
PUBLIC	?_pPerfUnRegFunc@ATL@@3P6AJXZA			; ATL::_pPerfUnRegFunc
PUBLIC	?_AtlRegisterPerUser@ATL@@3_NA			; ATL::_AtlRegisterPerUser
PUBLIC	?_Min@?$AtlLimits@H@ATL@@2HB			; ATL::AtlLimits<int>::_Min
PUBLIC	?_Max@?$AtlLimits@H@ATL@@2HB			; ATL::AtlLimits<int>::_Max
PUBLIC	??_C@_1CK@OEKPKBNA@?$AAC?$AAo?$AAm?$AAp?$AAo?$AAn?$AAe?$AAn?$AAt?$AA?5?$AAC?$AAa?$AAt?$AAe?$AAg?$AAo?$AAr?$AAi?$AAe?$AAs?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BC@NKMMNMGL@?$AAF?$AAi?$AAl?$AAe?$AAT?$AAy?$AAp?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BE@EKPAFMCP@?$AAI?$AAn?$AAt?$AAe?$AAr?$AAf?$AAa?$AAc?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BC@MAICEHGI@?$AAH?$AAa?$AAr?$AAd?$AAw?$AAa?$AAr?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_19HLLLM@?$AAM?$AAi?$AAm?$AAe?$AA?$AA@	; `string'
PUBLIC	?_Min@?$AtlLimits@I@ATL@@2IB			; ATL::AtlLimits<unsigned int>::_Min
PUBLIC	??_C@_17OMAOINJK@?$AAS?$AAA?$AAM?$AA?$AA@	; `string'
PUBLIC	??_C@_1BC@IBECJAAI@?$AAS?$AAE?$AAC?$AAU?$AAR?$AAI?$AAT?$AAY?$AA?$AA@ ; `string'
PUBLIC	?_Max@?$AtlLimits@I@ATL@@2IB			; ATL::AtlLimits<unsigned int>::_Max
PUBLIC	??_C@_1O@GBFINDKL@?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BC@EAHCMADO@?$AAS?$AAo?$AAf?$AAt?$AAw?$AAa?$AAr?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BA@JIHHIEDE@?$AAT?$AAy?$AAp?$AAe?$AAL?$AAi?$AAb?$AA?$AA@ ; `string'
PUBLIC	?_Min@?$AtlLimits@J@ATL@@2JB			; ATL::AtlLimits<long>::_Min
PUBLIC	?_Max@?$AtlLimits@J@ATL@@2JB			; ATL::AtlLimits<long>::_Max
PUBLIC	?_Min@?$AtlLimits@K@ATL@@2KB			; ATL::AtlLimits<unsigned long>::_Min
PUBLIC	?_Max@?$AtlLimits@K@ATL@@2KB			; ATL::AtlLimits<unsigned long>::_Max
;	COMDAT ?ATL_CREATE_OBJECT@CComApartment@ATL@@2IA
_BSS	SEGMENT
?ATL_CREATE_OBJECT@CComApartment@ATL@@2IA DD 01H DUP (?) ; ATL::CComApartment::ATL_CREATE_OBJECT
_BSS	ENDS
;	COMDAT ?_pAtlAutoThreadModule@ATL@@3PAUIAtlAutoThreadModule@1@A
_BSS	SEGMENT
?_pAtlAutoThreadModule@ATL@@3PAUIAtlAutoThreadModule@1@A DD 01H DUP (?) ; ATL::_pAtlAutoThreadModule
_BSS	ENDS
;	COMDAT ?m_bInitFailed@CAtlBaseModule@ATL@@2_NA
_BSS	SEGMENT
?m_bInitFailed@CAtlBaseModule@ATL@@2_NA DB 01H DUP (?)	; ATL::CAtlBaseModule::m_bInitFailed
_BSS	ENDS
;	COMDAT ?m_nLevel@CTrace@ATL@@1IA
_BSS	SEGMENT
?m_nLevel@CTrace@ATL@@1IA DD 01H DUP (?)		; ATL::CTrace::m_nLevel
_BSS	ENDS
;	COMDAT ?m_nLastCategory@CTrace@ATL@@1IA
_BSS	SEGMENT
?m_nLastCategory@CTrace@ATL@@1IA DD 01H DUP (?)		; ATL::CTrace::m_nLastCategory
_BSS	ENDS
;	COMDAT ?m_nMap@CTrace@ATL@@1PAUCategoryMap@12@A
_BSS	SEGMENT
?m_nMap@CTrace@ATL@@1PAUCategoryMap@12@A DB 02080H DUP (?) ; ATL::CTrace::m_nMap
_BSS	ENDS
;	COMDAT ?_pAtlModule@ATL@@3PAVCAtlModule@1@A
_BSS	SEGMENT
?_pAtlModule@ATL@@3PAVCAtlModule@1@A DD 01H DUP (?)	; ATL::_pAtlModule
_BSS	ENDS
;	COMDAT ?m_libid@CAtlModule@ATL@@2U_GUID@@A
_BSS	SEGMENT
?m_libid@CAtlModule@ATL@@2U_GUID@@A DB 010H DUP (?)	; ATL::CAtlModule::m_libid
_BSS	ENDS
_BSS	SEGMENT
?mViewportWidth@CScene@@0HA DD 01H DUP (?)		; CScene::mViewportWidth
?mViewportHeight@CScene@@0HA DD 01H DUP (?)		; CScene::mViewportHeight
_BSS	ENDS
;	COMDAT ?s_pfnPrevHook@CNoUIAssertHook@ATL@@0P6AHHPADPAH@ZA
_BSS	SEGMENT
?s_pfnPrevHook@CNoUIAssertHook@ATL@@0P6AHHPADPAH@ZA DD 01H DUP (?) ; ATL::CNoUIAssertHook::s_pfnPrevHook
_BSS	ENDS
;	COMDAT ?_pModule@ATL@@3PAVCComModule@1@A
_BSS	SEGMENT
?_pModule@ATL@@3PAVCComModule@1@A DD 01H DUP (?)	; ATL::_pModule
_BSS	ENDS
;	COMDAT ?_pPerfRegFunc@ATL@@3P6AJPAUHINSTANCE__@@@ZA
_BSS	SEGMENT
?_pPerfRegFunc@ATL@@3P6AJPAUHINSTANCE__@@@ZA DD 01H DUP (?) ; ATL::_pPerfRegFunc
_BSS	ENDS
;	COMDAT ?_pPerfUnRegFunc@ATL@@3P6AJXZA
_BSS	SEGMENT
?_pPerfUnRegFunc@ATL@@3P6AJXZA DD 01H DUP (?)		; ATL::_pPerfUnRegFunc
_BSS	ENDS
;	COMDAT ?_AtlRegisterPerUser@ATL@@3_NA
_BSS	SEGMENT
?_AtlRegisterPerUser@ATL@@3_NA DB 01H DUP (?)		; ATL::_AtlRegisterPerUser
_BSS	ENDS
;	COMDAT ?_Max@?$AtlLimits@K@ATL@@2KB
CONST	SEGMENT
?_Max@?$AtlLimits@K@ATL@@2KB DD 0ffffffffH		; ATL::AtlLimits<unsigned long>::_Max
CONST	ENDS
;	COMDAT ?_Min@?$AtlLimits@K@ATL@@2KB
CONST	SEGMENT
?_Min@?$AtlLimits@K@ATL@@2KB DD 00H			; ATL::AtlLimits<unsigned long>::_Min
CONST	ENDS
;	COMDAT ?_Max@?$AtlLimits@J@ATL@@2JB
CONST	SEGMENT
?_Max@?$AtlLimits@J@ATL@@2JB DD 07fffffffH		; ATL::AtlLimits<long>::_Max
CONST	ENDS
;	COMDAT ?_Min@?$AtlLimits@J@ATL@@2JB
CONST	SEGMENT
?_Min@?$AtlLimits@J@ATL@@2JB DD 080000000H		; ATL::AtlLimits<long>::_Min
CONST	ENDS
;	COMDAT ??_C@_1BA@JIHHIEDE@?$AAT?$AAy?$AAp?$AAe?$AAL?$AAi?$AAb?$AA?$AA@
CONST	SEGMENT
??_C@_1BA@JIHHIEDE@?$AAT?$AAy?$AAp?$AAe?$AAL?$AAi?$AAb?$AA?$AA@ DB 'T', 00H
	DB	'y', 00H, 'p', 00H, 'e', 00H, 'L', 00H, 'i', 00H, 'b', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1BC@EAHCMADO@?$AAS?$AAo?$AAf?$AAt?$AAw?$AAa?$AAr?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1BC@EAHCMADO@?$AAS?$AAo?$AAf?$AAt?$AAw?$AAa?$AAr?$AAe?$AA?$AA@ DB 'S'
	DB	00H, 'o', 00H, 'f', 00H, 't', 00H, 'w', 00H, 'a', 00H, 'r', 00H
	DB	'e', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1O@GBFINDKL@?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA?$AA@
CONST	SEGMENT
??_C@_1O@GBFINDKL@?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA?$AA@ DB 'S', 00H, 'Y'
	DB	00H, 'S', 00H, 'T', 00H, 'E', 00H, 'M', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ?_Max@?$AtlLimits@I@ATL@@2IB
CONST	SEGMENT
?_Max@?$AtlLimits@I@ATL@@2IB DD 0ffffffffH		; ATL::AtlLimits<unsigned int>::_Max
CONST	ENDS
;	COMDAT ??_C@_1BC@IBECJAAI@?$AAS?$AAE?$AAC?$AAU?$AAR?$AAI?$AAT?$AAY?$AA?$AA@
CONST	SEGMENT
??_C@_1BC@IBECJAAI@?$AAS?$AAE?$AAC?$AAU?$AAR?$AAI?$AAT?$AAY?$AA?$AA@ DB 'S'
	DB	00H, 'E', 00H, 'C', 00H, 'U', 00H, 'R', 00H, 'I', 00H, 'T', 00H
	DB	'Y', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_17OMAOINJK@?$AAS?$AAA?$AAM?$AA?$AA@
CONST	SEGMENT
??_C@_17OMAOINJK@?$AAS?$AAA?$AAM?$AA?$AA@ DB 'S', 00H, 'A', 00H, 'M', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ?_Min@?$AtlLimits@I@ATL@@2IB
CONST	SEGMENT
?_Min@?$AtlLimits@I@ATL@@2IB DD 00H			; ATL::AtlLimits<unsigned int>::_Min
CONST	ENDS
;	COMDAT ??_C@_19HLLLM@?$AAM?$AAi?$AAm?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_19HLLLM@?$AAM?$AAi?$AAm?$AAe?$AA?$AA@ DB 'M', 00H, 'i', 00H, 'm', 00H
	DB	'e', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BC@MAICEHGI@?$AAH?$AAa?$AAr?$AAd?$AAw?$AAa?$AAr?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1BC@MAICEHGI@?$AAH?$AAa?$AAr?$AAd?$AAw?$AAa?$AAr?$AAe?$AA?$AA@ DB 'H'
	DB	00H, 'a', 00H, 'r', 00H, 'd', 00H, 'w', 00H, 'a', 00H, 'r', 00H
	DB	'e', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BE@EKPAFMCP@?$AAI?$AAn?$AAt?$AAe?$AAr?$AAf?$AAa?$AAc?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1BE@EKPAFMCP@?$AAI?$AAn?$AAt?$AAe?$AAr?$AAf?$AAa?$AAc?$AAe?$AA?$AA@ DB 'I'
	DB	00H, 'n', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'f', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1BC@NKMMNMGL@?$AAF?$AAi?$AAl?$AAe?$AAT?$AAy?$AAp?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1BC@NKMMNMGL@?$AAF?$AAi?$AAl?$AAe?$AAT?$AAy?$AAp?$AAe?$AA?$AA@ DB 'F'
	DB	00H, 'i', 00H, 'l', 00H, 'e', 00H, 'T', 00H, 'y', 00H, 'p', 00H
	DB	'e', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1CK@OEKPKBNA@?$AAC?$AAo?$AAm?$AAp?$AAo?$AAn?$AAe?$AAn?$AAt?$AA?5?$AAC?$AAa?$AAt?$AAe?$AAg?$AAo?$AAr?$AAi?$AAe?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1CK@OEKPKBNA@?$AAC?$AAo?$AAm?$AAp?$AAo?$AAn?$AAe?$AAn?$AAt?$AA?5?$AAC?$AAa?$AAt?$AAe?$AAg?$AAo?$AAr?$AAi?$AAe?$AAs?$AA?$AA@ DB 'C'
	DB	00H, 'o', 00H, 'm', 00H, 'p', 00H, 'o', 00H, 'n', 00H, 'e', 00H
	DB	'n', 00H, 't', 00H, ' ', 00H, 'C', 00H, 'a', 00H, 't', 00H, 'e'
	DB	00H, 'g', 00H, 'o', 00H, 'r', 00H, 'i', 00H, 'e', 00H, 's', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ?_Max@?$AtlLimits@H@ATL@@2HB
CONST	SEGMENT
?_Max@?$AtlLimits@H@ATL@@2HB DD 07fffffffH		; ATL::AtlLimits<int>::_Max
CONST	ENDS
;	COMDAT ?_Min@?$AtlLimits@H@ATL@@2HB
CONST	SEGMENT
?_Min@?$AtlLimits@H@ATL@@2HB DD 080000000H		; ATL::AtlLimits<int>::_Min
CONST	ENDS
;	COMDAT ___pobjMapEntryLast
ATL$__z	SEGMENT
___pobjMapEntryLast DD 00H
ATL$__z	ENDS
;	COMDAT ___pobjMapEntryFirst
ATL$__a	SEGMENT
___pobjMapEntryFirst DD 00H
ATL$__a	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT _LIBID_ATLLib
CONST	SEGMENT
_LIBID_ATLLib DD 044ec0535H
	DW	0400fH
	DW	011d0H
	DB	09dH
	DB	0cdH
	DB	00H
	DB	0a0H
	DB	0c9H
	DB	03H
	DB	091H
	DB	0d3H
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT __GUID_b196b284_bab4_101a_b69c_00aa00341d07
CONST	SEGMENT
__GUID_b196b284_bab4_101a_b69c_00aa00341d07 DD 0b196b284H
	DW	0bab4H
	DW	0101aH
	DB	0b6H
	DB	09cH
	DB	00H
	DB	0aaH
	DB	00H
	DB	034H
	DB	01dH
	DB	07H
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT _IID_IAxWinAmbientDispatch
CONST	SEGMENT
_IID_IAxWinAmbientDispatch DD 0b6ea2051H
	DW	048aH
	DW	011d1H
	DB	082H
	DB	0b9H
	DB	00H
	DB	0c0H
	DB	04fH
	DB	0b9H
	DB	094H
	DB	02eH
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT _IID_IAxWinHostWindowLic
CONST	SEGMENT
_IID_IAxWinHostWindowLic DD 03935bda8H
	DW	04ed9H
	DW	0495cH
	DB	086H
	DB	050H
	DB	0e0H
	DB	01fH
	DB	0c1H
	DB	0e3H
	DB	08aH
	DB	04bH
CONST	ENDS
;	COMDAT ?GRIDSIZE@CScene@@0HB
CONST	SEGMENT
?GRIDSIZE@CScene@@0HB DD 01eH				; CScene::GRIDSIZE
CONST	ENDS
;	COMDAT ?MAX_OBJECTS@CScene@@0HB
CONST	SEGMENT
?MAX_OBJECTS@CScene@@0HB DD 07d0H			; CScene::MAX_OBJECTS
CONST	ENDS
;	COMDAT ?MAX_SHADER_LIGHTS@CScene@@0HB
CONST	SEGMENT
?MAX_SHADER_LIGHTS@CScene@@0HB DD 0cH			; CScene::MAX_SHADER_LIGHTS
CONST	ENDS
;	COMDAT __GUID_00000146_0000_0000_c000_000000000046
CONST	SEGMENT
__GUID_00000146_0000_0000_c000_000000000046 DD 0146H
	DW	00H
	DW	00H
	DB	0c0H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	046H
CONST	ENDS
;	COMDAT ?MAX_LIGHTS@CScene@@0HB
CONST	SEGMENT
?MAX_LIGHTS@CScene@@0HB DD 01eH				; CScene::MAX_LIGHTS
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?table_size@?$ctype@D@std@@2IB
CONST	SEGMENT
?table_size@?$ctype@D@std@@2IB DD 0100H			; std::ctype<char>::table_size
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PATtagCY@@@ATL@@2QQtagVARIANT@@PATtagCY@@Q3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PATtagCY@@@ATL@@2QQtagVARIANT@@PATtagCY@@Q3@ DD 08H ; ATL::CVarTypeInfo<tagCY *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PATtagCY@@@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PATtagCY@@@ATL@@2GB DW 04006H	; ATL::CVarTypeInfo<tagCY *>::VT
CONST	ENDS
;	COMDAT _IID_IAxWinHostWindow
CONST	SEGMENT
_IID_IAxWinHostWindow DD 0b6ea2050H
	DW	048aH
	DW	011d1H
	DB	082H
	DB	0b9H
	DB	00H
	DB	0c0H
	DB	04fH
	DB	0b9H
	DB	094H
	DB	02eH
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT __GUID_00020400_0000_0000_c000_000000000046
CONST	SEGMENT
__GUID_00020400_0000_0000_c000_000000000046 DD 020400H
	DW	00H
	DW	00H
	DB	0c0H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	046H
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@TtagCY@@@ATL@@2QQtagVARIANT@@TtagCY@@Q3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@TtagCY@@@ATL@@2QQtagVARIANT@@TtagCY@@Q3@ DD 08H ; ATL::CVarTypeInfo<tagCY>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@TtagCY@@@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@TtagCY@@@ATL@@2GB DW 06H		; ATL::CVarTypeInfo<tagCY>::VT
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAPAUIDispatch@@@ATL@@2QQtagVARIANT@@PAPAUIDispatch@@Q3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAPAUIDispatch@@@ATL@@2QQtagVARIANT@@PAPAUIDispatch@@Q3@ DD 08H ; ATL::CVarTypeInfo<IDispatch * *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAPAUIDispatch@@@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAPAUIDispatch@@@ATL@@2GB DW 04009H	; ATL::CVarTypeInfo<IDispatch * *>::VT
CONST	ENDS
;	COMDAT __GUID_00000000_0000_0000_c000_000000000046
CONST	SEGMENT
__GUID_00000000_0000_0000_c000_000000000046 DD 00H
	DW	00H
	DW	00H
	DB	0c0H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	046H
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAUIDispatch@@@ATL@@2QQtagVARIANT@@PAUIDispatch@@Q3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAUIDispatch@@@ATL@@2QQtagVARIANT@@PAUIDispatch@@Q3@ DD 08H ; ATL::CVarTypeInfo<IDispatch *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAUIDispatch@@@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAUIDispatch@@@ATL@@2GB DW 09H	; ATL::CVarTypeInfo<IDispatch *>::VT
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?m_nCategory@CTrace@ATL@@1IA
_DATA	SEGMENT
?m_nCategory@CTrace@ATL@@1IA DD 0ffffffffH		; ATL::CTrace::m_nCategory
_DATA	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAPAUIUnknown@@@ATL@@2QQtagVARIANT@@PAPAUIUnknown@@Q3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAPAUIUnknown@@@ATL@@2QQtagVARIANT@@PAPAUIUnknown@@Q3@ DD 08H ; ATL::CVarTypeInfo<IUnknown * *>::pmField
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAPAUIUnknown@@@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAPAUIUnknown@@@ATL@@2GB DW 0400dH	; ATL::CVarTypeInfo<IUnknown * *>::VT
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAUIUnknown@@@ATL@@2QQtagVARIANT@@PAUIUnknown@@Q3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAUIUnknown@@@ATL@@2QQtagVARIANT@@PAUIUnknown@@Q3@ DD 08H ; ATL::CVarTypeInfo<IUnknown *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAUIUnknown@@@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAUIUnknown@@@ATL@@2GB DW 0dH	; ATL::CVarTypeInfo<IUnknown *>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAPA_W@ATL@@2QQtagVARIANT@@PAPA_WQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAPA_W@ATL@@2QQtagVARIANT@@PAPA_WQ3@ DD 08H ; ATL::CVarTypeInfo<wchar_t * *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAPA_W@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAPA_W@ATL@@2GB DW 04008H		; ATL::CVarTypeInfo<wchar_t * *>::VT
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PA_W@ATL@@2QQtagVARIANT@@PA_WQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PA_W@ATL@@2QQtagVARIANT@@PA_WQ3@ DD 08H ; ATL::CVarTypeInfo<wchar_t *>::pmField
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PA_W@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PA_W@ATL@@2GB DW 08H			; ATL::CVarTypeInfo<wchar_t *>::VT
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAUtagVARIANT@@@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAUtagVARIANT@@@ATL@@2GB DW 0400cH	; ATL::CVarTypeInfo<tagVARIANT *>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAN@ATL@@2QQtagVARIANT@@PANQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAN@ATL@@2QQtagVARIANT@@PANQ3@ DD 08H ; ATL::CVarTypeInfo<double *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAN@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAN@ATL@@2GB DW 04005H		; ATL::CVarTypeInfo<double *>::VT
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@N@ATL@@2QQtagVARIANT@@NQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@N@ATL@@2QQtagVARIANT@@NQ3@ DD 08H ; ATL::CVarTypeInfo<double>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@N@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@N@ATL@@2GB DW 05H			; ATL::CVarTypeInfo<double>::VT
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?MAX_TYPE@CRegParser@ATL@@1HB
CONST	SEGMENT
?MAX_TYPE@CRegParser@ATL@@1HB DD 01000H			; ATL::CRegParser::MAX_TYPE
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?cbNeverDelete@CRegParser@ATL@@1HB
CONST	SEGMENT
?cbNeverDelete@CRegParser@ATL@@1HB DD 0cH		; ATL::CRegParser::cbNeverDelete
CONST	ENDS
;	COMDAT ?rgszNeverDelete@CRegParser@ATL@@1QBQB_WB
CONST	SEGMENT
?rgszNeverDelete@CRegParser@ATL@@1QBQB_WB DD FLAT:??_C@_1M@EJNEECMJ@?$AAA?$AAp?$AAp?$AAI?$AAD?$AA?$AA@ ; ATL::CRegParser::rgszNeverDelete
	DD	FLAT:??_C@_1M@KANJNLFF@?$AAC?$AAL?$AAS?$AAI?$AAD?$AA?$AA@
	DD	FLAT:??_C@_1CK@OEKPKBNA@?$AAC?$AAo?$AAm?$AAp?$AAo?$AAn?$AAe?$AAn?$AAt?$AA?5?$AAC?$AAa?$AAt?$AAe?$AAg?$AAo?$AAr?$AAi?$AAe?$AAs?$AA?$AA@
	DD	FLAT:??_C@_1BC@NKMMNMGL@?$AAF?$AAi?$AAl?$AAe?$AAT?$AAy?$AAp?$AAe?$AA?$AA@
	DD	FLAT:??_C@_1BE@EKPAFMCP@?$AAI?$AAn?$AAt?$AAe?$AAr?$AAf?$AAa?$AAc?$AAe?$AA?$AA@
	DD	FLAT:??_C@_1BC@MAICEHGI@?$AAH?$AAa?$AAr?$AAd?$AAw?$AAa?$AAr?$AAe?$AA?$AA@
	DD	FLAT:??_C@_19HLLLM@?$AAM?$AAi?$AAm?$AAe?$AA?$AA@
	DD	FLAT:??_C@_17OMAOINJK@?$AAS?$AAA?$AAM?$AA?$AA@
	DD	FLAT:??_C@_1BC@IBECJAAI@?$AAS?$AAE?$AAC?$AAU?$AAR?$AAI?$AAT?$AAY?$AA?$AA@
	DD	FLAT:??_C@_1O@GBFINDKL@?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA?$AA@
	DD	FLAT:??_C@_1BC@EAHCMADO@?$AAS?$AAo?$AAf?$AAt?$AAw?$AAa?$AAr?$AAe?$AA?$AA@
	DD	FLAT:??_C@_1BA@JIHHIEDE@?$AAT?$AAy?$AAp?$AAe?$AAL?$AAi?$AAb?$AA?$AA@
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAM@ATL@@2QQtagVARIANT@@PAMQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAM@ATL@@2QQtagVARIANT@@PAMQ3@ DD 08H ; ATL::CVarTypeInfo<float *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAM@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAM@ATL@@2GB DW 04004H		; ATL::CVarTypeInfo<float *>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@M@ATL@@2QQtagVARIANT@@MQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@M@ATL@@2QQtagVARIANT@@MQ3@ DD 08H ; ATL::CVarTypeInfo<float>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@M@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@M@ATL@@2GB DW 04H			; ATL::CVarTypeInfo<float>::VT
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PA_K@ATL@@2QQtagVARIANT@@PA_KQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PA_K@ATL@@2QQtagVARIANT@@PA_KQ3@ DD 08H ; ATL::CVarTypeInfo<unsigned __int64 *>::pmField
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PA_K@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PA_K@ATL@@2GB DW 04015H		; ATL::CVarTypeInfo<unsigned __int64 *>::VT
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?MAX_VALUE@CRegParser@ATL@@1HB
CONST	SEGMENT
?MAX_VALUE@CRegParser@ATL@@1HB DD 01000H		; ATL::CRegParser::MAX_VALUE
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@_K@ATL@@2QQtagVARIANT@@_KQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@_K@ATL@@2QQtagVARIANT@@_KQ3@ DD 08H ; ATL::CVarTypeInfo<unsigned __int64>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@_K@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@_K@ATL@@2GB DW 015H			; ATL::CVarTypeInfo<unsigned __int64>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PA_J@ATL@@2QQtagVARIANT@@PA_JQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PA_J@ATL@@2QQtagVARIANT@@PA_JQ3@ DD 08H ; ATL::CVarTypeInfo<__int64 *>::pmField
CONST	ENDS
;	COMDAT ?value@?$_Maximum@$S@std@@2IB
CONST	SEGMENT
?value@?$_Maximum@$S@std@@2IB DD 00H			; std::_Maximum<>::value
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PA_J@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PA_J@ATL@@2GB DW 04014H		; ATL::CVarTypeInfo<__int64 *>::VT
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@_J@ATL@@2QQtagVARIANT@@_JQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@_J@ATL@@2QQtagVARIANT@@_JQ3@ DD 08H ; ATL::CVarTypeInfo<__int64>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@_J@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@_J@ATL@@2GB DW 014H			; ATL::CVarTypeInfo<__int64>::VT
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$00@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$00@std@@2IB DD 01H		; std::integral_constant<unsigned int,1>::value
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT _IID_IDocHostUIHandlerDispatch
CONST	SEGMENT
_IID_IDocHostUIHandlerDispatch DD 0425b5af0H
	DW	065f1H
	DW	011d1H
	DB	096H
	DB	011H
	DB	00H
	DB	00H
	DB	0f8H
	DB	01eH
	DB	0dH
	DB	0dH
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAK@ATL@@2QQtagVARIANT@@PAKQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAK@ATL@@2QQtagVARIANT@@PAKQ3@ DD 08H ; ATL::CVarTypeInfo<unsigned long *>::pmField
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAK@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAK@ATL@@2GB DW 04013H		; ATL::CVarTypeInfo<unsigned long *>::VT
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@K@ATL@@2QQtagVARIANT@@KQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@K@ATL@@2QQtagVARIANT@@KQ3@ DD 08H ; ATL::CVarTypeInfo<unsigned long>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@K@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@K@ATL@@2GB DW 013H			; ATL::CVarTypeInfo<unsigned long>::VT
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAJ@ATL@@2QQtagVARIANT@@PAJQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAJ@ATL@@2QQtagVARIANT@@PAJQ3@ DD 08H ; ATL::CVarTypeInfo<long *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAJ@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAJ@ATL@@2GB DW 04003H		; ATL::CVarTypeInfo<long *>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@J@ATL@@2QQtagVARIANT@@JQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@J@ATL@@2QQtagVARIANT@@JQ3@ DD 08H ; ATL::CVarTypeInfo<long>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@J@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@J@ATL@@2GB DW 03H			; ATL::CVarTypeInfo<long>::VT
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAI@ATL@@2QQtagVARIANT@@PAIQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAI@ATL@@2QQtagVARIANT@@PAIQ3@ DD 08H ; ATL::CVarTypeInfo<unsigned int *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAI@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAI@ATL@@2GB DW 04013H		; ATL::CVarTypeInfo<unsigned int *>::VT
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$01@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$01@std@@2IB DD 02H		; std::integral_constant<unsigned int,2>::value
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@I@ATL@@2QQtagVARIANT@@IQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@I@ATL@@2QQtagVARIANT@@IQ3@ DD 08H ; ATL::CVarTypeInfo<unsigned int>::pmField
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@I@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@I@ATL@@2GB DW 013H			; ATL::CVarTypeInfo<unsigned int>::VT
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAH@ATL@@2QQtagVARIANT@@PAHQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAH@ATL@@2QQtagVARIANT@@PAHQ3@ DD 08H ; ATL::CVarTypeInfo<int *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAH@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAH@ATL@@2GB DW 04003H		; ATL::CVarTypeInfo<int *>::VT
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@H@ATL@@2QQtagVARIANT@@HQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@H@ATL@@2QQtagVARIANT@@HQ3@ DD 08H ; ATL::CVarTypeInfo<int>::pmField
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@H@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@H@ATL@@2GB DW 03H			; ATL::CVarTypeInfo<int>::VT
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAG@ATL@@2QQtagVARIANT@@PAGQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAG@ATL@@2QQtagVARIANT@@PAGQ3@ DD 08H ; ATL::CVarTypeInfo<unsigned short *>::pmField
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAG@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAG@ATL@@2GB DW 04012H		; ATL::CVarTypeInfo<unsigned short *>::VT
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::hexfloat
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@G@ATL@@2QQtagVARIANT@@GQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@G@ATL@@2QQtagVARIANT@@GQ3@ DD 08H ; ATL::CVarTypeInfo<unsigned short>::pmField
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@G@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@G@ATL@@2GB DW 012H			; ATL::CVarTypeInfo<unsigned short>::VT
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$03@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$03@std@@2IB DD 04H		; std::integral_constant<unsigned int,4>::value
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT _IID_IRegistrar
CONST	SEGMENT
_IID_IRegistrar DD 044ec053bH
	DW	0400fH
	DW	011d0H
	DB	09dH
	DB	0cdH
	DB	00H
	DB	0a0H
	DB	0c9H
	DB	03H
	DB	091H
	DB	0d3H
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAF@ATL@@2QQtagVARIANT@@PAFQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAF@ATL@@2QQtagVARIANT@@PAFQ3@ DD 08H ; ATL::CVarTypeInfo<short *>::pmField
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAF@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAF@ATL@@2GB DW 04002H		; ATL::CVarTypeInfo<short *>::VT
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT __GUID_7fd52380_4e07_101b_ae2d_08002b2ec713
CONST	SEGMENT
__GUID_7fd52380_4e07_101b_ae2d_08002b2ec713 DD 07fd52380H
	DW	04e07H
	DW	0101bH
	DB	0aeH
	DB	02dH
	DB	08H
	DB	00H
	DB	02bH
	DB	02eH
	DB	0c7H
	DB	013H
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT __GUID_00000109_0000_0000_c000_000000000046
CONST	SEGMENT
__GUID_00000109_0000_0000_c000_000000000046 DD 0109H
	DW	00H
	DW	00H
	DB	0c0H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	046H
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@F@ATL@@2QQtagVARIANT@@FQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@F@ATL@@2QQtagVARIANT@@FQ3@ DD 08H ; ATL::CVarTypeInfo<short>::pmField
CONST	ENDS
;	COMDAT ??_C@_1O@JDLOHAN@?$AAD?$AAe?$AAl?$AAe?$AAt?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1O@JDLOHAN@?$AAD?$AAe?$AAl?$AAe?$AAt?$AAe?$AA?$AA@ DB 'D', 00H, 'e', 00H
	DB	'l', 00H, 'e', 00H, 't', 00H, 'e', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@F@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@F@ATL@@2GB DW 02H			; ATL::CVarTypeInfo<short>::VT
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?szDelete@ATL@@3QB_WB
CONST	SEGMENT
?szDelete@ATL@@3QB_WB DD FLAT:??_C@_1O@JDLOHAN@?$AAD?$AAe?$AAl?$AAe?$AAt?$AAe?$AA?$AA@ ; ATL::szDelete
CONST	ENDS
;	COMDAT ??_C@_1BC@GCKHIPE@?$AAN?$AAo?$AAR?$AAe?$AAm?$AAo?$AAv?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1BC@GCKHIPE@?$AAN?$AAo?$AAR?$AAe?$AAm?$AAo?$AAv?$AAe?$AA?$AA@ DB 'N'
	DB	00H, 'o', 00H, 'R', 00H, 'e', 00H, 'm', 00H, 'o', 00H, 'v', 00H
	DB	'e', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ?szNoRemove@ATL@@3QB_WB
CONST	SEGMENT
?szNoRemove@ATL@@3QB_WB DD FLAT:??_C@_1BC@GCKHIPE@?$AAN?$AAo?$AAR?$AAe?$AAm?$AAo?$AAv?$AAe?$AA?$AA@ ; ATL::szNoRemove
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ??_C@_1BI@JFAIJMHL@?$AAF?$AAo?$AAr?$AAc?$AAe?$AAR?$AAe?$AAm?$AAo?$AAv?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1BI@JFAIJMHL@?$AAF?$AAo?$AAr?$AAc?$AAe?$AAR?$AAe?$AAm?$AAo?$AAv?$AAe?$AA?$AA@ DB 'F'
	DB	00H, 'o', 00H, 'r', 00H, 'c', 00H, 'e', 00H, 'R', 00H, 'e', 00H
	DB	'm', 00H, 'o', 00H, 'v', 00H, 'e', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ?szForceRemove@ATL@@3QB_WB
CONST	SEGMENT
?szForceRemove@ATL@@3QB_WB DD FLAT:??_C@_1BI@JFAIJMHL@?$AAF?$AAo?$AAr?$AAc?$AAe?$AAR?$AAe?$AAm?$AAo?$AAv?$AAe?$AA?$AA@ ; ATL::szForceRemove
CONST	ENDS
;	COMDAT ??_C@_17LLMMEOJD@?$AAV?$AAa?$AAl?$AA?$AA@
CONST	SEGMENT
??_C@_17LLMMEOJD@?$AAV?$AAa?$AAl?$AA?$AA@ DB 'V', 00H, 'a', 00H, 'l', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?szValToken@ATL@@3QB_WB
CONST	SEGMENT
?szValToken@ATL@@3QB_WB DD FLAT:??_C@_17LLMMEOJD@?$AAV?$AAa?$AAl?$AA?$AA@ ; ATL::szValToken
CONST	ENDS
;	COMDAT ??_C@_13OPKGLAFF@?$AAB?$AA?$AA@
CONST	SEGMENT
??_C@_13OPKGLAFF@?$AAB?$AA?$AA@ DB 'B', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ?szBinaryVal@ATL@@3QB_WB
CONST	SEGMENT
?szBinaryVal@ATL@@3QB_WB DD FLAT:??_C@_13OPKGLAFF@?$AAB?$AA?$AA@ ; ATL::szBinaryVal
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ??_C@_13MKMNOPIJ@?$AAD?$AA?$AA@
CONST	SEGMENT
??_C@_13MKMNOPIJ@?$AAD?$AA?$AA@ DB 'D', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT _CLSID_Registrar
CONST	SEGMENT
_CLSID_Registrar DD 044ec053aH
	DW	0400fH
	DW	011d0H
	DB	09dH
	DB	0cdH
	DB	00H
	DB	0a0H
	DB	0c9H
	DB	03H
	DB	091H
	DB	0d3H
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAE@ATL@@2QQtagVARIANT@@PAEQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAE@ATL@@2QQtagVARIANT@@PAEQ3@ DD 08H ; ATL::CVarTypeInfo<unsigned char *>::pmField
CONST	ENDS
;	COMDAT ?szDwordVal@ATL@@3QB_WB
CONST	SEGMENT
?szDwordVal@ATL@@3QB_WB DD FLAT:??_C@_13MKMNOPIJ@?$AAD?$AA?$AA@ ; ATL::szDwordVal
CONST	ENDS
;	COMDAT ??_C@_13LHMFKAAD@?$AAM?$AA?$AA@
CONST	SEGMENT
??_C@_13LHMFKAAD@?$AAM?$AA?$AA@ DB 'M', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAE@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAE@ATL@@2GB DW 04011H		; ATL::CVarTypeInfo<unsigned char *>::VT
CONST	ENDS
;	COMDAT ?multiszStringVal@ATL@@3QB_WB
CONST	SEGMENT
?multiszStringVal@ATL@@3QB_WB DD FLAT:??_C@_13LHMFKAAD@?$AAM?$AA?$AA@ ; ATL::multiszStringVal
CONST	ENDS
;	COMDAT ??_C@_13HADIAKP@?$AAS?$AA?$AA@
CONST	SEGMENT
??_C@_13HADIAKP@?$AAS?$AA?$AA@ DB 'S', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ?szStringVal@ATL@@3QB_WB
CONST	SEGMENT
?szStringVal@ATL@@3QB_WB DD FLAT:??_C@_13HADIAKP@?$AAS?$AA?$AA@ ; ATL::szStringVal
CONST	ENDS
;	COMDAT ?chEquals@ATL@@3_WB
CONST	SEGMENT
?chEquals@ATL@@3_WB DW 03dH				; ATL::chEquals
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?chQuote@ATL@@3_WB
CONST	SEGMENT
?chQuote@ATL@@3_WB DW 027H				; ATL::chQuote
CONST	ENDS
;	COMDAT ?chLeftBracket@ATL@@3_WB
CONST	SEGMENT
?chLeftBracket@ATL@@3_WB DW 07bH			; ATL::chLeftBracket
CONST	ENDS
;	COMDAT ?chRightBracket@ATL@@3_WB
CONST	SEGMENT
?chRightBracket@ATL@@3_WB DW 07dH			; ATL::chRightBracket
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?chDirSep@ATL@@3_WB
CONST	SEGMENT
?chDirSep@ATL@@3_WB DW 05cH				; ATL::chDirSep
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAD@ATL@@2QQtagVARIANT@@PADQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAD@ATL@@2QQtagVARIANT@@PADQ3@ DD 08H ; ATL::CVarTypeInfo<char *>::pmField
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAD@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAD@ATL@@2GB DW 04010H		; ATL::CVarTypeInfo<char *>::VT
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$07@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$07@std@@2IB DD 08H		; std::integral_constant<unsigned int,8>::value
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@E@ATL@@2QQtagVARIANT@@EQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@E@ATL@@2QQtagVARIANT@@EQ3@ DD 08H ; ATL::CVarTypeInfo<unsigned char>::pmField
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@E@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@E@ATL@@2GB DW 011H			; ATL::CVarTypeInfo<unsigned char>::VT
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@D@ATL@@2QQtagVARIANT@@DQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@D@ATL@@2QQtagVARIANT@@DQ3@ DD 08H ; ATL::CVarTypeInfo<char>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@D@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@D@ATL@@2GB DW 010H			; ATL::CVarTypeInfo<char>::VT
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?MAX_VERTEX_ELTS@CModel@@0HB
CONST	SEGMENT
?MAX_VERTEX_ELTS@CModel@@0HB DD 040H			; CModel::MAX_VERTEX_ELTS
CONST	ENDS
;	COMDAT ??_C@_1M@EJNEECMJ@?$AAA?$AAp?$AAp?$AAI?$AAD?$AA?$AA@
CONST	SEGMENT
??_C@_1M@EJNEECMJ@?$AAA?$AAp?$AAp?$AAI?$AAD?$AA?$AA@ DB 'A', 00H, 'p', 00H
	DB	'p', 00H, 'I', 00H, 'D', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ??_C@_1M@KANJNLFF@?$AAC?$AAL?$AAS?$AAI?$AAD?$AA?$AA@
CONST	SEGMENT
??_C@_1M@KANJNLFF@?$AAC?$AAL?$AAS?$AAI?$AAD?$AA?$AA@ DB 'C', 00H, 'L', 00H
	DB	'S', 00H, 'I', 00H, 'D', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT __GUID_fc4801a3_2ba9_11cf_a229_00aa003d7352
CONST	SEGMENT
__GUID_fc4801a3_2ba9_11cf_a229_00aa003d7352 DD 0fc4801a3H
	DW	02ba9H
	DW	011cfH
	DB	0a2H
	DB	029H
	DB	00H
	DB	0aaH
	DB	00H
	DB	03dH
	DB	073H
	DB	052H
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT __GUID_0002e012_0000_0000_c000_000000000046
CONST	SEGMENT
__GUID_0002e012_0000_0000_c000_000000000046 DD 02e012H
	DW	00H
	DW	00H
	DB	0c0H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	046H
CONST	ENDS
;	COMDAT _IID_IInternalConnection
CONST	SEGMENT
_IID_IInternalConnection DD 072ad0770H
	DW	06a9fH
	DW	011d1H
	DB	0bcH
	DB	0ecH
	DB	00H
	DB	060H
	DB	08H
	DB	08fH
	DB	044H
	DB	04eH
CONST	ENDS
;	COMDAT _IID_IAxWinAmbientDispatchEx
CONST	SEGMENT
_IID_IAxWinAmbientDispatchEx DD 0b2d0778bH
	DW	0ac99H
	DW	04c58H
	DB	0a5H
	DB	0c8H
	DB	0e7H
	DB	072H
	DB	04eH
	DB	053H
	DB	016H
	DB	0b5H
CONST	ENDS
;	COMDAT __GUID_9b7e4c04_342c_4106_a19f_4f2704f689f0
CONST	SEGMENT
__GUID_9b7e4c04_342c_4106_a19f_4f2704f689f0 DD 09b7e4c04H
	DW	0342cH
	DW	04106H
	DB	0a1H
	DB	09fH
	DB	04fH
	DB	027H
	DB	04H
	DB	0f6H
	DB	089H
	DB	0f0H
CONST	ENDS
;	COMDAT ?_Max@?$AtlLimits@_K@ATL@@2_KB
CONST	SEGMENT
?_Max@?$AtlLimits@_K@ATL@@2_KB DQ ffffffffffffffffH	; ATL::AtlLimits<unsigned __int64>::_Max
CONST	ENDS
;	COMDAT ?_Min@?$AtlLimits@_K@ATL@@2_KB
CONST	SEGMENT
?_Min@?$AtlLimits@_K@ATL@@2_KB DQ 0000000000000000H	; ATL::AtlLimits<unsigned __int64>::_Min
CONST	ENDS
;	COMDAT ?_Max@?$AtlLimits@_J@ATL@@2_JB
CONST	SEGMENT
?_Max@?$AtlLimits@_J@ATL@@2_JB DQ 7fffffffffffffffH	; ATL::AtlLimits<__int64>::_Max
CONST	ENDS
;	COMDAT ?_Min@?$AtlLimits@_J@ATL@@2_JB
CONST	SEGMENT
?_Min@?$AtlLimits@_J@ATL@@2_JB DQ 8000000000000000H	; ATL::AtlLimits<__int64>::_Min
CONST	ENDS
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	_HRESULT_FROM_WIN32
PUBLIC	_hypot
PUBLIC	??0D3DXVECTOR3@@QAE@XZ				; D3DXVECTOR3::D3DXVECTOR3
PUBLIC	??0D3DXVECTOR3@@QAE@MMM@Z			; D3DXVECTOR3::D3DXVECTOR3
PUBLIC	??BD3DXVECTOR3@@QAEPAMXZ			; D3DXVECTOR3::operator float *
PUBLIC	??0D3DXVECTOR4@@QAE@XZ				; D3DXVECTOR4::D3DXVECTOR4
PUBLIC	??0D3DXVECTOR4@@QAE@ABU_D3DVECTOR@@M@Z		; D3DXVECTOR4::D3DXVECTOR4
PUBLIC	??0D3DXVECTOR4@@QAE@MMMM@Z			; D3DXVECTOR4::D3DXVECTOR4
PUBLIC	??BD3DXMATRIX@@QAEPAMXZ				; D3DXMATRIX::operator float *
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	??$AtlMultiply@I@ATL@@YAJPAIII@Z		; ATL::AtlMultiply<unsigned int>
PUBLIC	?Allocate@CCRTAllocator@ATL@@SAPAXI@Z		; ATL::CCRTAllocator::Allocate
PUBLIC	?Free@CCRTAllocator@ATL@@SAXPAX@Z		; ATL::CCRTAllocator::Free
PUBLIC	?_AtlGetConversionACP@ATL@@YGIXZ		; ATL::_AtlGetConversionACP
PUBLIC	??0?$CTraceCategoryEx@$0IAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<524288,0>::CTraceCategoryEx<524288,0>
PUBLIC	??0?$CTraceCategoryEx@$00$0A@@ATL@@QAE@PB_W@Z	; ATL::CTraceCategoryEx<1,0>::CTraceCategoryEx<1,0>
PUBLIC	??0?$CTraceCategoryEx@$01$0A@@ATL@@QAE@PB_W@Z	; ATL::CTraceCategoryEx<2,0>::CTraceCategoryEx<2,0>
PUBLIC	??B?$CTraceCategoryEx@$01$0A@@ATL@@QAEIXZ	; ATL::CTraceCategoryEx<2,0>::operator unsigned int
PUBLIC	??0?$CTraceCategoryEx@$03$0A@@ATL@@QAE@PB_W@Z	; ATL::CTraceCategoryEx<4,0>::CTraceCategoryEx<4,0>
PUBLIC	??0?$CTraceCategoryEx@$07$0A@@ATL@@QAE@PB_W@Z	; ATL::CTraceCategoryEx<8,0>::CTraceCategoryEx<8,0>
PUBLIC	??0?$CTraceCategoryEx@$0BA@$0A@@ATL@@QAE@PB_W@Z	; ATL::CTraceCategoryEx<16,0>::CTraceCategoryEx<16,0>
PUBLIC	??0?$CTraceCategoryEx@$0CA@$0A@@ATL@@QAE@PB_W@Z	; ATL::CTraceCategoryEx<32,0>::CTraceCategoryEx<32,0>
PUBLIC	??B?$CTraceCategoryEx@$0CA@$0A@@ATL@@QAEIXZ	; ATL::CTraceCategoryEx<32,0>::operator unsigned int
PUBLIC	??0?$CTraceCategoryEx@$0EA@$0A@@ATL@@QAE@PB_W@Z	; ATL::CTraceCategoryEx<64,0>::CTraceCategoryEx<64,0>
PUBLIC	??0?$CTraceCategoryEx@$0IA@$0A@@ATL@@QAE@PB_W@Z	; ATL::CTraceCategoryEx<128,0>::CTraceCategoryEx<128,0>
PUBLIC	??0?$CTraceCategoryEx@$0BAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<256,0>::CTraceCategoryEx<256,0>
PUBLIC	??0?$CTraceCategoryEx@$0CAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<512,0>::CTraceCategoryEx<512,0>
PUBLIC	??0?$CTraceCategoryEx@$0EAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<1024,0>::CTraceCategoryEx<1024,0>
PUBLIC	??0?$CTraceCategoryEx@$0IAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<2048,0>::CTraceCategoryEx<2048,0>
PUBLIC	??0?$CTraceCategoryEx@$0BAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<4096,0>::CTraceCategoryEx<4096,0>
PUBLIC	??0?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<8192,0>::CTraceCategoryEx<8192,0>
PUBLIC	??B?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAEIXZ	; ATL::CTraceCategoryEx<8192,0>::operator unsigned int
PUBLIC	??0?$CTraceCategoryEx@$0EAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<16384,0>::CTraceCategoryEx<16384,0>
PUBLIC	??0?$CTraceCategoryEx@$0IAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<32768,0>::CTraceCategoryEx<32768,0>
PUBLIC	??0?$CTraceCategoryEx@$0BAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<65536,0>::CTraceCategoryEx<65536,0>
PUBLIC	??0?$CTraceCategoryEx@$0CAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<131072,0>::CTraceCategoryEx<131072,0>
PUBLIC	??0?$CTraceCategoryEx@$0EAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<262144,0>::CTraceCategoryEx<262144,0>
PUBLIC	??0?$CTraceCategoryEx@$0BAAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<1048576,0>::CTraceCategoryEx<1048576,0>
PUBLIC	??0?$CTraceCategoryEx@$0CAAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<2097152,0>::CTraceCategoryEx<2097152,0>
PUBLIC	??0?$CTraceCategoryEx@$0EAAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<4194304,0>::CTraceCategoryEx<4194304,0>
PUBLIC	?GetCategoryName@CTrace@ATL@@CAPA_WI@Z		; ATL::CTrace::GetCategoryName
PUBLIC	?TraceV@CTrace@ATL@@CAXPBDHIIPB_W@Z		; ATL::CTrace::TraceV
PUBLIC	?TraceV@CTrace@ATL@@SAXPBDHIIPB_WPAD@Z		; ATL::CTrace::TraceV
PUBLIC	?RegisterCategory@CTrace@ATL@@SAXPB_WI@Z	; ATL::CTrace::RegisterCategory
PUBLIC	??0?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@IAE@XZ ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>
PUBLIC	??1?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::~CHeapPtrBase<wchar_t,ATL::CCRTAllocator>
PUBLIC	??B?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QBEPA_WXZ ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::operator wchar_t *
PUBLIC	?AllocateBytes@?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QAE_NI@Z ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::AllocateBytes
PUBLIC	?Free@?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QAEXXZ ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::Free
PUBLIC	??0?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CHeapPtr<wchar_t,ATL::CCRTAllocator>::CHeapPtr<wchar_t,ATL::CCRTAllocator>
PUBLIC	?Allocate@?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE_NI@Z ; ATL::CHeapPtr<wchar_t,ATL::CCRTAllocator>::Allocate
PUBLIC	??1?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CHeapPtr<wchar_t,ATL::CCRTAllocator>::~CHeapPtr<wchar_t,ATL::CCRTAllocator>
PUBLIC	??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z	; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
PUBLIC	??RCTraceFileAndLineInfo@ATL@@QBAXHIPB_WZZ	; ATL::CTraceFileAndLineInfo::operator()
PUBLIC	?_AtlRaiseException@ATL@@YAXKK@Z		; ATL::_AtlRaiseException
PUBLIC	??0CAtlException@ATL@@QAE@J@Z			; ATL::CAtlException::CAtlException
PUBLIC	?AtlThrowImpl@ATL@@YGXJ@Z			; ATL::AtlThrowImpl
PUBLIC	?AtlThrowLastWin32@ATL@@YGXXZ			; ATL::AtlThrowLastWin32
PUBLIC	?_AtlInitializeCriticalSectionEx@ATL@@YAHPAU_RTL_CRITICAL_SECTION@@KK@Z ; ATL::_AtlInitializeCriticalSectionEx
PUBLIC	??0CComCriticalSection@ATL@@QAE@XZ		; ATL::CComCriticalSection::CComCriticalSection
PUBLIC	??1CComCriticalSection@ATL@@QAE@XZ		; ATL::CComCriticalSection::~CComCriticalSection
PUBLIC	?Init@CComCriticalSection@ATL@@QAEJXZ		; ATL::CComCriticalSection::Init
PUBLIC	?Term@CComCriticalSection@ATL@@QAEJXZ		; ATL::CComCriticalSection::Term
PUBLIC	?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ ; ATL::CAtlBaseModule::GetModuleInstance
PUBLIC	??0_ATL_COM_MODULE70@ATL@@QAE@XZ		; ATL::_ATL_COM_MODULE70::_ATL_COM_MODULE70
PUBLIC	??1_ATL_COM_MODULE70@ATL@@QAE@XZ		; ATL::_ATL_COM_MODULE70::~_ATL_COM_MODULE70
PUBLIC	??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
PUBLIC	??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::~CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
PUBLIC	?GetSize@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QBEHXZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::GetSize
PUBLIC	?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll
PUBLIC	??A?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEAAGH@Z ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::operator[]
PUBLIC	??0_ATL_WIN_MODULE70@ATL@@QAE@XZ		; ATL::_ATL_WIN_MODULE70::_ATL_WIN_MODULE70
PUBLIC	??1_ATL_WIN_MODULE70@ATL@@QAE@XZ		; ATL::_ATL_WIN_MODULE70::~_ATL_WIN_MODULE70
PUBLIC	?AtlWinModuleInit@ATL@@YGJPAU_ATL_WIN_MODULE70@1@@Z ; ATL::AtlWinModuleInit
PUBLIC	?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z ; ATL::AtlWinModuleTerm
PUBLIC	??0CAtlComModule@ATL@@QAE@XZ			; ATL::CAtlComModule::CAtlComModule
PUBLIC	??1CAtlComModule@ATL@@QAE@XZ			; ATL::CAtlComModule::~CAtlComModule
PUBLIC	?Term@CAtlComModule@ATL@@QAEXXZ			; ATL::CAtlComModule::Term
PUBLIC	??0CAtlWinModule@ATL@@QAE@XZ			; ATL::CAtlWinModule::CAtlWinModule
PUBLIC	??1CAtlWinModule@ATL@@QAE@XZ			; ATL::CAtlWinModule::~CAtlWinModule
PUBLIC	?Term@CAtlWinModule@ATL@@QAEXXZ			; ATL::CAtlWinModule::Term
PUBLIC	?length@?$char_traits@D@std@@SAIPBD@Z		; std::char_traits<char>::length
PUBLIC	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::copy
PUBLIC	?move@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::move
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
PUBLIC	??0_Container_proxy@std@@QAE@XZ			; std::_Container_proxy::_Container_proxy
PUBLIC	??0_Container_base12@std@@QAE@XZ		; std::_Container_base12::_Container_base12
PUBLIC	??1_Container_base12@std@@QAE@XZ		; std::_Container_base12::~_Container_base12
PUBLIC	?_Orphan_all@_Container_base12@std@@QAEXXZ	; std::_Container_base12::_Orphan_all
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?max_size@?$allocator@D@std@@QBEIXZ		; std::allocator<char>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
PUBLIC	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
PUBLIC	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
PUBLIC	??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
PUBLIC	?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Alloc_proxy
PUBLIC	?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Free_proxy
PUBLIC	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
PUBLIC	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
PUBLIC	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
PUBLIC	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
PUBLIC	??0id@locale@std@@QAE@I@Z			; std::locale::id::id
PUBLIC	??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z		; std::_Debug_pointer<char>
PUBLIC	?generic_category@std@@YAABVerror_category@1@XZ	; std::generic_category
PUBLIC	?system_category@std@@YAABVerror_category@1@XZ	; std::system_category
PUBLIC	??0error_category@std@@QAE@XZ			; std::error_category::error_category
PUBLIC	??1error_category@std@@UAE@XZ			; std::error_category::~error_category
PUBLIC	?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition
PUBLIC	?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent
PUBLIC	?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent
PUBLIC	??8error_category@std@@QBE_NABV01@@Z		; std::error_category::operator==
PUBLIC	??_Gerror_category@std@@UAEPAXI@Z		; std::error_category::`scalar deleting destructor'
PUBLIC	?value@error_code@std@@QBEHXZ			; std::error_code::value
PUBLIC	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
PUBLIC	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
PUBLIC	?value@error_condition@std@@QBEHXZ		; std::error_condition::value
PUBLIC	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
PUBLIC	??8error_condition@std@@QBE_NABV01@@Z		; std::error_condition::operator==
PUBLIC	??0_Generic_error_category@std@@QAE@XZ		; std::_Generic_error_category::_Generic_error_category
PUBLIC	?name@_Generic_error_category@std@@UBEPBDXZ	; std::_Generic_error_category::name
PUBLIC	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
PUBLIC	??1_Generic_error_category@std@@UAE@XZ		; std::_Generic_error_category::~_Generic_error_category
PUBLIC	??_G_Generic_error_category@std@@UAEPAXI@Z	; std::_Generic_error_category::`scalar deleting destructor'
PUBLIC	??0_Iostream_error_category@std@@QAE@XZ		; std::_Iostream_error_category::_Iostream_error_category
PUBLIC	?name@_Iostream_error_category@std@@UBEPBDXZ	; std::_Iostream_error_category::name
PUBLIC	?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message
PUBLIC	??1_Iostream_error_category@std@@UAE@XZ		; std::_Iostream_error_category::~_Iostream_error_category
PUBLIC	??_G_Iostream_error_category@std@@UAEPAXI@Z	; std::_Iostream_error_category::`scalar deleting destructor'
PUBLIC	??0_System_error_category@std@@QAE@XZ		; std::_System_error_category::_System_error_category
PUBLIC	?name@_System_error_category@std@@UBEPBDXZ	; std::_System_error_category::name
PUBLIC	?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message
PUBLIC	?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition
PUBLIC	??1_System_error_category@std@@UAE@XZ		; std::_System_error_category::~_System_error_category
PUBLIC	??_G_System_error_category@std@@UAEPAXI@Z	; std::_System_error_category::`scalar deleting destructor'
PUBLIC	?ToRadians@@YAMM@Z				; ToRadians
PUBLIC	?square@@YAMM@Z					; square
PUBLIC	?SetDevice@CModel@@SAXPAUID3D10Device@@@Z	; CModel::SetDevice
PUBLIC	?GetPosition@CModel@@QAE?AUD3DXVECTOR3@@XZ	; CModel::GetPosition
PUBLIC	?GetWorldMatrix@CModel@@QAE?AU_D3DXMATRIXA16@@XZ ; CModel::GetWorldMatrix
PUBLIC	?SetPosition@CModel@@QAEXUD3DXVECTOR3@@@Z	; CModel::SetPosition
PUBLIC	?SetRotation@CModel@@QAEXUD3DXVECTOR3@@@Z	; CModel::SetRotation
PUBLIC	?SetScale@CModel@@QAEXM@Z			; CModel::SetScale
PUBLIC	?SetViewport@CCamera@@SAXHH@Z			; CCamera::SetViewport
PUBLIC	?GetPosition@CCamera@@QAE?AUD3DXVECTOR3@@XZ	; CCamera::GetPosition
PUBLIC	?GetViewMatrix@CCamera@@QAE?AU_D3DXMATRIXA16@@XZ ; CCamera::GetViewMatrix
PUBLIC	?GetProjectionMatrix@CCamera@@QAE?AU_D3DXMATRIXA16@@XZ ; CCamera::GetProjectionMatrix
PUBLIC	?SetPosition@CCamera@@QAEXUD3DXVECTOR3@@@Z	; CCamera::SetPosition
PUBLIC	?SetRotation@CCamera@@QAEXUD3DXVECTOR3@@@Z	; CCamera::SetRotation
PUBLIC	?SetNearClip@CCamera@@QAEXM@Z			; CCamera::SetNearClip
PUBLIC	?GetColourV@CLight@@QAE?AUD3DXVECTOR3@@XZ	; CLight::GetColourV
PUBLIC	?GetModel@CLight@@QAEPAVCModel@@XZ		; CLight::GetModel
PUBLIC	?SetModel@CLight@@QAEXPAVCModel@@@Z		; CLight::SetModel
PUBLIC	?GetBrightness@CLight@@QAEMXZ			; CLight::GetBrightness
PUBLIC	?SetBrightness@CLight@@QAEXM@Z			; CLight::SetBrightness
PUBLIC	?SetDisco@CLight@@QAEXXZ			; CLight::SetDisco
PUBLIC	??_GCLight@@QAEPAXI@Z				; CLight::`scalar deleting destructor'
PUBLIC	?GetModel@CRenderObject@@QAEPAVCModel@@XZ	; CRenderObject::GetModel
PUBLIC	?GetColourV@CRenderObject@@QAE?AUD3DXVECTOR3@@XZ ; CRenderObject::GetColourV
PUBLIC	?GetTexture@CRenderObject@@QAEPAUID3D10ShaderResourceView@@XZ ; CRenderObject::GetTexture
PUBLIC	?GetNormalMap@CRenderObject@@QAEPAUID3D10ShaderResourceView@@XZ ; CRenderObject::GetNormalMap
PUBLIC	?IsLit@CRenderObject@@QAE_NXZ			; CRenderObject::IsLit
PUBLIC	?IsTransparent@CRenderObject@@QAE_NXZ		; CRenderObject::IsTransparent
PUBLIC	?Render@CRenderObject@@QAEXXZ			; CRenderObject::Render
PUBLIC	?RenderMirror@CRenderObject@@QAEXXZ		; CRenderObject::RenderMirror
PUBLIC	?SetColourCycle@CRenderObject@@QAEXXZ		; CRenderObject::SetColourCycle
PUBLIC	?SetSpinX@CRenderObject@@QAEXM@Z		; CRenderObject::SetSpinX
PUBLIC	?SetSpinY@CRenderObject@@QAEXM@Z		; CRenderObject::SetSpinY
PUBLIC	?SetSpinZ@CRenderObject@@QAEXM@Z		; CRenderObject::SetSpinZ
PUBLIC	?SetWiggle@CRenderObject@@QAEXM@Z		; CRenderObject::SetWiggle
PUBLIC	?GetWiggle@CRenderObject@@QAEMXZ		; CRenderObject::GetWiggle
PUBLIC	?GetOutlineThickness@CRenderObject@@QAEMXZ	; CRenderObject::GetOutlineThickness
PUBLIC	??_GCRenderObject@@QAEPAXI@Z			; CRenderObject::`scalar deleting destructor'
PUBLIC	?BasicItems@CScene@@AAE_NXZ			; CScene::BasicItems
PUBLIC	?SceneItems@CScene@@AAE_NXZ			; CScene::SceneItems
PUBLIC	?TestItems@CScene@@AAE_NXZ			; CScene::TestItems
PUBLIC	?CellStuff@CScene@@AAE_NXZ			; CScene::CellStuff
PUBLIC	?SetLive@CScene@@AAEXHH@Z			; CScene::SetLive
PUBLIC	?SetDead@CScene@@AAEXHH@Z			; CScene::SetDead
PUBLIC	?CalcNeighbours@CScene@@AAEXXZ			; CScene::CalcNeighbours
PUBLIC	?SetLights@CScene@@AAEXUD3DXVECTOR3@@QAPAVCLight@@H@Z ; CScene::SetLights
PUBLIC	?compareLights@CScene@@CAHPBX0@Z		; CScene::compareLights
PUBLIC	?WndProc@CScene@@CGJPAUHWND__@@IIJ@Z		; CScene::WndProc
PUBLIC	?DrawObject@CScene@@AAEXH_N@Z			; CScene::DrawObject
PUBLIC	?DrawAllObjects@CScene@@AAEX_N@Z		; CScene::DrawAllObjects
PUBLIC	??0CScene@@QAE@XZ				; CScene::CScene
PUBLIC	??1CScene@@QAE@XZ				; CScene::~CScene
PUBLIC	?InitDevice@CScene@@QAE_NXZ			; CScene::InitDevice
PUBLIC	?ReleaseResources@CScene@@QAEXXZ		; CScene::ReleaseResources
PUBLIC	?LoadEffectFile@CScene@@QAE_NXZ			; CScene::LoadEffectFile
PUBLIC	?InitScene@CScene@@QAE_NXZ			; CScene::InitScene
PUBLIC	?UpdateScene@CScene@@QAEXM@Z			; CScene::UpdateScene
PUBLIC	?RenderScene@CScene@@QAEXXZ			; CScene::RenderScene
PUBLIC	?RenderMirrors@CScene@@QAEXXZ			; CScene::RenderMirrors
PUBLIC	?InitWindow@CScene@@QAE_NPAUHINSTANCE__@@H@Z	; CScene::InitWindow
PUBLIC	??$strcpy_s@$0GE@@@YAHAAY0GE@DPBD@Z		; strcpy_s<100>
PUBLIC	??$_itoa_s@$05@@YAHHAAY05DH@Z			; _itoa_s<6>
PUBLIC	??$strcat_s@$0GE@@@YAHAAY0GE@DPBD@Z		; strcat_s<100>
PUBLIC	??0?$CA2WEX@$0IA@@ATL@@QAE@PBD@Z		; ATL::CA2WEX<128>::CA2WEX<128>
PUBLIC	??1?$CA2WEX@$0IA@@ATL@@QAE@XZ			; ATL::CA2WEX<128>::~CA2WEX<128>
PUBLIC	??B?$CA2WEX@$0IA@@ATL@@QBEPA_WXZ		; ATL::CA2WEX<128>::operator wchar_t *
PUBLIC	?Init@?$CA2WEX@$0IA@@ATL@@AAEXPBDI@Z		; ATL::CA2WEX<128>::Init
PUBLIC	??$AtlConvFreeMemory@_W@ATL@@YAXPA_W0H@Z	; ATL::AtlConvFreeMemory<wchar_t>
PUBLIC	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
PUBLIC	??$addressof@D@std@@YAPADAAD@Z			; std::addressof<char>
PUBLIC	??$AtlConvAllocMemory@_W@ATL@@YAXPAPA_WHPA_WH@Z	; ATL::AtlConvAllocMemory<wchar_t>
PUBLIC	??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>
PUBLIC	?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate
PUBLIC	?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate
PUBLIC	??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>
PUBLIC	??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>
PUBLIC	??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z ; std::_Allocate<std::_Container_proxy>
PUBLIC	??$_Allocate@D@std@@YAPADIPAD@Z			; std::_Allocate<char>
PUBLIC	??$forward@AAPAD@std@@YAAAPADAAPAD@Z		; std::forward<char * &>
PUBLIC	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
PUBLIC	??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>
PUBLIC	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z	; std::allocator<char>::destroy<char *>
PUBLIC	??_C@_13COJANIEC@?$AA0?$AA?$AA@			; `string'
PUBLIC	??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@		; `string'
PUBLIC	??_C@_1KC@BHGECGBJ@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; `string'
PUBLIC	??_C@_1KA@BPMCHGPL@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; `string'
PUBLIC	?atlTraceGeneral@ATL@@3V?$CTraceCategoryEx@$00$0A@@1@A ; ATL::atlTraceGeneral
PUBLIC	??_C@_1CA@ONGMEOAB@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAG?$AAe?$AAn?$AAe?$AAr?$AAa?$AAl?$AA?$AA@ ; `string'
PUBLIC	?atlTraceCOM@ATL@@3V?$CTraceCategoryEx@$01$0A@@1@A ; ATL::atlTraceCOM
PUBLIC	??_C@_1BI@MAFGHOEE@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAC?$AAO?$AAM?$AA?$AA@ ; `string'
PUBLIC	?atlTraceQI@ATL@@3V?$CTraceCategoryEx@$03$0A@@1@A ; ATL::atlTraceQI
PUBLIC	??_C@_1BG@FPLJJEMF@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAQ?$AAI?$AA?$AA@ ; `string'
PUBLIC	?atlTraceRegistrar@ATL@@3V?$CTraceCategoryEx@$07$0A@@1@A ; ATL::atlTraceRegistrar
PUBLIC	??_C@_1CE@NIAEAIDK@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAR?$AAe?$AAg?$AAi?$AAs?$AAt?$AAr?$AAa?$AAr?$AA?$AA@ ; `string'
PUBLIC	?atlTraceRefcount@ATL@@3V?$CTraceCategoryEx@$0BA@$0A@@1@A ; ATL::atlTraceRefcount
PUBLIC	??_C@_1CC@BNHGJFNK@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAR?$AAe?$AAf?$AAc?$AAo?$AAu?$AAn?$AAt?$AA?$AA@ ; `string'
PUBLIC	?atlTraceWindowing@ATL@@3V?$CTraceCategoryEx@$0CA@$0A@@1@A ; ATL::atlTraceWindowing
PUBLIC	??_C@_1CE@NAJDPMNB@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AAi?$AAn?$AAg?$AA?$AA@ ; `string'
PUBLIC	?atlTraceControls@ATL@@3V?$CTraceCategoryEx@$0EA@$0A@@1@A ; ATL::atlTraceControls
PUBLIC	??_C@_1CC@IMNJGBED@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAC?$AAo?$AAn?$AAt?$AAr?$AAo?$AAl?$AAs?$AA?$AA@ ; `string'
PUBLIC	?atlTraceHosting@ATL@@3V?$CTraceCategoryEx@$0IA@$0A@@1@A ; ATL::atlTraceHosting
PUBLIC	??_C@_1CA@OMOMONMN@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAH?$AAo?$AAs?$AAt?$AAi?$AAn?$AAg?$AA?$AA@ ; `string'
PUBLIC	?atlTraceDBClient@ATL@@3V?$CTraceCategoryEx@$0BAA@$0A@@1@A ; ATL::atlTraceDBClient
PUBLIC	??_C@_1CC@JNJJDOOH@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAD?$AAB?$AAC?$AAl?$AAi?$AAe?$AAn?$AAt?$AA?$AA@ ; `string'
PUBLIC	?atlTraceDBProvider@ATL@@3V?$CTraceCategoryEx@$0CAA@$0A@@1@A ; ATL::atlTraceDBProvider
PUBLIC	??_C@_1CG@MNMMIOOI@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAD?$AAB?$AAP?$AAr?$AAo?$AAv?$AAi?$AAd?$AAe?$AAr?$AA?$AA@ ; `string'
PUBLIC	?atlTraceSnapin@ATL@@3V?$CTraceCategoryEx@$0EAA@$0A@@1@A ; ATL::atlTraceSnapin
PUBLIC	??_C@_1BO@EFPHNHHN@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAS?$AAn?$AAa?$AAp?$AAi?$AAn?$AA?$AA@ ; `string'
PUBLIC	?atlTraceNotImpl@ATL@@3V?$CTraceCategoryEx@$0IAA@$0A@@1@A ; ATL::atlTraceNotImpl
PUBLIC	??_C@_1CA@DMHPIODO@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAN?$AAo?$AAt?$AAI?$AAm?$AAp?$AAl?$AA?$AA@ ; `string'
PUBLIC	?atlTraceAllocation@ATL@@3V?$CTraceCategoryEx@$0BAAA@$0A@@1@A ; ATL::atlTraceAllocation
PUBLIC	??_C@_1CG@KFEEMCDH@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?$AA@ ; `string'
PUBLIC	?atlTraceException@ATL@@3V?$CTraceCategoryEx@$0CAAA@$0A@@1@A ; ATL::atlTraceException
PUBLIC	??_C@_1CE@IMMADNAP@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAE?$AAx?$AAc?$AAe?$AAp?$AAt?$AAi?$AAo?$AAn?$AA?$AA@ ; `string'
PUBLIC	?atlTraceTime@ATL@@3V?$CTraceCategoryEx@$0EAAA@$0A@@1@A ; ATL::atlTraceTime
PUBLIC	??_C@_1BK@NCJHOFCL@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAT?$AAi?$AAm?$AAe?$AA?$AA@ ; `string'
PUBLIC	?atlTraceCache@ATL@@3V?$CTraceCategoryEx@$0IAAA@$0A@@1@A ; ATL::atlTraceCache
PUBLIC	??_C@_1BM@GIKLHLFD@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAC?$AAa?$AAc?$AAh?$AAe?$AA?$AA@ ; `string'
PUBLIC	?atlTraceStencil@ATL@@3V?$CTraceCategoryEx@$0BAAAA@$0A@@1@A ; ATL::atlTraceStencil
PUBLIC	??_C@_1CA@PBPHANCD@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAS?$AAt?$AAe?$AAn?$AAc?$AAi?$AAl?$AA?$AA@ ; `string'
PUBLIC	?atlTraceString@ATL@@3V?$CTraceCategoryEx@$0CAAAA@$0A@@1@A ; ATL::atlTraceString
PUBLIC	??_C@_1BO@GMLILNDJ@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAS?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?$AA@ ; `string'
PUBLIC	?atlTraceMap@ATL@@3V?$CTraceCategoryEx@$0EAAAA@$0A@@1@A ; ATL::atlTraceMap
PUBLIC	??_C@_1BI@OKDLCIEM@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAM?$AAa?$AAp?$AA?$AA@ ; `string'
PUBLIC	?atlTraceUtil@ATL@@3V?$CTraceCategoryEx@$0IAAAA@$0A@@1@A ; ATL::atlTraceUtil
PUBLIC	??_C@_1BK@DMHCKHHD@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAU?$AAt?$AAi?$AAl?$AA?$AA@ ; `string'
PUBLIC	?atlTraceSecurity@ATL@@3V?$CTraceCategoryEx@$0BAAAAA@$0A@@1@A ; ATL::atlTraceSecurity
PUBLIC	??_C@_1CC@DMMBNCFG@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAS?$AAe?$AAc?$AAu?$AAr?$AAi?$AAt?$AAy?$AA?$AA@ ; `string'
PUBLIC	?atlTraceSync@ATL@@3V?$CTraceCategoryEx@$0CAAAAA@$0A@@1@A ; ATL::atlTraceSync
PUBLIC	??_C@_1BK@OPAPOCAL@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAS?$AAy?$AAn?$AAc?$AA?$AA@ ; `string'
PUBLIC	?atlTraceISAPI@ATL@@3V?$CTraceCategoryEx@$0EAAAAA@$0A@@1@A ; ATL::atlTraceISAPI
PUBLIC	??_C@_1BM@FHAEDBFK@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAI?$AAS?$AAA?$AAP?$AAI?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@PLLAHAGD@?$AA?$CF?$AAs?$AA?5?$AA?9?$AA?5?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@PGKOAACE@?$AA?$CF?$AAu?$AA?5?$AA?9?$AA?5?$AA?$AA@ ; `string'
PUBLIC	??_C@_19LJDFFCJJ@?$AA?$CF?$AAs?$AA?$CF?$AAs?$AA?$AA@ ; `string'
PUBLIC	??_C@_15MAOEGKJF@?$AA?$CF?$AAS?$AA?$AA@		; `string'
PUBLIC	??_C@_1EO@EBPPKGOM@?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAT?$AAo?$AAo?$AA?5?$AAm?$AAa?$AAn?$AAy?$AA?5?$AAc?$AAa?$AAt?$AAe?$AAg?$AAo?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAd?$AAe@ ; `string'
PUBLIC	??_C@_1KC@GEMPEEJK@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; `string'
PUBLIC	?__LINE__Var@?1??AtlThrowImpl@ATL@@YGXJ@Z@4JA	; `ATL::AtlThrowImpl'::`2'::__LINE__Var
PUBLIC	??_C@_0FC@OFGMOGKO@c?3?2program?5files?5?$CIx86?$CJ?2microsoft@ ; `string'
PUBLIC	??_C@_1CK@DFMKPFAK@?$AAA?$AAt?$AAl?$AAT?$AAh?$AAr?$AAo?$AAw?$AA?3?$AA?5?$AAh?$AAr?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?6?$AA?$AA@ ; `string'
PUBLIC	__TI1?AVCAtlException@ATL@@
PUBLIC	__CTA1?AVCAtlException@ATL@@
PUBLIC	??_R0?AVCAtlException@ATL@@@8			; ATL::CAtlException `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVCAtlException@ATL@@@84
PUBLIC	??_C@_1BM@GBBOFEAE@?$AA_?$AA_?$AAa?$AAt?$AAl?$AA_?$AAc?$AAo?$AAn?$AAd?$AAV?$AAa?$AAl?$AA?$AA@ ; `string'
PUBLIC	??_C@_1KA@ELJIHIAD@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; `string'
PUBLIC	??_C@_0FA@ODGKGNGJ@c?3?2program?5files?5?$CIx86?$CJ?2microsoft@ ; `string'
PUBLIC	??_C@_1IA@KEEOONGN@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?5?$AA?3?$AA?5?$AAU?$AAn?$AAa?$AAb?$AAl?$AAe?$AA?5?$AAt?$AAo?$AA?5?$AAi?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AAi?$AAz?$AAe?$AA?5?$AAc?$AAr?$AAi@ ; `string'
PUBLIC	?_AtlComModule@ATL@@3VCAtlComModule@1@A		; ATL::_AtlComModule
PUBLIC	?_AtlWinModule@ATL@@3VCAtlWinModule@1@A		; ATL::_AtlWinModule
PUBLIC	?__LINE__Var@?1??AtlWinModuleInit@ATL@@YGJPAU_ATL_WIN_MODULE70@2@@Z@4JA ; `ATL::AtlWinModuleInit'::`2'::__LINE__Var
PUBLIC	??_C@_1IG@OPJAFKJH@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?5?$AA?3?$AA?5?$AAU?$AAn?$AAa?$AAb?$AAl?$AAe?$AA?5?$AAt?$AAo?$AA?5?$AAi?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AAi?$AAz?$AAe?$AA?5?$AAc?$AAr?$AAi@ ; `string'
PUBLIC	??_7error_category@std@@6B@			; std::error_category::`vftable'
PUBLIC	??_7_Generic_error_category@std@@6B@		; std::_Generic_error_category::`vftable'
PUBLIC	??_C@_07DCLBNMLN@generic?$AA@			; `string'
PUBLIC	??_C@_0O@BFJCFAAK@unknown?5error?$AA@		; `string'
PUBLIC	??_7_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`vftable'
PUBLIC	??_C@_08LLGCOLLL@iostream?$AA@			; `string'
PUBLIC	??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@	; `string'
PUBLIC	??_7_System_error_category@std@@6B@		; std::_System_error_category::`vftable'
PUBLIC	??_C@_06FHFOAHML@system?$AA@			; `string'
PUBLIC	?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
PUBLIC	?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
PUBLIC	?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
PUBLIC	?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
PUBLIC	?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
PUBLIC	??_C@_1DC@LOBNDLGH@?$AAS?$AAt?$AAo?$AAn?$AAe?$AAD?$AAi?$AAf?$AAf?$AAu?$AAs?$AAe?$AAS?$AAp?$AAe?$AAc?$AAu?$AAl?$AAa?$AAr?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DA@IEJEKIPL@?$AAW?$AAo?$AAo?$AAd?$AAD?$AAi?$AAf?$AAf?$AAu?$AAs?$AAe?$AAS?$AAp?$AAe?$AAc?$AAu?$AAl?$AAa?$AAr?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BC@MACPKMCG@?$AAM?$AAo?$AAo?$AAn?$AA?4?$AAj?$AAp?$AAg?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DA@GABNFLNL@?$AAW?$AAa?$AAl?$AAl?$AAD?$AAi?$AAf?$AAf?$AAu?$AAs?$AAe?$AAS?$AAp?$AAe?$AAc?$AAu?$AAl?$AAa?$AAr?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CI@HJHILCKN@?$AAW?$AAa?$AAl?$AAl?$AAN?$AAo?$AAr?$AAm?$AAa?$AAl?$AAD?$AAe?$AAp?$AAt?$AAh?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DC@DJHFCGLD@?$AAM?$AAe?$AAt?$AAa?$AAl?$AAD?$AAi?$AAf?$AAf?$AAu?$AAs?$AAe?$AAS?$AAp?$AAe?$AAc?$AAu?$AAl?$AAa?$AAr?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DG@GOOKDEDK@?$AAP?$AAa?$AAt?$AAt?$AAe?$AAr?$AAn?$AAD?$AAi?$AAf?$AAf?$AAu?$AAs?$AAe?$AAS?$AAp?$AAe?$AAc?$AAu?$AAl?$AAa?$AAr?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CO@NOLHING@?$AAP?$AAa?$AAt?$AAt?$AAe?$AAr?$AAn?$AAN?$AAo?$AAr?$AAm?$AAa?$AAl?$AAD?$AAe?$AAp?$AAt?$AAh?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BE@DADLEHEK@?$AAG?$AAl?$AAa?$AAs?$AAs?$AA?4?$AAj?$AAp?$AAg?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DE@DFEKPPGN@?$AAT?$AAr?$AAo?$AAl?$AAl?$AA1?$AAD?$AAi?$AAf?$AAf?$AAu?$AAs?$AAe?$AAS?$AAp?$AAe?$AAc?$AAu?$AAl?$AAa?$AAr?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DE@NHBHEBO@?$AAT?$AAr?$AAo?$AAl?$AAl?$AA2?$AAD?$AAi?$AAf?$AAf?$AAu?$AAs?$AAe?$AAS?$AAp?$AAe?$AAc?$AAu?$AAl?$AAa?$AAr?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DE@KMEIPAPA@?$AAT?$AAr?$AAo?$AAl?$AAl?$AA3?$AAD?$AAi?$AAf?$AAf?$AAu?$AAs?$AAe?$AAS?$AAp?$AAe?$AAc?$AAu?$AAl?$AAa?$AAr?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DE@HNAGGCPI@?$AAT?$AAr?$AAo?$AAl?$AAl?$AA4?$AAD?$AAi?$AAf?$AAf?$AAu?$AAs?$AAe?$AAS?$AAp?$AAe?$AAc?$AAu?$AAl?$AAa?$AAr?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DC@ONLGGDNI@?$AAB?$AAr?$AAa?$AAi?$AAn?$AAD?$AAi?$AAf?$AAf?$AAu?$AAs?$AAe?$AAS?$AAp?$AAe?$AAc?$AAu?$AAl?$AAa?$AAr?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CK@IHOPDIJ@?$AAB?$AAr?$AAa?$AAi?$AAn?$AAN?$AAo?$AAr?$AAm?$AAa?$AAl?$AAD?$AAe?$AAp?$AAt?$AAh?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@ ; `string'
PUBLIC	??_C@_08MLPDMJMG@Mirror?4x?$AA@			; `string'
PUBLIC	??_C@_0CM@HGOJECN@CO2409?5?9?5Graphics?5Assignment?5?9?5S@ ; `string'
PUBLIC	??_C@_04IHBDCLGJ@?5O?3?5?$AA@			; `string'
PUBLIC	??_C@_04JFKGIEIH@?5L?3?5?$AA@			; `string'
PUBLIC	??_C@_1CI@OKMLABGO@?$AAT?$AAu?$AAt?$AAo?$AAr?$AAi?$AAa?$AAl?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AAC?$AAl?$AAa?$AAs?$AAs?$AA?$AA@ ; `string'
PUBLIC	??_C@_1EO@IKJJOGJD@?$AAC?$AAO?$AA2?$AA4?$AA0?$AA9?$AA?5?$AA?9?$AA?5?$AAG?$AAr?$AAa?$AAp?$AAh?$AAi?$AAc?$AAs?$AA?5?$AAA?$AAs?$AAs?$AAi?$AAg?$AAn?$AAm?$AAe?$AAn?$AAt?$AA?5?$AA?9?$AA?5?$AAS@ ; `string'
PUBLIC	??_C@_06BACILOGA@fx_4_0?$AA@			; `string'
PUBLIC	??_C@_1CG@MCKIKNIO@?$AAG?$AAr?$AAa?$AAp?$AAh?$AAi?$AAc?$AAs?$AAA?$AAs?$AAs?$AAi?$AAg?$AAn?$AA1?$AA?4?$AAf?$AAx?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@ILHOPKA@?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?$AA@ ; `string'
PUBLIC	??_C@_1KK@KKJBPFMN@?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?5?$AAl?$AAo?$AAa?$AAd?$AAi?$AAn?$AAg?$AA?5?$AAF?$AAX?$AA?5?$AAf?$AAi?$AAl?$AAe?$AA?4?$AA?5?$AAE?$AAn?$AAs?$AAu?$AAr?$AAe?$AA?5?$AAy?$AAo@ ; `string'
PUBLIC	??_C@_0N@BLACAFBJ@tPlainColour?$AA@		; `string'
PUBLIC	??_C@_0O@CBIDLEEF@tPlainTexture?$AA@		; `string'
PUBLIC	??_C@_0BF@HOFAMMJK@tColourChangeTexture?$AA@	; `string'
PUBLIC	??_C@_0M@PFGJBPP@tLitTexture?$AA@		; `string'
PUBLIC	??_C@_0N@DBNJLAPA@t4LitTexture?$AA@		; `string'
PUBLIC	??_C@_0BC@EBBNGCN@t4LitAttenTexture?$AA@	; `string'
PUBLIC	??_C@_0BB@NDOCHMBG@t4LitSpecularMap?$AA@	; `string'
PUBLIC	??_C@_0N@FAEPMAEM@tParallaxMap?$AA@		; `string'
PUBLIC	??_C@_06ELGFLNMO@tJelly?$AA@			; `string'
PUBLIC	??_C@_0N@HPAFDOEN@tCellShading?$AA@		; `string'
PUBLIC	??_C@_0BC@IHNCMDEH@tCellShadingWrong?$AA@	; `string'
PUBLIC	??_C@_05JGDPNHEJ@tHalo?$AA@			; `string'
PUBLIC	??_C@_0P@FEDIONCO@tSpaceHaloPara?$AA@		; `string'
PUBLIC	??_C@_0BC@NABDBAIK@tSpaceOutlinePara?$AA@	; `string'
PUBLIC	??_C@_09JDFCMBBC@tLitGlass?$AA@			; `string'
PUBLIC	??_C@_0L@MOJEDPIK@tSpaceHalo?$AA@		; `string'
PUBLIC	??_C@_0O@GOICGJFK@tSpaceOutline?$AA@		; `string'
PUBLIC	??_C@_0O@CIOABDO@tTextureMorph?$AA@		; `string'
PUBLIC	??_C@_0M@NCEALFAM@MirrorClear?$AA@		; `string'
PUBLIC	??_C@_0O@CFAHMOKA@MirrorSurface?$AA@		; `string'
PUBLIC	??_C@_0BD@EAMCFOMD@tPlainColourMirror?$AA@	; `string'
PUBLIC	??_C@_0BE@GKDAAGPD@tPlainTextureMirror?$AA@	; `string'
PUBLIC	??_C@_0BL@BDPLHMPN@tColourChangeTextureMirror?$AA@ ; `string'
PUBLIC	??_C@_0BC@PLBJLENF@tLitTextureMirror?$AA@	; `string'
PUBLIC	??_C@_0BD@GNCBGOED@t4LitTextureMirror?$AA@	; `string'
PUBLIC	??_C@_0BI@EEKKACMN@t4LitAttenTextureMirror?$AA@	; `string'
PUBLIC	??_C@_0BH@MJFOIGI@t4LitSpecularMapMirror?$AA@	; `string'
PUBLIC	??_C@_0BD@CIMFECON@tParallaxMapMirror?$AA@	; `string'
PUBLIC	??_C@_0N@KFADNAIL@tJellyMirror?$AA@		; `string'
PUBLIC	??_C@_0BD@NDCFMGPA@tCellShadingMirror?$AA@	; `string'
PUBLIC	??_C@_0BI@MCEONCDC@tCellShadingWrongMirror?$AA@	; `string'
PUBLIC	??_C@_0M@FENFNCKC@tHaloMirror?$AA@		; `string'
PUBLIC	??_C@_0BF@KFEJDHPA@tSpaceHaloParaMirror?$AA@	; `string'
PUBLIC	??_C@_0BI@GGPGLIH@tSpaceOutlineParaMirror?$AA@	; `string'
PUBLIC	??_C@_0BA@BCLLKFIB@tLitGlassMirror?$AA@		; `string'
PUBLIC	??_C@_0BB@CDMINDKK@tSpaceHaloMirror?$AA@	; `string'
PUBLIC	??_C@_0BE@CKKPKAMN@tSpaceOutlineMirror?$AA@	; `string'
PUBLIC	??_C@_0BE@BLJDFMPB@tTextureMorphMirror?$AA@	; `string'
PUBLIC	??_C@_0M@JIFPIELG@WorldMatrix?$AA@		; `string'
PUBLIC	??_C@_0L@BCBAMPKD@ViewMatrix?$AA@		; `string'
PUBLIC	??_C@_0L@FHHLNBJL@ProjMatrix?$AA@		; `string'
PUBLIC	??_C@_0L@ILIGHKAJ@DiffuseMap?$AA@		; `string'
PUBLIC	??_C@_09ILPGELJF@NormalMap?$AA@			; `string'
PUBLIC	??_C@_09JBPBDAII@cameraPos?$AA@			; `string'
PUBLIC	??_C@_0M@FMIDCGNI@ModelColour?$AA@		; `string'
PUBLIC	??_C@_08EGHFDCKI@lightPos?$AA@			; `string'
PUBLIC	??_C@_0M@ICIEANMG@lightColour?$AA@		; `string'
PUBLIC	??_C@_0M@NEELCHAN@lightBright?$AA@		; `string'
PUBLIC	??_C@_0O@OODJBMLI@ambientColour?$AA@		; `string'
PUBLIC	??_C@_06LAADFJPH@wiggle?$AA@			; `string'
PUBLIC	??_C@_0BB@HDLHOHKD@OutlineThickness?$AA@	; `string'
PUBLIC	??_C@_09HJHGEJDE@ClipPlane?$AA@			; `string'
PUBLIC	??_C@_06HGKAGIBP@Cube?4x?$AA@			; `string'
PUBLIC	??_C@_08KCKKFACH@Teapot?4x?$AA@			; `string'
PUBLIC	??_C@_08EEMGLHJD@Sphere?4x?$AA@			; `string'
PUBLIC	??_C@_07DBODOLME@Troll?4x?$AA@			; `string'
PUBLIC	??_C@_07MPPKGAHN@Floor?4x?$AA@			; `string'
PUBLIC	??_C@_1EA@JHMKKLFC@?$AAn?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5?$AAm?$AA_?$AAn?$AAS?$AAi?$AAz?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1KI@KJKLFHG@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; `string'
PUBLIC	??_C@_1IO@JLPDPDPD@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; `string'
PUBLIC	?id@?$numpunct@D@std@@2V0locale@2@A		; std::numpunct<char>::id
PUBLIC	?id@?$numpunct@_W@std@@2V0locale@2@A		; std::numpunct<wchar_t>::id
PUBLIC	??_C@_1BK@NHECDDNK@?$AAm?$AA_?$AAp?$AAD?$AAa?$AAt?$AAa?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
PUBLIC	??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; `string'
PUBLIC	??_R4error_category@std@@6B@			; std::error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVerror_category@std@@@8			; std::error_category `RTTI Type Descriptor'
PUBLIC	??_R3error_category@std@@8			; std::error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2error_category@std@@8			; std::error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@error_category@std@@8		; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Generic_error_category@std@@6B@		; std::_Generic_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Generic_error_category@std@@@8		; std::_Generic_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Generic_error_category@std@@8	; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Iostream_error_category@std@@@8	; std::_Iostream_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Iostream_error_category@std@@8	; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_System_error_category@std@@6B@		; std::_System_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_System_error_category@std@@@8		; std::_System_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_System_error_category@std@@8		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_System_error_category@std@@8		; std::_System_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_System_error_category@std@@8	; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@00000000
PUBLIC	__real@3dcccccd
PUBLIC	__real@3e4ccccd
PUBLIC	__real@3e99999a
PUBLIC	__real@3f000000
PUBLIC	__real@3f333333
PUBLIC	__real@3f490fdb
PUBLIC	__real@3f4ccccd
PUBLIC	__real@3f800000
PUBLIC	__real@3fc00000
PUBLIC	__real@40000000
PUBLIC	__real@40200000
PUBLIC	__real@40490fdb
PUBLIC	__real@40a00000
PUBLIC	__real@41200000
PUBLIC	__real@41480000
PUBLIC	__real@41500000
PUBLIC	__real@41700000
PUBLIC	__real@41880000
PUBLIC	__real@41900000
PUBLIC	__real@41a00000
PUBLIC	__real@41c80000
PUBLIC	__real@41f00000
PUBLIC	__real@42200000
PUBLIC	__real@42480000
PUBLIC	__real@42a00000
PUBLIC	__real@43180000
PUBLIC	__real@43340000
PUBLIC	__real@43480000
PUBLIC	__real@437a0000
PUBLIC	__real@461c4000
PUBLIC	__real@4e396fca
PUBLIC	__real@c1200000
PUBLIC	__real@c1700000
PUBLIC	__real@c1a00000
PUBLIC	__real@c1c80000
PUBLIC	__real@c1f00000
PUBLIC	__real@c2200000
PUBLIC	__real@c37a0000
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_strcpy_s:PROC
EXTRN	_strcat_s:PROC
EXTRN	_strlen:PROC
EXTRN	_memmove:PROC
EXTRN	_wcscpy_s:PROC
EXTRN	_wcslen:PROC
EXTRN	__imp__DecodePointer@4:PROC
EXTRN	__imp__RaiseException@16:PROC
EXTRN	__imp__GetLastError@0:PROC
EXTRN	__imp__InitializeCriticalSectionEx@12:PROC
EXTRN	__imp__DeleteCriticalSection@4:PROC
EXTRN	__imp__DefWindowProcW@16:PROC
EXTRN	__imp__PostQuitMessage@4:PROC
EXTRN	__imp__UnregisterClassW@8:PROC
EXTRN	__imp__RegisterClassExW@4:PROC
EXTRN	__imp__CreateWindowExW@48:PROC
EXTRN	__imp__DestroyWindow@4:PROC
EXTRN	__imp__ShowWindow@8:PROC
EXTRN	__imp__BeginPaint@8:PROC
EXTRN	__imp__EndPaint@8:PROC
EXTRN	__imp__SetWindowTextA@8:PROC
EXTRN	__imp__GetClientRect@8:PROC
EXTRN	__imp__AdjustWindowRect@12:PROC
EXTRN	__imp__MessageBoxW@16:PROC
EXTRN	__imp__LoadCursorW@8:PROC
EXTRN	__imp__LoadIconW@8:PROC
EXTRN	__imp__MultiByteToWideChar@24:PROC
EXTRN	_qsort:PROC
EXTRN	__itoa_s:PROC
EXTRN	_calloc:PROC
EXTRN	_free:PROC
EXTRN	_malloc:PROC
EXTRN	__recalloc:PROC
EXTRN	_D3D10CreateDeviceAndSwapChain@32:PROC
EXTRN	__hypot:PROC
EXTRN	_D3DX10CreateShaderResourceViewFromFileW@24:PROC
EXTRN	_D3DX10CreateEffectFromFileW@48:PROC
EXTRN	__CrtDbgReportW:PROC
EXTRN	_swprintf_s:PROC
EXTRN	__vsnwprintf_s:PROC
EXTRN	__vscwprintf:PROC
EXTRN	??0_Lockit@std@@QAE@H@Z:PROC			; std::_Lockit::_Lockit
EXTRN	??1_Lockit@std@@QAE@XZ:PROC			; std::_Lockit::~_Lockit
EXTRN	?_Debug_message@std@@YAXPB_W0I@Z:PROC		; std::_Debug_message
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
EXTRN	??_Eerror_category@std@@UAEPAXI@Z:PROC		; std::error_category::`vector deleting destructor'
EXTRN	?_Syserror_map@std@@YAPBDH@Z:PROC		; std::_Syserror_map
EXTRN	?_Winerror_map@std@@YAPBDH@Z:PROC		; std::_Winerror_map
EXTRN	??_E_Generic_error_category@std@@UAEPAXI@Z:PROC	; std::_Generic_error_category::`vector deleting destructor'
EXTRN	??_E_Iostream_error_category@std@@UAEPAXI@Z:PROC ; std::_Iostream_error_category::`vector deleting destructor'
EXTRN	??_E_System_error_category@std@@UAEPAXI@Z:PROC	; std::_System_error_category::`vector deleting destructor'
EXTRN	?KeyDownEvent@@YAXW4EKeyState@@@Z:PROC		; KeyDownEvent
EXTRN	?KeyUpEvent@@YAXW4EKeyState@@@Z:PROC		; KeyUpEvent
EXTRN	?KeyHit@@YA_NW4EKeyCode@@@Z:PROC		; KeyHit
EXTRN	??0CModel@@QAE@UD3DXVECTOR3@@0M@Z:PROC		; CModel::CModel
EXTRN	?Load@CModel@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUID3D10EffectTechnique@@_N@Z:PROC ; CModel::Load
EXTRN	?UpdateMatrix@CModel@@QAEXXZ:PROC		; CModel::UpdateMatrix
EXTRN	?Control@CModel@@QAEXMW4EKeyCode@@0000000@Z:PROC ; CModel::Control
EXTRN	?Render@CModel@@QAEXPAUID3D10EffectTechnique@@@Z:PROC ; CModel::Render
EXTRN	??0CCamera@@QAE@UD3DXVECTOR3@@0MMM@Z:PROC	; CCamera::CCamera
EXTRN	?UpdateMatrices@CCamera@@QAEXXZ:PROC		; CCamera::UpdateMatrices
EXTRN	?Control@CCamera@@QAEXMW4EKeyCode@@0000000@Z:PROC ; CCamera::Control
EXTRN	??0CLight@@QAE@XZ:PROC				; CLight::CLight
EXTRN	??1CLight@@QAE@XZ:PROC				; CLight::~CLight
EXTRN	?SetColour@CLight@@QAEXMMM@Z:PROC		; CLight::SetColour
EXTRN	?SetOrbit@CLight@@QAEXUD3DXVECTOR3@@MM@Z:PROC	; CLight::SetOrbit
EXTRN	?SetColourCycle@CLight@@QAEXM@Z:PROC		; CLight::SetColourCycle
EXTRN	?SetFade@CLight@@QAEXM@Z:PROC			; CLight::SetFade
EXTRN	?Update@CLight@@QAEXM@Z:PROC			; CLight::Update
EXTRN	??0CRenderObject@@QAE@QADUD3DXVECTOR3@@1PAUID3D10EffectTechnique@@2PAUID3D10ShaderResourceView@@3_N44@Z:PROC ; CRenderObject::CRenderObject
EXTRN	??1CRenderObject@@QAE@XZ:PROC			; CRenderObject::~CRenderObject
EXTRN	?SetColour@CRenderObject@@QAEXMMM@Z:PROC	; CRenderObject::SetColour
EXTRN	?Update@CRenderObject@@QAEXM@Z:PROC		; CRenderObject::Update
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	_memset:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?_AtlBaseModule@ATL@@3VCAtlBaseModule@1@A:BYTE	; ATL::_AtlBaseModule
EXTRN	___ImageBase:BYTE
EXTRN	?mpd3dDev@CModel@@0PAUID3D10Device@@A:DWORD	; CModel::mpd3dDev
EXTRN	?mViewportWidth@CCamera@@0HA:DWORD		; CCamera::mViewportWidth
EXTRN	?mViewportHeight@CCamera@@0HA:DWORD		; CCamera::mViewportHeight
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?atlTraceGeneral@ATL@@3V?$CTraceCategoryEx@$00$0A@@1@A
_BSS	SEGMENT
?atlTraceGeneral@ATL@@3V?$CTraceCategoryEx@$00$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceGeneral
_BSS	ENDS
;	COMDAT ?atlTraceCOM@ATL@@3V?$CTraceCategoryEx@$01$0A@@1@A
_BSS	SEGMENT
?atlTraceCOM@ATL@@3V?$CTraceCategoryEx@$01$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceCOM
_BSS	ENDS
;	COMDAT ?atlTraceQI@ATL@@3V?$CTraceCategoryEx@$03$0A@@1@A
_BSS	SEGMENT
?atlTraceQI@ATL@@3V?$CTraceCategoryEx@$03$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceQI
_BSS	ENDS
;	COMDAT ?atlTraceRegistrar@ATL@@3V?$CTraceCategoryEx@$07$0A@@1@A
_BSS	SEGMENT
?atlTraceRegistrar@ATL@@3V?$CTraceCategoryEx@$07$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceRegistrar
_BSS	ENDS
;	COMDAT ?atlTraceRefcount@ATL@@3V?$CTraceCategoryEx@$0BA@$0A@@1@A
_BSS	SEGMENT
?atlTraceRefcount@ATL@@3V?$CTraceCategoryEx@$0BA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceRefcount
_BSS	ENDS
;	COMDAT ?atlTraceWindowing@ATL@@3V?$CTraceCategoryEx@$0CA@$0A@@1@A
_BSS	SEGMENT
?atlTraceWindowing@ATL@@3V?$CTraceCategoryEx@$0CA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceWindowing
_BSS	ENDS
;	COMDAT ?atlTraceControls@ATL@@3V?$CTraceCategoryEx@$0EA@$0A@@1@A
_BSS	SEGMENT
?atlTraceControls@ATL@@3V?$CTraceCategoryEx@$0EA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceControls
_BSS	ENDS
;	COMDAT ?atlTraceHosting@ATL@@3V?$CTraceCategoryEx@$0IA@$0A@@1@A
_BSS	SEGMENT
?atlTraceHosting@ATL@@3V?$CTraceCategoryEx@$0IA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceHosting
_BSS	ENDS
;	COMDAT ?atlTraceDBClient@ATL@@3V?$CTraceCategoryEx@$0BAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceDBClient@ATL@@3V?$CTraceCategoryEx@$0BAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceDBClient
_BSS	ENDS
;	COMDAT ?atlTraceDBProvider@ATL@@3V?$CTraceCategoryEx@$0CAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceDBProvider@ATL@@3V?$CTraceCategoryEx@$0CAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceDBProvider
_BSS	ENDS
;	COMDAT ?atlTraceSnapin@ATL@@3V?$CTraceCategoryEx@$0EAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceSnapin@ATL@@3V?$CTraceCategoryEx@$0EAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceSnapin
_BSS	ENDS
;	COMDAT ?atlTraceNotImpl@ATL@@3V?$CTraceCategoryEx@$0IAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceNotImpl@ATL@@3V?$CTraceCategoryEx@$0IAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceNotImpl
_BSS	ENDS
;	COMDAT ?atlTraceAllocation@ATL@@3V?$CTraceCategoryEx@$0BAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceAllocation@ATL@@3V?$CTraceCategoryEx@$0BAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceAllocation
_BSS	ENDS
;	COMDAT ?atlTraceException@ATL@@3V?$CTraceCategoryEx@$0CAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceException@ATL@@3V?$CTraceCategoryEx@$0CAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceException
_BSS	ENDS
;	COMDAT ?atlTraceTime@ATL@@3V?$CTraceCategoryEx@$0EAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceTime@ATL@@3V?$CTraceCategoryEx@$0EAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceTime
_BSS	ENDS
;	COMDAT ?atlTraceCache@ATL@@3V?$CTraceCategoryEx@$0IAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceCache@ATL@@3V?$CTraceCategoryEx@$0IAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceCache
_BSS	ENDS
;	COMDAT ?atlTraceStencil@ATL@@3V?$CTraceCategoryEx@$0BAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceStencil@ATL@@3V?$CTraceCategoryEx@$0BAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceStencil
_BSS	ENDS
;	COMDAT ?atlTraceString@ATL@@3V?$CTraceCategoryEx@$0CAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceString@ATL@@3V?$CTraceCategoryEx@$0CAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceString
_BSS	ENDS
;	COMDAT ?atlTraceMap@ATL@@3V?$CTraceCategoryEx@$0EAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceMap@ATL@@3V?$CTraceCategoryEx@$0EAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceMap
_BSS	ENDS
;	COMDAT ?atlTraceUtil@ATL@@3V?$CTraceCategoryEx@$0IAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceUtil@ATL@@3V?$CTraceCategoryEx@$0IAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceUtil
_BSS	ENDS
;	COMDAT ?atlTraceSecurity@ATL@@3V?$CTraceCategoryEx@$0BAAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceSecurity@ATL@@3V?$CTraceCategoryEx@$0BAAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceSecurity
_BSS	ENDS
;	COMDAT ?atlTraceSync@ATL@@3V?$CTraceCategoryEx@$0CAAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceSync@ATL@@3V?$CTraceCategoryEx@$0CAAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceSync
_BSS	ENDS
;	COMDAT ?atlTraceISAPI@ATL@@3V?$CTraceCategoryEx@$0EAAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceISAPI@ATL@@3V?$CTraceCategoryEx@$0EAAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceISAPI
_BSS	ENDS
;	COMDAT ?_AtlComModule@ATL@@3VCAtlComModule@1@A
_BSS	SEGMENT
?_AtlComModule@ATL@@3VCAtlComModule@1@A DB 028H DUP (?)	; ATL::_AtlComModule
_BSS	ENDS
;	COMDAT ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A
_BSS	SEGMENT
?_AtlWinModule@ATL@@3VCAtlWinModule@1@A DB 02cH DUP (?)	; ATL::_AtlWinModule
_BSS	ENDS
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
	ALIGN	4

_allocator_arg DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
_BSS	SEGMENT
?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_Generic_object
_BSS	ENDS
;	COMDAT ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
_BSS	SEGMENT
?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_Iostream_object
_BSS	ENDS
;	COMDAT ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
_BSS	SEGMENT
?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_System_object
_BSS	ENDS
;	COMDAT ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
_BSS	ENDS
;	COMDAT ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
_BSS	ENDS
;	COMDAT ?id@?$numpunct@D@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@D@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<char>::id
_BSS	ENDS
;	COMDAT ?id@?$numpunct@_W@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@_W@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<wchar_t>::id
_BSS	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
_atlTraceGeneral$initializer$ DD FLAT:??__EatlTraceGeneral@ATL@@YAXXZ
CRT$XCU	ENDS
;	COMDAT __real@c37a0000
CONST	SEGMENT
__real@c37a0000 DD 0c37a0000r			; -250
CONST	ENDS
;	COMDAT __real@c2200000
CONST	SEGMENT
__real@c2200000 DD 0c2200000r			; -40
CONST	ENDS
;	COMDAT __real@c1f00000
CONST	SEGMENT
__real@c1f00000 DD 0c1f00000r			; -30
CONST	ENDS
;	COMDAT __real@c1c80000
CONST	SEGMENT
__real@c1c80000 DD 0c1c80000r			; -25
CONST	ENDS
;	COMDAT __real@c1a00000
CONST	SEGMENT
__real@c1a00000 DD 0c1a00000r			; -20
CONST	ENDS
;	COMDAT __real@c1700000
CONST	SEGMENT
__real@c1700000 DD 0c1700000r			; -15
CONST	ENDS
;	COMDAT __real@c1200000
CONST	SEGMENT
__real@c1200000 DD 0c1200000r			; -10
CONST	ENDS
;	COMDAT __real@4e396fca
CONST	SEGMENT
__real@4e396fca DD 04e396fcar			; 7.77778e+008
CONST	ENDS
;	COMDAT __real@461c4000
CONST	SEGMENT
__real@461c4000 DD 0461c4000r			; 10000
CONST	ENDS
;	COMDAT __real@437a0000
CONST	SEGMENT
__real@437a0000 DD 0437a0000r			; 250
CONST	ENDS
;	COMDAT __real@43480000
CONST	SEGMENT
__real@43480000 DD 043480000r			; 200
CONST	ENDS
;	COMDAT __real@43340000
CONST	SEGMENT
__real@43340000 DD 043340000r			; 180
CONST	ENDS
;	COMDAT __real@43180000
CONST	SEGMENT
__real@43180000 DD 043180000r			; 152
CONST	ENDS
;	COMDAT __real@42a00000
CONST	SEGMENT
__real@42a00000 DD 042a00000r			; 80
CONST	ENDS
;	COMDAT __real@42480000
CONST	SEGMENT
__real@42480000 DD 042480000r			; 50
CONST	ENDS
;	COMDAT __real@42200000
CONST	SEGMENT
__real@42200000 DD 042200000r			; 40
CONST	ENDS
;	COMDAT __real@41f00000
CONST	SEGMENT
__real@41f00000 DD 041f00000r			; 30
CONST	ENDS
;	COMDAT __real@41c80000
CONST	SEGMENT
__real@41c80000 DD 041c80000r			; 25
CONST	ENDS
;	COMDAT __real@41a00000
CONST	SEGMENT
__real@41a00000 DD 041a00000r			; 20
CONST	ENDS
;	COMDAT __real@41900000
CONST	SEGMENT
__real@41900000 DD 041900000r			; 18
CONST	ENDS
;	COMDAT __real@41880000
CONST	SEGMENT
__real@41880000 DD 041880000r			; 17
CONST	ENDS
;	COMDAT __real@41700000
CONST	SEGMENT
__real@41700000 DD 041700000r			; 15
CONST	ENDS
;	COMDAT __real@41500000
CONST	SEGMENT
__real@41500000 DD 041500000r			; 13
CONST	ENDS
;	COMDAT __real@41480000
CONST	SEGMENT
__real@41480000 DD 041480000r			; 12.5
CONST	ENDS
;	COMDAT __real@41200000
CONST	SEGMENT
__real@41200000 DD 041200000r			; 10
CONST	ENDS
;	COMDAT __real@40a00000
CONST	SEGMENT
__real@40a00000 DD 040a00000r			; 5
CONST	ENDS
;	COMDAT __real@40490fdb
CONST	SEGMENT
__real@40490fdb DD 040490fdbr			; 3.14159
CONST	ENDS
;	COMDAT __real@40200000
CONST	SEGMENT
__real@40200000 DD 040200000r			; 2.5
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3fc00000
CONST	SEGMENT
__real@3fc00000 DD 03fc00000r			; 1.5
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f4ccccd
CONST	SEGMENT
__real@3f4ccccd DD 03f4ccccdr			; 0.8
CONST	ENDS
;	COMDAT __real@3f490fdb
CONST	SEGMENT
__real@3f490fdb DD 03f490fdbr			; 0.785398
CONST	ENDS
;	COMDAT __real@3f333333
CONST	SEGMENT
__real@3f333333 DD 03f333333r			; 0.7
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3e99999a
CONST	SEGMENT
__real@3e99999a DD 03e99999ar			; 0.3
CONST	ENDS
;	COMDAT __real@3e4ccccd
CONST	SEGMENT
__real@3e4ccccd DD 03e4ccccdr			; 0.2
CONST	ENDS
;	COMDAT __real@3dcccccd
CONST	SEGMENT
__real@3dcccccd DD 03dcccccdr			; 0.1
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_R1A@?0A@EA@_System_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_System_error_category@std@@8 DD FLAT:??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_System_error_category@std@@8
rdata$r	SEGMENT
??_R2_System_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_System_error_category@std@@8
rdata$r	SEGMENT
??_R3_System_error_category@std@@8 DD 00H		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_System_error_category@std@@@8
data$r	SEGMENT
??_R0?AV_System_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_System_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_System_error_category@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4_System_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_System_error_category@std@@6B@ DD 00H		; std::_System_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_System_error_category@std@@@8
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Iostream_error_category@std@@8 DD FLAT:??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R2_Iostream_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R3_Iostream_error_category@std@@8 DD 00H		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Iostream_error_category@std@@@8
data$r	SEGMENT
??_R0?AV_Iostream_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Iostream_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Iostream_error_category@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4_Iostream_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Iostream_error_category@std@@6B@ DD 00H		; std::_Iostream_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Iostream_error_category@std@@@8
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Generic_error_category@std@@8 DD FLAT:??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R2_Generic_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R3_Generic_error_category@std@@8 DD 00H		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Generic_error_category@std@@@8
data$r	SEGMENT
??_R0?AV_Generic_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Generic_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Generic_error_category@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4_Generic_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Generic_error_category@std@@6B@ DD 00H		; std::_Generic_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Generic_error_category@std@@@8
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@error_category@std@@8 DD FLAT:??_R0?AVerror_category@std@@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2error_category@std@@8
rdata$r	SEGMENT
??_R2error_category@std@@8 DD FLAT:??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3error_category@std@@8
rdata$r	SEGMENT
??_R3error_category@std@@8 DD 00H			; std::error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVerror_category@std@@@8
data$r	SEGMENT
??_R0?AVerror_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVerror_category@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4error_category@std@@6B@
rdata$r	SEGMENT
??_R4error_category@std@@6B@ DD 00H			; std::error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVerror_category@std@@@8
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
CONST	SEGMENT
??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ DB 'i'
	DB	00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H, 'd', 00H
	DB	' ', 00H, 'n', 00H, 'u', 00H, 'l', 00H, 'l', 00H, ' ', 00H, 'p'
	DB	00H, 'o', 00H, 'i', 00H, 'n', 00H, 't', 00H, 'e', 00H, 'r', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BK@NHECDDNK@?$AAm?$AA_?$AAp?$AAD?$AAa?$AAt?$AAa?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1BK@NHECDDNK@?$AAm?$AA_?$AAp?$AAD?$AAa?$AAt?$AAa?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@ DB 'm'
	DB	00H, '_', 00H, 'p', 00H, 'D', 00H, 'a', 00H, 't', 00H, 'a', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '0', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1IO@JLPDPDPD@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
CONST	SEGMENT
??_C@_1IO@JLPDPDPD@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 'm', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H
	DB	'v', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' '
	DB	00H, 's', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	' ', 00H, '1', 00H, '2', 00H, '.', 00H, '0', 00H, '\', 00H, 'v'
	DB	00H, 'c', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l', 00H
	DB	'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'x', 00H, 's', 00H, 't'
	DB	00H, 'r', 00H, 'i', 00H, 'n', 00H, 'g', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1KI@KJKLFHG@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
CONST	SEGMENT
??_C@_1KI@KJKLFHG@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 'm', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H
	DB	'v', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' '
	DB	00H, 's', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	' ', 00H, '1', 00H, '2', 00H, '.', 00H, '0', 00H, '\', 00H, 'v'
	DB	00H, 'c', 00H, '\', 00H, 'a', 00H, 't', 00H, 'l', 00H, 'm', 00H
	DB	'f', 00H, 'c', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l'
	DB	00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'a', 00H, 't', 00H
	DB	'l', 00H, 's', 00H, 'i', 00H, 'm', 00H, 'p', 00H, 'c', 00H, 'o'
	DB	00H, 'l', 00H, 'l', 00H, '.', 00H, 'h', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EA@JHMKKLFC@?$AAn?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5?$AAm?$AA_?$AAn?$AAS?$AAi?$AAz?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1EA@JHMKKLFC@?$AAn?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5?$AAm?$AA_?$AAn?$AAS?$AAi?$AAz?$AAe?$AA?$AA@ DB 'n'
	DB	00H, 'I', 00H, 'n', 00H, 'd', 00H, 'e', 00H, 'x', 00H, ' ', 00H
	DB	'>', 00H, '=', 00H, ' ', 00H, '0', 00H, ' ', 00H, '&', 00H, '&'
	DB	00H, ' ', 00H, 'n', 00H, 'I', 00H, 'n', 00H, 'd', 00H, 'e', 00H
	DB	'x', 00H, ' ', 00H, '<', 00H, ' ', 00H, 'm', 00H, '_', 00H, 'n'
	DB	00H, 'S', 00H, 'i', 00H, 'z', 00H, 'e', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07MPPKGAHN@Floor?4x?$AA@
CONST	SEGMENT
??_C@_07MPPKGAHN@Floor?4x?$AA@ DB 'Floor.x', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07DBODOLME@Troll?4x?$AA@
CONST	SEGMENT
??_C@_07DBODOLME@Troll?4x?$AA@ DB 'Troll.x', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08EEMGLHJD@Sphere?4x?$AA@
CONST	SEGMENT
??_C@_08EEMGLHJD@Sphere?4x?$AA@ DB 'Sphere.x', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08KCKKFACH@Teapot?4x?$AA@
CONST	SEGMENT
??_C@_08KCKKFACH@Teapot?4x?$AA@ DB 'Teapot.x', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06HGKAGIBP@Cube?4x?$AA@
CONST	SEGMENT
??_C@_06HGKAGIBP@Cube?4x?$AA@ DB 'Cube.x', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09HJHGEJDE@ClipPlane?$AA@
CONST	SEGMENT
??_C@_09HJHGEJDE@ClipPlane?$AA@ DB 'ClipPlane', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@HDLHOHKD@OutlineThickness?$AA@
CONST	SEGMENT
??_C@_0BB@HDLHOHKD@OutlineThickness?$AA@ DB 'OutlineThickness', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06LAADFJPH@wiggle?$AA@
CONST	SEGMENT
??_C@_06LAADFJPH@wiggle?$AA@ DB 'wiggle', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@OODJBMLI@ambientColour?$AA@
CONST	SEGMENT
??_C@_0O@OODJBMLI@ambientColour?$AA@ DB 'ambientColour', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NEELCHAN@lightBright?$AA@
CONST	SEGMENT
??_C@_0M@NEELCHAN@lightBright?$AA@ DB 'lightBright', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@ICIEANMG@lightColour?$AA@
CONST	SEGMENT
??_C@_0M@ICIEANMG@lightColour?$AA@ DB 'lightColour', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08EGHFDCKI@lightPos?$AA@
CONST	SEGMENT
??_C@_08EGHFDCKI@lightPos?$AA@ DB 'lightPos', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FMIDCGNI@ModelColour?$AA@
CONST	SEGMENT
??_C@_0M@FMIDCGNI@ModelColour?$AA@ DB 'ModelColour', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09JBPBDAII@cameraPos?$AA@
CONST	SEGMENT
??_C@_09JBPBDAII@cameraPos?$AA@ DB 'cameraPos', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09ILPGELJF@NormalMap?$AA@
CONST	SEGMENT
??_C@_09ILPGELJF@NormalMap?$AA@ DB 'NormalMap', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@ILIGHKAJ@DiffuseMap?$AA@
CONST	SEGMENT
??_C@_0L@ILIGHKAJ@DiffuseMap?$AA@ DB 'DiffuseMap', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@FHHLNBJL@ProjMatrix?$AA@
CONST	SEGMENT
??_C@_0L@FHHLNBJL@ProjMatrix?$AA@ DB 'ProjMatrix', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BCBAMPKD@ViewMatrix?$AA@
CONST	SEGMENT
??_C@_0L@BCBAMPKD@ViewMatrix?$AA@ DB 'ViewMatrix', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JIFPIELG@WorldMatrix?$AA@
CONST	SEGMENT
??_C@_0M@JIFPIELG@WorldMatrix?$AA@ DB 'WorldMatrix', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@BLJDFMPB@tTextureMorphMirror?$AA@
CONST	SEGMENT
??_C@_0BE@BLJDFMPB@tTextureMorphMirror?$AA@ DB 'tTextureMorphMirror', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@CKKPKAMN@tSpaceOutlineMirror?$AA@
CONST	SEGMENT
??_C@_0BE@CKKPKAMN@tSpaceOutlineMirror?$AA@ DB 'tSpaceOutlineMirror', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@CDMINDKK@tSpaceHaloMirror?$AA@
CONST	SEGMENT
??_C@_0BB@CDMINDKK@tSpaceHaloMirror?$AA@ DB 'tSpaceHaloMirror', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@BCLLKFIB@tLitGlassMirror?$AA@
CONST	SEGMENT
??_C@_0BA@BCLLKFIB@tLitGlassMirror?$AA@ DB 'tLitGlassMirror', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@GGPGLIH@tSpaceOutlineParaMirror?$AA@
CONST	SEGMENT
??_C@_0BI@GGPGLIH@tSpaceOutlineParaMirror?$AA@ DB 'tSpaceOutlineParaMirro'
	DB	'r', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@KFEJDHPA@tSpaceHaloParaMirror?$AA@
CONST	SEGMENT
??_C@_0BF@KFEJDHPA@tSpaceHaloParaMirror?$AA@ DB 'tSpaceHaloParaMirror', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FENFNCKC@tHaloMirror?$AA@
CONST	SEGMENT
??_C@_0M@FENFNCKC@tHaloMirror?$AA@ DB 'tHaloMirror', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@MCEONCDC@tCellShadingWrongMirror?$AA@
CONST	SEGMENT
??_C@_0BI@MCEONCDC@tCellShadingWrongMirror?$AA@ DB 'tCellShadingWrongMirr'
	DB	'or', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@NDCFMGPA@tCellShadingMirror?$AA@
CONST	SEGMENT
??_C@_0BD@NDCFMGPA@tCellShadingMirror?$AA@ DB 'tCellShadingMirror', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KFADNAIL@tJellyMirror?$AA@
CONST	SEGMENT
??_C@_0N@KFADNAIL@tJellyMirror?$AA@ DB 'tJellyMirror', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@CIMFECON@tParallaxMapMirror?$AA@
CONST	SEGMENT
??_C@_0BD@CIMFECON@tParallaxMapMirror?$AA@ DB 'tParallaxMapMirror', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@MJFOIGI@t4LitSpecularMapMirror?$AA@
CONST	SEGMENT
??_C@_0BH@MJFOIGI@t4LitSpecularMapMirror?$AA@ DB 't4LitSpecularMapMirror', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@EEKKACMN@t4LitAttenTextureMirror?$AA@
CONST	SEGMENT
??_C@_0BI@EEKKACMN@t4LitAttenTextureMirror?$AA@ DB 't4LitAttenTextureMirr'
	DB	'or', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@GNCBGOED@t4LitTextureMirror?$AA@
CONST	SEGMENT
??_C@_0BD@GNCBGOED@t4LitTextureMirror?$AA@ DB 't4LitTextureMirror', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@PLBJLENF@tLitTextureMirror?$AA@
CONST	SEGMENT
??_C@_0BC@PLBJLENF@tLitTextureMirror?$AA@ DB 'tLitTextureMirror', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@BDPLHMPN@tColourChangeTextureMirror?$AA@
CONST	SEGMENT
??_C@_0BL@BDPLHMPN@tColourChangeTextureMirror?$AA@ DB 'tColourChangeTextu'
	DB	'reMirror', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GKDAAGPD@tPlainTextureMirror?$AA@
CONST	SEGMENT
??_C@_0BE@GKDAAGPD@tPlainTextureMirror?$AA@ DB 'tPlainTextureMirror', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@EAMCFOMD@tPlainColourMirror?$AA@
CONST	SEGMENT
??_C@_0BD@EAMCFOMD@tPlainColourMirror?$AA@ DB 'tPlainColourMirror', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CFAHMOKA@MirrorSurface?$AA@
CONST	SEGMENT
??_C@_0O@CFAHMOKA@MirrorSurface?$AA@ DB 'MirrorSurface', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NCEALFAM@MirrorClear?$AA@
CONST	SEGMENT
??_C@_0M@NCEALFAM@MirrorClear?$AA@ DB 'MirrorClear', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CIOABDO@tTextureMorph?$AA@
CONST	SEGMENT
??_C@_0O@CIOABDO@tTextureMorph?$AA@ DB 'tTextureMorph', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@GOICGJFK@tSpaceOutline?$AA@
CONST	SEGMENT
??_C@_0O@GOICGJFK@tSpaceOutline?$AA@ DB 'tSpaceOutline', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MOJEDPIK@tSpaceHalo?$AA@
CONST	SEGMENT
??_C@_0L@MOJEDPIK@tSpaceHalo?$AA@ DB 'tSpaceHalo', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09JDFCMBBC@tLitGlass?$AA@
CONST	SEGMENT
??_C@_09JDFCMBBC@tLitGlass?$AA@ DB 'tLitGlass', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@NABDBAIK@tSpaceOutlinePara?$AA@
CONST	SEGMENT
??_C@_0BC@NABDBAIK@tSpaceOutlinePara?$AA@ DB 'tSpaceOutlinePara', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@FEDIONCO@tSpaceHaloPara?$AA@
CONST	SEGMENT
??_C@_0P@FEDIONCO@tSpaceHaloPara?$AA@ DB 'tSpaceHaloPara', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05JGDPNHEJ@tHalo?$AA@
CONST	SEGMENT
??_C@_05JGDPNHEJ@tHalo?$AA@ DB 'tHalo', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@IHNCMDEH@tCellShadingWrong?$AA@
CONST	SEGMENT
??_C@_0BC@IHNCMDEH@tCellShadingWrong?$AA@ DB 'tCellShadingWrong', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@HPAFDOEN@tCellShading?$AA@
CONST	SEGMENT
??_C@_0N@HPAFDOEN@tCellShading?$AA@ DB 'tCellShading', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06ELGFLNMO@tJelly?$AA@
CONST	SEGMENT
??_C@_06ELGFLNMO@tJelly?$AA@ DB 'tJelly', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FAEPMAEM@tParallaxMap?$AA@
CONST	SEGMENT
??_C@_0N@FAEPMAEM@tParallaxMap?$AA@ DB 'tParallaxMap', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@NDOCHMBG@t4LitSpecularMap?$AA@
CONST	SEGMENT
??_C@_0BB@NDOCHMBG@t4LitSpecularMap?$AA@ DB 't4LitSpecularMap', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@EBBNGCN@t4LitAttenTexture?$AA@
CONST	SEGMENT
??_C@_0BC@EBBNGCN@t4LitAttenTexture?$AA@ DB 't4LitAttenTexture', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DBNJLAPA@t4LitTexture?$AA@
CONST	SEGMENT
??_C@_0N@DBNJLAPA@t4LitTexture?$AA@ DB 't4LitTexture', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PFGJBPP@tLitTexture?$AA@
CONST	SEGMENT
??_C@_0M@PFGJBPP@tLitTexture?$AA@ DB 'tLitTexture', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@HOFAMMJK@tColourChangeTexture?$AA@
CONST	SEGMENT
??_C@_0BF@HOFAMMJK@tColourChangeTexture?$AA@ DB 'tColourChangeTexture', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CBIDLEEF@tPlainTexture?$AA@
CONST	SEGMENT
??_C@_0O@CBIDLEEF@tPlainTexture?$AA@ DB 'tPlainTexture', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BLACAFBJ@tPlainColour?$AA@
CONST	SEGMENT
??_C@_0N@BLACAFBJ@tPlainColour?$AA@ DB 'tPlainColour', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1KK@KKJBPFMN@?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?5?$AAl?$AAo?$AAa?$AAd?$AAi?$AAn?$AAg?$AA?5?$AAF?$AAX?$AA?5?$AAf?$AAi?$AAl?$AAe?$AA?4?$AA?5?$AAE?$AAn?$AAs?$AAu?$AAr?$AAe?$AA?5?$AAy?$AAo@
CONST	SEGMENT
??_C@_1KK@KKJBPFMN@?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?5?$AAl?$AAo?$AAa?$AAd?$AAi?$AAn?$AAg?$AA?5?$AAF?$AAX?$AA?5?$AAf?$AAi?$AAl?$AAe?$AA?4?$AA?5?$AAE?$AAn?$AAs?$AAu?$AAr?$AAe?$AA?5?$AAy?$AAo@ DB 'E'
	DB	00H, 'r', 00H, 'r', 00H, 'o', 00H, 'r', 00H, ' ', 00H, 'l', 00H
	DB	'o', 00H, 'a', 00H, 'd', 00H, 'i', 00H, 'n', 00H, 'g', 00H, ' '
	DB	00H, 'F', 00H, 'X', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'l', 00H
	DB	'e', 00H, '.', 00H, ' ', 00H, 'E', 00H, 'n', 00H, 's', 00H, 'u'
	DB	00H, 'r', 00H, 'e', 00H, ' ', 00H, 'y', 00H, 'o', 00H, 'u', 00H
	DB	'r', 00H, ' ', 00H, 'F', 00H, 'X', 00H, ' ', 00H, 'f', 00H, 'i'
	DB	00H, 'l', 00H, 'e', 00H, ' ', 00H, 'i', 00H, 's', 00H, ' ', 00H
	DB	'i', 00H, 'n', 00H, ' ', 00H, 't', 00H, 'h', 00H, 'e', 00H, ' '
	DB	00H, 's', 00H, 'a', 00H, 'm', 00H, 'e', 00H, ' ', 00H, 'f', 00H
	DB	'o', 00H, 'l', 00H, 'd', 00H, 'e', 00H, 'r', 00H, ' ', 00H, 'a'
	DB	00H, 's', 00H, ' ', 00H, 't', 00H, 'h', 00H, 'i', 00H, 's', 00H
	DB	' ', 00H, 'e', 00H, 'x', 00H, 'e', 00H, 'c', 00H, 'u', 00H, 't'
	DB	00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H, '.', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@ILHOPKA@?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?$AA@
CONST	SEGMENT
??_C@_1M@ILHOPKA@?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?$AA@ DB 'E', 00H, 'r', 00H
	DB	'r', 00H, 'o', 00H, 'r', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@MCKIKNIO@?$AAG?$AAr?$AAa?$AAp?$AAh?$AAi?$AAc?$AAs?$AAA?$AAs?$AAs?$AAi?$AAg?$AAn?$AA1?$AA?4?$AAf?$AAx?$AA?$AA@
CONST	SEGMENT
??_C@_1CG@MCKIKNIO@?$AAG?$AAr?$AAa?$AAp?$AAh?$AAi?$AAc?$AAs?$AAA?$AAs?$AAs?$AAi?$AAg?$AAn?$AA1?$AA?4?$AAf?$AAx?$AA?$AA@ DB 'G'
	DB	00H, 'r', 00H, 'a', 00H, 'p', 00H, 'h', 00H, 'i', 00H, 'c', 00H
	DB	's', 00H, 'A', 00H, 's', 00H, 's', 00H, 'i', 00H, 'g', 00H, 'n'
	DB	00H, '1', 00H, '.', 00H, 'f', 00H, 'x', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06BACILOGA@fx_4_0?$AA@
CONST	SEGMENT
??_C@_06BACILOGA@fx_4_0?$AA@ DB 'fx_4_0', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1EO@IKJJOGJD@?$AAC?$AAO?$AA2?$AA4?$AA0?$AA9?$AA?5?$AA?9?$AA?5?$AAG?$AAr?$AAa?$AAp?$AAh?$AAi?$AAc?$AAs?$AA?5?$AAA?$AAs?$AAs?$AAi?$AAg?$AAn?$AAm?$AAe?$AAn?$AAt?$AA?5?$AA?9?$AA?5?$AAS@
CONST	SEGMENT
??_C@_1EO@IKJJOGJD@?$AAC?$AAO?$AA2?$AA4?$AA0?$AA9?$AA?5?$AA?9?$AA?5?$AAG?$AAr?$AAa?$AAp?$AAh?$AAi?$AAc?$AAs?$AA?5?$AAA?$AAs?$AAs?$AAi?$AAg?$AAn?$AAm?$AAe?$AAn?$AAt?$AA?5?$AA?9?$AA?5?$AAS@ DB 'C'
	DB	00H, 'O', 00H, '2', 00H, '4', 00H, '0', 00H, '9', 00H, ' ', 00H
	DB	'-', 00H, ' ', 00H, 'G', 00H, 'r', 00H, 'a', 00H, 'p', 00H, 'h'
	DB	00H, 'i', 00H, 'c', 00H, 's', 00H, ' ', 00H, 'A', 00H, 's', 00H
	DB	's', 00H, 'i', 00H, 'g', 00H, 'n', 00H, 'm', 00H, 'e', 00H, 'n'
	DB	00H, 't', 00H, ' ', 00H, '-', 00H, ' ', 00H, 'S', 00H, 'h', 00H
	DB	'a', 00H, 'd', 00H, 'e', 00H, 'r', 00H, 's', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CI@OKMLABGO@?$AAT?$AAu?$AAt?$AAo?$AAr?$AAi?$AAa?$AAl?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AAC?$AAl?$AAa?$AAs?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1CI@OKMLABGO@?$AAT?$AAu?$AAt?$AAo?$AAr?$AAi?$AAa?$AAl?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AAC?$AAl?$AAa?$AAs?$AAs?$AA?$AA@ DB 'T'
	DB	00H, 'u', 00H, 't', 00H, 'o', 00H, 'r', 00H, 'i', 00H, 'a', 00H
	DB	'l', 00H, 'W', 00H, 'i', 00H, 'n', 00H, 'd', 00H, 'o', 00H, 'w'
	DB	00H, 'C', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04JFKGIEIH@?5L?3?5?$AA@
CONST	SEGMENT
??_C@_04JFKGIEIH@?5L?3?5?$AA@ DB ' L: ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04IHBDCLGJ@?5O?3?5?$AA@
CONST	SEGMENT
??_C@_04IHBDCLGJ@?5O?3?5?$AA@ DB ' O: ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@HGOJECN@CO2409?5?9?5Graphics?5Assignment?5?9?5S@
CONST	SEGMENT
??_C@_0CM@HGOJECN@CO2409?5?9?5Graphics?5Assignment?5?9?5S@ DB 'CO2409 - G'
	DB	'raphics Assignment - Shaders FPS ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08MLPDMJMG@Mirror?4x?$AA@
CONST	SEGMENT
??_C@_08MLPDMJMG@Mirror?4x?$AA@ DB 'Mirror.x', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1CK@IHOPDIJ@?$AAB?$AAr?$AAa?$AAi?$AAn?$AAN?$AAo?$AAr?$AAm?$AAa?$AAl?$AAD?$AAe?$AAp?$AAt?$AAh?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1CK@IHOPDIJ@?$AAB?$AAr?$AAa?$AAi?$AAn?$AAN?$AAo?$AAr?$AAm?$AAa?$AAl?$AAD?$AAe?$AAp?$AAt?$AAh?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@ DB 'B'
	DB	00H, 'r', 00H, 'a', 00H, 'i', 00H, 'n', 00H, 'N', 00H, 'o', 00H
	DB	'r', 00H, 'm', 00H, 'a', 00H, 'l', 00H, 'D', 00H, 'e', 00H, 'p'
	DB	00H, 't', 00H, 'h', 00H, '.', 00H, 'd', 00H, 'd', 00H, 's', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1DC@ONLGGDNI@?$AAB?$AAr?$AAa?$AAi?$AAn?$AAD?$AAi?$AAf?$AAf?$AAu?$AAs?$AAe?$AAS?$AAp?$AAe?$AAc?$AAu?$AAl?$AAa?$AAr?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1DC@ONLGGDNI@?$AAB?$AAr?$AAa?$AAi?$AAn?$AAD?$AAi?$AAf?$AAf?$AAu?$AAs?$AAe?$AAS?$AAp?$AAe?$AAc?$AAu?$AAl?$AAa?$AAr?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@ DB 'B'
	DB	00H, 'r', 00H, 'a', 00H, 'i', 00H, 'n', 00H, 'D', 00H, 'i', 00H
	DB	'f', 00H, 'f', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'S', 00H, 'p'
	DB	00H, 'e', 00H, 'c', 00H, 'u', 00H, 'l', 00H, 'a', 00H, 'r', 00H
	DB	'.', 00H, 'd', 00H, 'd', 00H, 's', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DE@HNAGGCPI@?$AAT?$AAr?$AAo?$AAl?$AAl?$AA4?$AAD?$AAi?$AAf?$AAf?$AAu?$AAs?$AAe?$AAS?$AAp?$AAe?$AAc?$AAu?$AAl?$AAa?$AAr?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1DE@HNAGGCPI@?$AAT?$AAr?$AAo?$AAl?$AAl?$AA4?$AAD?$AAi?$AAf?$AAf?$AAu?$AAs?$AAe?$AAS?$AAp?$AAe?$AAc?$AAu?$AAl?$AAa?$AAr?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@ DB 'T'
	DB	00H, 'r', 00H, 'o', 00H, 'l', 00H, 'l', 00H, '4', 00H, 'D', 00H
	DB	'i', 00H, 'f', 00H, 'f', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'S'
	DB	00H, 'p', 00H, 'e', 00H, 'c', 00H, 'u', 00H, 'l', 00H, 'a', 00H
	DB	'r', 00H, '.', 00H, 'd', 00H, 'd', 00H, 's', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DE@KMEIPAPA@?$AAT?$AAr?$AAo?$AAl?$AAl?$AA3?$AAD?$AAi?$AAf?$AAf?$AAu?$AAs?$AAe?$AAS?$AAp?$AAe?$AAc?$AAu?$AAl?$AAa?$AAr?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1DE@KMEIPAPA@?$AAT?$AAr?$AAo?$AAl?$AAl?$AA3?$AAD?$AAi?$AAf?$AAf?$AAu?$AAs?$AAe?$AAS?$AAp?$AAe?$AAc?$AAu?$AAl?$AAa?$AAr?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@ DB 'T'
	DB	00H, 'r', 00H, 'o', 00H, 'l', 00H, 'l', 00H, '3', 00H, 'D', 00H
	DB	'i', 00H, 'f', 00H, 'f', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'S'
	DB	00H, 'p', 00H, 'e', 00H, 'c', 00H, 'u', 00H, 'l', 00H, 'a', 00H
	DB	'r', 00H, '.', 00H, 'd', 00H, 'd', 00H, 's', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DE@NHBHEBO@?$AAT?$AAr?$AAo?$AAl?$AAl?$AA2?$AAD?$AAi?$AAf?$AAf?$AAu?$AAs?$AAe?$AAS?$AAp?$AAe?$AAc?$AAu?$AAl?$AAa?$AAr?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1DE@NHBHEBO@?$AAT?$AAr?$AAo?$AAl?$AAl?$AA2?$AAD?$AAi?$AAf?$AAf?$AAu?$AAs?$AAe?$AAS?$AAp?$AAe?$AAc?$AAu?$AAl?$AAa?$AAr?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@ DB 'T'
	DB	00H, 'r', 00H, 'o', 00H, 'l', 00H, 'l', 00H, '2', 00H, 'D', 00H
	DB	'i', 00H, 'f', 00H, 'f', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'S'
	DB	00H, 'p', 00H, 'e', 00H, 'c', 00H, 'u', 00H, 'l', 00H, 'a', 00H
	DB	'r', 00H, '.', 00H, 'd', 00H, 'd', 00H, 's', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DE@DFEKPPGN@?$AAT?$AAr?$AAo?$AAl?$AAl?$AA1?$AAD?$AAi?$AAf?$AAf?$AAu?$AAs?$AAe?$AAS?$AAp?$AAe?$AAc?$AAu?$AAl?$AAa?$AAr?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1DE@DFEKPPGN@?$AAT?$AAr?$AAo?$AAl?$AAl?$AA1?$AAD?$AAi?$AAf?$AAf?$AAu?$AAs?$AAe?$AAS?$AAp?$AAe?$AAc?$AAu?$AAl?$AAa?$AAr?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@ DB 'T'
	DB	00H, 'r', 00H, 'o', 00H, 'l', 00H, 'l', 00H, '1', 00H, 'D', 00H
	DB	'i', 00H, 'f', 00H, 'f', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'S'
	DB	00H, 'p', 00H, 'e', 00H, 'c', 00H, 'u', 00H, 'l', 00H, 'a', 00H
	DB	'r', 00H, '.', 00H, 'd', 00H, 'd', 00H, 's', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BE@DADLEHEK@?$AAG?$AAl?$AAa?$AAs?$AAs?$AA?4?$AAj?$AAp?$AAg?$AA?$AA@
CONST	SEGMENT
??_C@_1BE@DADLEHEK@?$AAG?$AAl?$AAa?$AAs?$AAs?$AA?4?$AAj?$AAp?$AAg?$AA?$AA@ DB 'G'
	DB	00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H, '.', 00H, 'j', 00H
	DB	'p', 00H, 'g', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1CO@NOLHING@?$AAP?$AAa?$AAt?$AAt?$AAe?$AAr?$AAn?$AAN?$AAo?$AAr?$AAm?$AAa?$AAl?$AAD?$AAe?$AAp?$AAt?$AAh?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1CO@NOLHING@?$AAP?$AAa?$AAt?$AAt?$AAe?$AAr?$AAn?$AAN?$AAo?$AAr?$AAm?$AAa?$AAl?$AAD?$AAe?$AAp?$AAt?$AAh?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@ DB 'P'
	DB	00H, 'a', 00H, 't', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'n', 00H
	DB	'N', 00H, 'o', 00H, 'r', 00H, 'm', 00H, 'a', 00H, 'l', 00H, 'D'
	DB	00H, 'e', 00H, 'p', 00H, 't', 00H, 'h', 00H, '.', 00H, 'd', 00H
	DB	'd', 00H, 's', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1DG@GOOKDEDK@?$AAP?$AAa?$AAt?$AAt?$AAe?$AAr?$AAn?$AAD?$AAi?$AAf?$AAf?$AAu?$AAs?$AAe?$AAS?$AAp?$AAe?$AAc?$AAu?$AAl?$AAa?$AAr?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1DG@GOOKDEDK@?$AAP?$AAa?$AAt?$AAt?$AAe?$AAr?$AAn?$AAD?$AAi?$AAf?$AAf?$AAu?$AAs?$AAe?$AAS?$AAp?$AAe?$AAc?$AAu?$AAl?$AAa?$AAr?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@ DB 'P'
	DB	00H, 'a', 00H, 't', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'n', 00H
	DB	'D', 00H, 'i', 00H, 'f', 00H, 'f', 00H, 'u', 00H, 's', 00H, 'e'
	DB	00H, 'S', 00H, 'p', 00H, 'e', 00H, 'c', 00H, 'u', 00H, 'l', 00H
	DB	'a', 00H, 'r', 00H, '.', 00H, 'd', 00H, 'd', 00H, 's', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1DC@DJHFCGLD@?$AAM?$AAe?$AAt?$AAa?$AAl?$AAD?$AAi?$AAf?$AAf?$AAu?$AAs?$AAe?$AAS?$AAp?$AAe?$AAc?$AAu?$AAl?$AAa?$AAr?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1DC@DJHFCGLD@?$AAM?$AAe?$AAt?$AAa?$AAl?$AAD?$AAi?$AAf?$AAf?$AAu?$AAs?$AAe?$AAS?$AAp?$AAe?$AAc?$AAu?$AAl?$AAa?$AAr?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@ DB 'M'
	DB	00H, 'e', 00H, 't', 00H, 'a', 00H, 'l', 00H, 'D', 00H, 'i', 00H
	DB	'f', 00H, 'f', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'S', 00H, 'p'
	DB	00H, 'e', 00H, 'c', 00H, 'u', 00H, 'l', 00H, 'a', 00H, 'r', 00H
	DB	'.', 00H, 'd', 00H, 'd', 00H, 's', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CI@HJHILCKN@?$AAW?$AAa?$AAl?$AAl?$AAN?$AAo?$AAr?$AAm?$AAa?$AAl?$AAD?$AAe?$AAp?$AAt?$AAh?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1CI@HJHILCKN@?$AAW?$AAa?$AAl?$AAl?$AAN?$AAo?$AAr?$AAm?$AAa?$AAl?$AAD?$AAe?$AAp?$AAt?$AAh?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@ DB 'W'
	DB	00H, 'a', 00H, 'l', 00H, 'l', 00H, 'N', 00H, 'o', 00H, 'r', 00H
	DB	'm', 00H, 'a', 00H, 'l', 00H, 'D', 00H, 'e', 00H, 'p', 00H, 't'
	DB	00H, 'h', 00H, '.', 00H, 'd', 00H, 'd', 00H, 's', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DA@GABNFLNL@?$AAW?$AAa?$AAl?$AAl?$AAD?$AAi?$AAf?$AAf?$AAu?$AAs?$AAe?$AAS?$AAp?$AAe?$AAc?$AAu?$AAl?$AAa?$AAr?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1DA@GABNFLNL@?$AAW?$AAa?$AAl?$AAl?$AAD?$AAi?$AAf?$AAf?$AAu?$AAs?$AAe?$AAS?$AAp?$AAe?$AAc?$AAu?$AAl?$AAa?$AAr?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@ DB 'W'
	DB	00H, 'a', 00H, 'l', 00H, 'l', 00H, 'D', 00H, 'i', 00H, 'f', 00H
	DB	'f', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'S', 00H, 'p', 00H, 'e'
	DB	00H, 'c', 00H, 'u', 00H, 'l', 00H, 'a', 00H, 'r', 00H, '.', 00H
	DB	'd', 00H, 'd', 00H, 's', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1BC@MACPKMCG@?$AAM?$AAo?$AAo?$AAn?$AA?4?$AAj?$AAp?$AAg?$AA?$AA@
CONST	SEGMENT
??_C@_1BC@MACPKMCG@?$AAM?$AAo?$AAo?$AAn?$AA?4?$AAj?$AAp?$AAg?$AA?$AA@ DB 'M'
	DB	00H, 'o', 00H, 'o', 00H, 'n', 00H, '.', 00H, 'j', 00H, 'p', 00H
	DB	'g', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1DA@IEJEKIPL@?$AAW?$AAo?$AAo?$AAd?$AAD?$AAi?$AAf?$AAf?$AAu?$AAs?$AAe?$AAS?$AAp?$AAe?$AAc?$AAu?$AAl?$AAa?$AAr?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1DA@IEJEKIPL@?$AAW?$AAo?$AAo?$AAd?$AAD?$AAi?$AAf?$AAf?$AAu?$AAs?$AAe?$AAS?$AAp?$AAe?$AAc?$AAu?$AAl?$AAa?$AAr?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@ DB 'W'
	DB	00H, 'o', 00H, 'o', 00H, 'd', 00H, 'D', 00H, 'i', 00H, 'f', 00H
	DB	'f', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'S', 00H, 'p', 00H, 'e'
	DB	00H, 'c', 00H, 'u', 00H, 'l', 00H, 'a', 00H, 'r', 00H, '.', 00H
	DB	'd', 00H, 'd', 00H, 's', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1DC@LOBNDLGH@?$AAS?$AAt?$AAo?$AAn?$AAe?$AAD?$AAi?$AAf?$AAf?$AAu?$AAs?$AAe?$AAS?$AAp?$AAe?$AAc?$AAu?$AAl?$AAa?$AAr?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1DC@LOBNDLGH@?$AAS?$AAt?$AAo?$AAn?$AAe?$AAD?$AAi?$AAf?$AAf?$AAu?$AAs?$AAe?$AAS?$AAp?$AAe?$AAc?$AAu?$AAl?$AAa?$AAr?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@ DB 'S'
	DB	00H, 't', 00H, 'o', 00H, 'n', 00H, 'e', 00H, 'D', 00H, 'i', 00H
	DB	'f', 00H, 'f', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'S', 00H, 'p'
	DB	00H, 'e', 00H, 'c', 00H, 'u', 00H, 'l', 00H, 'a', 00H, 'r', 00H
	DB	'.', 00H, 'd', 00H, 'd', 00H, 's', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06FHFOAHML@system?$AA@
CONST	SEGMENT
??_C@_06FHFOAHML@system?$AA@ DB 'system', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_System_error_category@std@@6B@
CONST	SEGMENT
??_7_System_error_category@std@@6B@ DD FLAT:??_R4_System_error_category@std@@6B@ ; std::_System_error_category::`vftable'
	DD	FLAT:??_E_System_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_System_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
CONST	SEGMENT
??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ DB 'iostream stream error'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_08LLGCOLLL@iostream?$AA@
CONST	SEGMENT
??_C@_08LLGCOLLL@iostream?$AA@ DB 'iostream', 00H	; `string'
CONST	ENDS
;	COMDAT ??_7_Iostream_error_category@std@@6B@
CONST	SEGMENT
??_7_Iostream_error_category@std@@6B@ DD FLAT:??_R4_Iostream_error_category@std@@6B@ ; std::_Iostream_error_category::`vftable'
	DD	FLAT:??_E_Iostream_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Iostream_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
CONST	SEGMENT
??_C@_0O@BFJCFAAK@unknown?5error?$AA@ DB 'unknown error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07DCLBNMLN@generic?$AA@
CONST	SEGMENT
??_C@_07DCLBNMLN@generic?$AA@ DB 'generic', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_Generic_error_category@std@@6B@
CONST	SEGMENT
??_7_Generic_error_category@std@@6B@ DD FLAT:??_R4_Generic_error_category@std@@6B@ ; std::_Generic_error_category::`vftable'
	DD	FLAT:??_E_Generic_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Generic_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_7error_category@std@@6B@
CONST	SEGMENT
??_7error_category@std@@6B@ DD FLAT:??_R4error_category@std@@6B@ ; std::error_category::`vftable'
	DD	FLAT:??_Eerror_category@std@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_1IG@OPJAFKJH@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?5?$AA?3?$AA?5?$AAU?$AAn?$AAa?$AAb?$AAl?$AAe?$AA?5?$AAt?$AAo?$AA?5?$AAi?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AAi?$AAz?$AAe?$AA?5?$AAc?$AAr?$AAi@
CONST	SEGMENT
??_C@_1IG@OPJAFKJH@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?5?$AA?3?$AA?5?$AAU?$AAn?$AAa?$AAb?$AAl?$AAe?$AA?5?$AAt?$AAo?$AA?5?$AAi?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AAi?$AAz?$AAe?$AA?5?$AAc?$AAr?$AAi@ DB 'E'
	DB	00H, 'R', 00H, 'R', 00H, 'O', 00H, 'R', 00H, ' ', 00H, ':', 00H
	DB	' ', 00H, 'U', 00H, 'n', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e'
	DB	00H, ' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'i', 00H, 'n', 00H
	DB	'i', 00H, 't', 00H, 'i', 00H, 'a', 00H, 'l', 00H, 'i', 00H, 'z'
	DB	00H, 'e', 00H, ' ', 00H, 'c', 00H, 'r', 00H, 'i', 00H, 't', 00H
	DB	'i', 00H, 'c', 00H, 'a', 00H, 'l', 00H, ' ', 00H, 's', 00H, 'e'
	DB	00H, 'c', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, ' ', 00H
	DB	'i', 00H, 'n', 00H, ' ', 00H, 'A', 00H, 't', 00H, 'l', 00H, 'W'
	DB	00H, 'i', 00H, 'n', 00H, 'M', 00H, 'o', 00H, 'd', 00H, 'u', 00H
	DB	'l', 00H, 'e', 00H, 'I', 00H, 'n', 00H, 'i', 00H, 't', 00H, 0aH
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??AtlWinModuleInit@ATL@@YGJPAU_ATL_WIN_MODULE70@2@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??AtlWinModuleInit@ATL@@YGJPAU_ATL_WIN_MODULE70@2@@Z@4JA DD 020e1H ; `ATL::AtlWinModuleInit'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1IA@KEEOONGN@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?5?$AA?3?$AA?5?$AAU?$AAn?$AAa?$AAb?$AAl?$AAe?$AA?5?$AAt?$AAo?$AA?5?$AAi?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AAi?$AAz?$AAe?$AA?5?$AAc?$AAr?$AAi@
CONST	SEGMENT
??_C@_1IA@KEEOONGN@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?5?$AA?3?$AA?5?$AAU?$AAn?$AAa?$AAb?$AAl?$AAe?$AA?5?$AAt?$AAo?$AA?5?$AAi?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AAi?$AAz?$AAe?$AA?5?$AAc?$AAr?$AAi@ DB 'E'
	DB	00H, 'R', 00H, 'R', 00H, 'O', 00H, 'R', 00H, ' ', 00H, ':', 00H
	DB	' ', 00H, 'U', 00H, 'n', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e'
	DB	00H, ' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'i', 00H, 'n', 00H
	DB	'i', 00H, 't', 00H, 'i', 00H, 'a', 00H, 'l', 00H, 'i', 00H, 'z'
	DB	00H, 'e', 00H, ' ', 00H, 'c', 00H, 'r', 00H, 'i', 00H, 't', 00H
	DB	'i', 00H, 'c', 00H, 'a', 00H, 'l', 00H, ' ', 00H, 's', 00H, 'e'
	DB	00H, 'c', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, ' ', 00H
	DB	'i', 00H, 'n', 00H, ' ', 00H, 'C', 00H, 'A', 00H, 't', 00H, 'l'
	DB	00H, 'C', 00H, 'o', 00H, 'm', 00H, 'M', 00H, 'o', 00H, 'd', 00H
	DB	'u', 00H, 'l', 00H, 'e', 00H, 0aH, 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FA@ODGKGNGJ@c?3?2program?5files?5?$CIx86?$CJ?2microsoft@
CONST	SEGMENT
??_C@_0FA@ODGKGNGJ@c?3?2program?5files?5?$CIx86?$CJ?2microsoft@ DB 'c:\pr'
	DB	'ogram files (x86)\microsoft visual studio 12.0\vc\atlmfc\incl'
	DB	'ude\atlbase.h', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1KA@ELJIHIAD@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
CONST	SEGMENT
??_C@_1KA@ELJIHIAD@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 'm', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H
	DB	'v', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' '
	DB	00H, 's', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	' ', 00H, '1', 00H, '2', 00H, '.', 00H, '0', 00H, '\', 00H, 'v'
	DB	00H, 'c', 00H, '\', 00H, 'a', 00H, 't', 00H, 'l', 00H, 'm', 00H
	DB	'f', 00H, 'c', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l'
	DB	00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'a', 00H, 't', 00H
	DB	'l', 00H, 'b', 00H, 'a', 00H, 's', 00H, 'e', 00H, '.', 00H, 'h'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BM@GBBOFEAE@?$AA_?$AA_?$AAa?$AAt?$AAl?$AA_?$AAc?$AAo?$AAn?$AAd?$AAV?$AAa?$AAl?$AA?$AA@
CONST	SEGMENT
??_C@_1BM@GBBOFEAE@?$AA_?$AA_?$AAa?$AAt?$AAl?$AA_?$AAc?$AAo?$AAn?$AAd?$AAV?$AAa?$AAl?$AA?$AA@ DB '_'
	DB	00H, '_', 00H, 'a', 00H, 't', 00H, 'l', 00H, '_', 00H, 'c', 00H
	DB	'o', 00H, 'n', 00H, 'd', 00H, 'V', 00H, 'a', 00H, 'l', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVCAtlException@ATL@@@84
xdata$x	SEGMENT
__CT??_R0?AVCAtlException@ATL@@@84 DD 00H
	DD	FLAT:??_R0?AVCAtlException@ATL@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	04H
	DD	00H
xdata$x	ENDS
;	COMDAT ??_R0?AVCAtlException@ATL@@@8
data$r	SEGMENT
??_R0?AVCAtlException@ATL@@@8 DD FLAT:??_7type_info@@6B@ ; ATL::CAtlException `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCAtlException@ATL@@', 00H
data$r	ENDS
;	COMDAT __CTA1?AVCAtlException@ATL@@
xdata$x	SEGMENT
__CTA1?AVCAtlException@ATL@@ DD 01H
	DD	FLAT:__CT??_R0?AVCAtlException@ATL@@@84
xdata$x	ENDS
;	COMDAT __TI1?AVCAtlException@ATL@@
xdata$x	SEGMENT
__TI1?AVCAtlException@ATL@@ DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__CTA1?AVCAtlException@ATL@@
xdata$x	ENDS
;	COMDAT ??_C@_1CK@DFMKPFAK@?$AAA?$AAt?$AAl?$AAT?$AAh?$AAr?$AAo?$AAw?$AA?3?$AA?5?$AAh?$AAr?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?6?$AA?$AA@
CONST	SEGMENT
??_C@_1CK@DFMKPFAK@?$AAA?$AAt?$AAl?$AAT?$AAh?$AAr?$AAo?$AAw?$AA?3?$AA?5?$AAh?$AAr?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?6?$AA?$AA@ DB 'A'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'h', 00H, 'r', 00H, 'o', 00H
	DB	'w', 00H, ':', 00H, ' ', 00H, 'h', 00H, 'r', 00H, ' ', 00H, '='
	DB	00H, ' ', 00H, '0', 00H, 'x', 00H, '%', 00H, 'x', 00H, 0aH, 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0FC@OFGMOGKO@c?3?2program?5files?5?$CIx86?$CJ?2microsoft@
CONST	SEGMENT
??_C@_0FC@OFGMOGKO@c?3?2program?5files?5?$CIx86?$CJ?2microsoft@ DB 'c:\pr'
	DB	'ogram files (x86)\microsoft visual studio 12.0\vc\atlmfc\incl'
	DB	'ude\atlexcept.h', 00H			; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??AtlThrowImpl@ATL@@YGXJ@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??AtlThrowImpl@ATL@@YGXJ@Z@4JA DD 041H	; `ATL::AtlThrowImpl'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1KC@GEMPEEJK@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
CONST	SEGMENT
??_C@_1KC@GEMPEEJK@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 'm', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H
	DB	'v', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' '
	DB	00H, 's', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	' ', 00H, '1', 00H, '2', 00H, '.', 00H, '0', 00H, '\', 00H, 'v'
	DB	00H, 'c', 00H, '\', 00H, 'a', 00H, 't', 00H, 'l', 00H, 'm', 00H
	DB	'f', 00H, 'c', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l'
	DB	00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'a', 00H, 't', 00H
	DB	'l', 00H, 't', 00H, 'r', 00H, 'a', 00H, 'c', 00H, 'e', 00H, '.'
	DB	00H, 'h', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1EO@EBPPKGOM@?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAT?$AAo?$AAo?$AA?5?$AAm?$AAa?$AAn?$AAy?$AA?5?$AAc?$AAa?$AAt?$AAe?$AAg?$AAo?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAd?$AAe@
CONST	SEGMENT
??_C@_1EO@EBPPKGOM@?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAT?$AAo?$AAo?$AA?5?$AAm?$AAa?$AAn?$AAy?$AA?5?$AAc?$AAa?$AAt?$AAe?$AAg?$AAo?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAd?$AAe@ DB 'f'
	DB	00H, 'a', 00H, 'l', 00H, 's', 00H, 'e', 00H, ' ', 00H, '&', 00H
	DB	'&', 00H, ' ', 00H, '"', 00H, 'T', 00H, 'o', 00H, 'o', 00H, ' '
	DB	00H, 'm', 00H, 'a', 00H, 'n', 00H, 'y', 00H, ' ', 00H, 'c', 00H
	DB	'a', 00H, 't', 00H, 'e', 00H, 'g', 00H, 'o', 00H, 'r', 00H, 'i'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, 'd', 00H, 'e', 00H, 'f', 00H
	DB	'i', 00H, 'n', 00H, 'e', 00H, 'd', 00H, '"', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_15MAOEGKJF@?$AA?$CF?$AAS?$AA?$AA@
CONST	SEGMENT
??_C@_15MAOEGKJF@?$AA?$CF?$AAS?$AA?$AA@ DB '%', 00H, 'S', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_19LJDFFCJJ@?$AA?$CF?$AAs?$AA?$CF?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_19LJDFFCJJ@?$AA?$CF?$AAs?$AA?$CF?$AAs?$AA?$AA@ DB '%', 00H, 's', 00H
	DB	'%', 00H, 's', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@PGKOAACE@?$AA?$CF?$AAu?$AA?5?$AA?9?$AA?5?$AA?$AA@
CONST	SEGMENT
??_C@_1M@PGKOAACE@?$AA?$CF?$AAu?$AA?5?$AA?9?$AA?5?$AA?$AA@ DB '%', 00H, 'u'
	DB	00H, ' ', 00H, '-', 00H, ' ', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@PLLAHAGD@?$AA?$CF?$AAs?$AA?5?$AA?9?$AA?5?$AA?$AA@
CONST	SEGMENT
??_C@_1M@PLLAHAGD@?$AA?$CF?$AAs?$AA?5?$AA?9?$AA?5?$AA?$AA@ DB '%', 00H, 's'
	DB	00H, ' ', 00H, '-', 00H, ' ', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1BM@FHAEDBFK@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAI?$AAS?$AAA?$AAP?$AAI?$AA?$AA@
CONST	SEGMENT
??_C@_1BM@FHAEDBFK@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAI?$AAS?$AAA?$AAP?$AAI?$AA?$AA@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'I', 00H, 'S', 00H, 'A', 00H, 'P', 00H, 'I', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1BK@OPAPOCAL@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAS?$AAy?$AAn?$AAc?$AA?$AA@
CONST	SEGMENT
??_C@_1BK@OPAPOCAL@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAS?$AAy?$AAn?$AAc?$AA?$AA@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'S', 00H, 'y', 00H, 'n', 00H, 'c', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@DMMBNCFG@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAS?$AAe?$AAc?$AAu?$AAr?$AAi?$AAt?$AAy?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@DMMBNCFG@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAS?$AAe?$AAc?$AAu?$AAr?$AAi?$AAt?$AAy?$AA?$AA@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'S', 00H, 'e', 00H, 'c', 00H, 'u', 00H, 'r', 00H, 'i'
	DB	00H, 't', 00H, 'y', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1BK@DMHCKHHD@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAU?$AAt?$AAi?$AAl?$AA?$AA@
CONST	SEGMENT
??_C@_1BK@DMHCKHHD@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAU?$AAt?$AAi?$AAl?$AA?$AA@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'U', 00H, 't', 00H, 'i', 00H, 'l', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BI@OKDLCIEM@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAM?$AAa?$AAp?$AA?$AA@
CONST	SEGMENT
??_C@_1BI@OKDLCIEM@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAM?$AAa?$AAp?$AA?$AA@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'M', 00H, 'a', 00H, 'p', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BO@GMLILNDJ@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAS?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?$AA@
CONST	SEGMENT
??_C@_1BO@GMLILNDJ@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAS?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?$AA@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'S', 00H, 't', 00H, 'r', 00H, 'i', 00H, 'n', 00H, 'g'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1CA@PBPHANCD@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAS?$AAt?$AAe?$AAn?$AAc?$AAi?$AAl?$AA?$AA@
CONST	SEGMENT
??_C@_1CA@PBPHANCD@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAS?$AAt?$AAe?$AAn?$AAc?$AAi?$AAl?$AA?$AA@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'S', 00H, 't', 00H, 'e', 00H, 'n', 00H, 'c', 00H, 'i'
	DB	00H, 'l', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1BM@GIKLHLFD@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAC?$AAa?$AAc?$AAh?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1BM@GIKLHLFD@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAC?$AAa?$AAc?$AAh?$AAe?$AA?$AA@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'C', 00H, 'a', 00H, 'c', 00H, 'h', 00H, 'e', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1BK@NCJHOFCL@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAT?$AAi?$AAm?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1BK@NCJHOFCL@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAT?$AAi?$AAm?$AAe?$AA?$AA@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'T', 00H, 'i', 00H, 'm', 00H, 'e', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CE@IMMADNAP@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAE?$AAx?$AAc?$AAe?$AAp?$AAt?$AAi?$AAo?$AAn?$AA?$AA@
CONST	SEGMENT
??_C@_1CE@IMMADNAP@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAE?$AAx?$AAc?$AAe?$AAp?$AAt?$AAi?$AAo?$AAn?$AA?$AA@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'E', 00H, 'x', 00H, 'c', 00H, 'e', 00H, 'p', 00H, 't'
	DB	00H, 'i', 00H, 'o', 00H, 'n', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@KFEEMCDH@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?$AA@
CONST	SEGMENT
??_C@_1CG@KFEEMCDH@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?$AA@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'A', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'a'
	DB	00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CA@DMHPIODO@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAN?$AAo?$AAt?$AAI?$AAm?$AAp?$AAl?$AA?$AA@
CONST	SEGMENT
??_C@_1CA@DMHPIODO@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAN?$AAo?$AAt?$AAI?$AAm?$AAp?$AAl?$AA?$AA@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'N', 00H, 'o', 00H, 't', 00H, 'I', 00H, 'm', 00H, 'p'
	DB	00H, 'l', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1BO@EFPHNHHN@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAS?$AAn?$AAa?$AAp?$AAi?$AAn?$AA?$AA@
CONST	SEGMENT
??_C@_1BO@EFPHNHHN@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAS?$AAn?$AAa?$AAp?$AAi?$AAn?$AA?$AA@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'S', 00H, 'n', 00H, 'a', 00H, 'p', 00H, 'i', 00H, 'n'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@MNMMIOOI@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAD?$AAB?$AAP?$AAr?$AAo?$AAv?$AAi?$AAd?$AAe?$AAr?$AA?$AA@
CONST	SEGMENT
??_C@_1CG@MNMMIOOI@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAD?$AAB?$AAP?$AAr?$AAo?$AAv?$AAi?$AAd?$AAe?$AAr?$AA?$AA@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'D', 00H, 'B', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 'v'
	DB	00H, 'i', 00H, 'd', 00H, 'e', 00H, 'r', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@JNJJDOOH@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAD?$AAB?$AAC?$AAl?$AAi?$AAe?$AAn?$AAt?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@JNJJDOOH@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAD?$AAB?$AAC?$AAl?$AAi?$AAe?$AAn?$AAt?$AA?$AA@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'D', 00H, 'B', 00H, 'C', 00H, 'l', 00H, 'i', 00H, 'e'
	DB	00H, 'n', 00H, 't', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1CA@OMOMONMN@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAH?$AAo?$AAs?$AAt?$AAi?$AAn?$AAg?$AA?$AA@
CONST	SEGMENT
??_C@_1CA@OMOMONMN@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAH?$AAo?$AAs?$AAt?$AAi?$AAn?$AAg?$AA?$AA@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'H', 00H, 'o', 00H, 's', 00H, 't', 00H, 'i', 00H, 'n'
	DB	00H, 'g', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@IMNJGBED@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAC?$AAo?$AAn?$AAt?$AAr?$AAo?$AAl?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@IMNJGBED@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAC?$AAo?$AAn?$AAt?$AAr?$AAo?$AAl?$AAs?$AA?$AA@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'C', 00H, 'o', 00H, 'n', 00H, 't', 00H, 'r', 00H, 'o'
	DB	00H, 'l', 00H, 's', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1CE@NAJDPMNB@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AAi?$AAn?$AAg?$AA?$AA@
CONST	SEGMENT
??_C@_1CE@NAJDPMNB@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AAi?$AAn?$AAg?$AA?$AA@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'W', 00H, 'i', 00H, 'n', 00H, 'd', 00H, 'o', 00H, 'w'
	DB	00H, 'i', 00H, 'n', 00H, 'g', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@BNHGJFNK@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAR?$AAe?$AAf?$AAc?$AAo?$AAu?$AAn?$AAt?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@BNHGJFNK@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAR?$AAe?$AAf?$AAc?$AAo?$AAu?$AAn?$AAt?$AA?$AA@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'R', 00H, 'e', 00H, 'f', 00H, 'c', 00H, 'o', 00H, 'u'
	DB	00H, 'n', 00H, 't', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1CE@NIAEAIDK@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAR?$AAe?$AAg?$AAi?$AAs?$AAt?$AAr?$AAa?$AAr?$AA?$AA@
CONST	SEGMENT
??_C@_1CE@NIAEAIDK@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAR?$AAe?$AAg?$AAi?$AAs?$AAt?$AAr?$AAa?$AAr?$AA?$AA@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'R', 00H, 'e', 00H, 'g', 00H, 'i', 00H, 's', 00H, 't'
	DB	00H, 'r', 00H, 'a', 00H, 'r', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1BG@FPLJJEMF@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAQ?$AAI?$AA?$AA@
CONST	SEGMENT
??_C@_1BG@FPLJJEMF@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAQ?$AAI?$AA?$AA@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'Q', 00H, 'I', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1BI@MAFGHOEE@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAC?$AAO?$AAM?$AA?$AA@
CONST	SEGMENT
??_C@_1BI@MAFGHOEE@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAC?$AAO?$AAM?$AA?$AA@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'C', 00H, 'O', 00H, 'M', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CA@ONGMEOAB@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAG?$AAe?$AAn?$AAe?$AAr?$AAa?$AAl?$AA?$AA@
CONST	SEGMENT
??_C@_1CA@ONGMEOAB@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAG?$AAe?$AAn?$AAe?$AAr?$AAa?$AAl?$AA?$AA@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'G', 00H, 'e', 00H, 'n', 00H, 'e', 00H, 'r', 00H, 'a'
	DB	00H, 'l', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1KA@BPMCHGPL@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
CONST	SEGMENT
??_C@_1KA@BPMCHGPL@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 'm', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H
	DB	'v', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' '
	DB	00H, 's', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	' ', 00H, '1', 00H, '2', 00H, '.', 00H, '0', 00H, '\', 00H, 'v'
	DB	00H, 'c', 00H, '\', 00H, 'a', 00H, 't', 00H, 'l', 00H, 'm', 00H
	DB	'f', 00H, 'c', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l'
	DB	00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'a', 00H, 't', 00H
	DB	'l', 00H, 'c', 00H, 'o', 00H, 'n', 00H, 'v', 00H, '.', 00H, 'h'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1KC@BHGECGBJ@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
CONST	SEGMENT
??_C@_1KC@BHGECGBJ@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 'm', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H
	DB	'v', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' '
	DB	00H, 's', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	' ', 00H, '1', 00H, '2', 00H, '.', 00H, '0', 00H, '\', 00H, 'v'
	DB	00H, 'c', 00H, '\', 00H, 'a', 00H, 't', 00H, 'l', 00H, 'm', 00H
	DB	'f', 00H, 'c', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l'
	DB	00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'a', 00H, 't', 00H
	DB	'l', 00H, 'a', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, '.'
	DB	00H, 'h', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ DB '%', 00H, 's', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_13COJANIEC@?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_13COJANIEC@?$AA0?$AA?$AA@ DB '0', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
__ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0
__ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?InitScene@CScene@@QAE_NXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?InitScene@CScene@@QAE_NXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?InitScene@CScene@@QAE_NXZ$1
__ehfuncinfo$?InitScene@CScene@@QAE_NXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?InitScene@CScene@@QAE_NXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?CellStuff@CScene@@AAE_NXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CellStuff@CScene@@AAE_NXZ$0
__ehfuncinfo$?CellStuff@CScene@@AAE_NXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?CellStuff@CScene@@AAE_NXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?TestItems@CScene@@AAE_NXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?TestItems@CScene@@AAE_NXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?TestItems@CScene@@AAE_NXZ$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?TestItems@CScene@@AAE_NXZ$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?TestItems@CScene@@AAE_NXZ$3
__ehfuncinfo$?TestItems@CScene@@AAE_NXZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?TestItems@CScene@@AAE_NXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?SceneItems@CScene@@AAE_NXZ DD 019930522H
	DD	0eH
	DD	FLAT:__unwindtable$?SceneItems@CScene@@AAE_NXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?SceneItems@CScene@@AAE_NXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SceneItems@CScene@@AAE_NXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?SceneItems@CScene@@AAE_NXZ$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?SceneItems@CScene@@AAE_NXZ$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?SceneItems@CScene@@AAE_NXZ$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?SceneItems@CScene@@AAE_NXZ$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?SceneItems@CScene@@AAE_NXZ$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?SceneItems@CScene@@AAE_NXZ$6
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?SceneItems@CScene@@AAE_NXZ$7
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?SceneItems@CScene@@AAE_NXZ$8
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?SceneItems@CScene@@AAE_NXZ$9
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?SceneItems@CScene@@AAE_NXZ$10
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?SceneItems@CScene@@AAE_NXZ$11
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?SceneItems@CScene@@AAE_NXZ$12
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?SceneItems@CScene@@AAE_NXZ$13
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?BasicItems@CScene@@AAE_NXZ DD 019930522H
	DD	018H
	DD	FLAT:__unwindtable$?BasicItems@CScene@@AAE_NXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?BasicItems@CScene@@AAE_NXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$6
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$7
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$8
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$9
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$10
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$11
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$12
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$13
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$14
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$15
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$16
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$17
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$18
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$19
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$20
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$21
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$22
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$23
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0
__ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1CAtlWinModule@ATL@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CAtlWinModule@ATL@@QAE@XZ$0
__ehfuncinfo$??1CAtlWinModule@ATL@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1CAtlWinModule@ATL@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1CAtlComModule@ATL@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CAtlComModule@ATL@@QAE@XZ$0
__ehfuncinfo$??1CAtlComModule@ATL@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1CAtlComModule@ATL@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1_ATL_WIN_MODULE70@ATL@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1_ATL_WIN_MODULE70@ATL@@QAE@XZ$0
__ehfuncinfo$??1_ATL_WIN_MODULE70@ATL@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1_ATL_WIN_MODULE70@ATL@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0_ATL_WIN_MODULE70@ATL@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0_ATL_WIN_MODULE70@ATL@@QAE@XZ$0
__ehfuncinfo$??0_ATL_WIN_MODULE70@ATL@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0_ATL_WIN_MODULE70@ATL@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?TraceV@CTrace@ATL@@SAXPBDHIIPB_WPAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?TraceV@CTrace@ATL@@SAXPBDHIIPB_WPAD@Z$0
__ehfuncinfo$?TraceV@CTrace@ATL@@SAXPBDHIIPB_WPAD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?TraceV@CTrace@ATL@@SAXPBDHIIPB_WPAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
_atlTraceCOM$initializer$ DD FLAT:??__EatlTraceCOM@ATL@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
_atlTraceQI$initializer$ DD FLAT:??__EatlTraceQI@ATL@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
_atlTraceRegistrar$initializer$ DD FLAT:??__EatlTraceRegistrar@ATL@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
_atlTraceRefcount$initializer$ DD FLAT:??__EatlTraceRefcount@ATL@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
_atlTraceWindowing$initializer$ DD FLAT:??__EatlTraceWindowing@ATL@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
_atlTraceControls$initializer$ DD FLAT:??__EatlTraceControls@ATL@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
_atlTraceHosting$initializer$ DD FLAT:??__EatlTraceHosting@ATL@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
_atlTraceDBClient$initializer$ DD FLAT:??__EatlTraceDBClient@ATL@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
_atlTraceDBProvider$initializer$ DD FLAT:??__EatlTraceDBProvider@ATL@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
_atlTraceSnapin$initializer$ DD FLAT:??__EatlTraceSnapin@ATL@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
_atlTraceNotImpl$initializer$ DD FLAT:??__EatlTraceNotImpl@ATL@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
_atlTraceAllocation$initializer$ DD FLAT:??__EatlTraceAllocation@ATL@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
_atlTraceException$initializer$ DD FLAT:??__EatlTraceException@ATL@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
_atlTraceTime$initializer$ DD FLAT:??__EatlTraceTime@ATL@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
_atlTraceCache$initializer$ DD FLAT:??__EatlTraceCache@ATL@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
_atlTraceStencil$initializer$ DD FLAT:??__EatlTraceStencil@ATL@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
_atlTraceString$initializer$ DD FLAT:??__EatlTraceString@ATL@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
_atlTraceMap$initializer$ DD FLAT:??__EatlTraceMap@ATL@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
_atlTraceUtil$initializer$ DD FLAT:??__EatlTraceUtil@ATL@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
_atlTraceSecurity$initializer$ DD FLAT:??__EatlTraceSecurity@ATL@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
_atlTraceSync$initializer$ DD FLAT:??__EatlTraceSync@ATL@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
_atlTraceISAPI$initializer$ DD FLAT:??__EatlTraceISAPI@ATL@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
__AtlComModule$initializer$ DD FLAT:??__E_AtlComModule@ATL@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
__AtlWinModule$initializer$ DD FLAT:??__E_AtlWinModule@ATL@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Generic_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Iostream_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_System_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA DD FLAT:??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA DD FLAT:??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$numpunct@D@std@@2P6AXXZA DD FLAT:??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; std::numpunct<char>::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$numpunct@_W@std@@2P6AXXZA DD FLAT:??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ; std::numpunct<wchar_t>::id$initializer$
CRT$XCU	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z PROC	; std::allocator<char>::destroy<char *>, COMDAT
; _this$ = ecx

; 605  : 		void destroy(_Uty *_Ptr)

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 606  : 		{	// destroy object at _Ptr
; 607  : 		_Ptr->~_Uty();
; 608  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ENDP	; std::allocator<char>::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
tv73 = -244						; size = 4
$T2 = -236						; size = 4
$T3 = -224						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z PROC ; std::allocator<char>::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-244]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR _<_Args_0>$[ebp]
	push	ecx
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	mov	edx, DWORD PTR $T3[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR tv73[ebp], ecx
	jmp	SHORT $LN4@construct
$LN3@construct:
	mov	DWORD PTR tv73[ebp], 0
$LN4@construct:
	mov	edx, DWORD PTR tv73[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1

; 601  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 244				; 000000f4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0:
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-248]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ENDP ; std::allocator<char>::construct<char *,char * &>
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ
text$di	SEGMENT
??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<wchar_t>::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	0
	mov	ecx, OFFSET ?id@?$numpunct@_W@std@@2V0locale@2@A ; std::numpunct<wchar_t>::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<wchar_t>::id''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ
text$di	SEGMENT
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<char>::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	0
	mov	ecx, OFFSET ?id@?$numpunct@D@std@@2V0locale@2@A ; std::numpunct<char>::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<char>::id''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$di	SEGMENT
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	0
	mov	ecx, OFFSET ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$di	SEGMENT
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	0
	mov	ecx, OFFSET ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z PROC ; std::forward<std::_Container_proxy>, COMDAT

; 1504 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ENDP ; std::forward<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::destroy<char *>, COMDAT

; 728  : 		static void destroy(_Alloc& _Al, _Uty *_Ptr)

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 729  : 		{	// destroy object at _Ptr
; 730  : 		_Al.destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>

; 731  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>, COMDAT

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	push	eax
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>

; 724  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAD@std@@YAAAPADAAPAD@Z PROC		; std::forward<char * &>, COMDAT

; 1504 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$forward@AAPAD@std@@YAAAPADAAPAD@Z ENDP		; std::forward<char * &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object'', COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
	call	??1_System_error_category@std@@UAE@XZ
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
text$yd	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$di	SEGMENT
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_System_object'', COMDAT

; 611  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
	call	??0_System_error_category@std@@QAE@XZ	; std::_System_error_category::_System_error_category
	push	OFFSET ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
	call	_atexit
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_System_object''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object'', COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	call	??1_Iostream_error_category@std@@UAE@XZ
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
text$yd	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$di	SEGMENT
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object'', COMDAT

; 611  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	call	??0_Iostream_error_category@std@@QAE@XZ	; std::_Iostream_error_category::_Iostream_error_category
	push	OFFSET ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
	call	_atexit
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object'', COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
	call	??1_Generic_error_category@std@@UAE@XZ
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
text$yd	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$di	SEGMENT
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object'', COMDAT

; 611  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	push	OFFSET ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
	call	_atexit
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT
__Ptr$ = -8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@D@std@@YAPADIPAD@Z PROC			; std::_Allocate<char>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 23   : 	void *_Ptr = 0;

	mov	DWORD PTR __Ptr$[ebp], 0

; 24   : 
; 25   : 	if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN4@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)

	jmp	SHORT $LN3@Allocate
$LN4@Allocate:

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	DWORD PTR __Count$[ebp], -1
	ja	SHORT $LN1@Allocate
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR __Ptr$[ebp], eax
	cmp	DWORD PTR __Ptr$[ebp], 0
	jne	SHORT $LN3@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN3@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 32   : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@D@std@@YAPADIPAD@Z ENDP			; std::_Allocate<char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z
_TEXT	SEGMENT
__Ptr$ = -8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z PROC ; std::_Allocate<std::_Container_proxy>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 23   : 	void *_Ptr = 0;

	mov	DWORD PTR __Ptr$[ebp], 0

; 24   : 
; 25   : 	if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN4@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)

	jmp	SHORT $LN3@Allocate
$LN4@Allocate:

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	DWORD PTR __Count$[ebp], 536870911	; 1fffffffH
	ja	SHORT $LN1@Allocate
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 3
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR __Ptr$[ebp], eax
	cmp	DWORD PTR __Ptr$[ebp], 0
	jne	SHORT $LN3@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN3@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 32   : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z ENDP ; std::_Allocate<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z PROC ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>, COMDAT
; _this$ = ecx

; 605  : 		void destroy(_Uty *_Ptr)

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 606  : 		{	// destroy object at _Ptr
; 607  : 		_Ptr->~_Uty();
; 608  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ENDP ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
_TEXT	SEGMENT
tv74 = -244						; size = 4
$T2 = -236						; size = 4
$T3 = -224						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z PROC ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>, COMDAT
; _this$ = ecx

; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-244]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	8
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR _<_Args_0>$[ebp]
	push	ecx
	call	??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR $T3[ebp]
	mov	DWORD PTR tv74[ebp], edx
	jmp	SHORT $LN4@construct
$LN3@construct:
	mov	DWORD PTR tv74[ebp], 0
$LN4@construct:
	mov	eax, DWORD PTR tv74[ebp]
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1

; 601  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 244				; 000000f4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0:
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-248]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ENDP ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z PROC ; std::allocator<std::_Container_proxy>::allocate, COMDAT
; _this$ = ecx

; 577  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 578  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z ; std::_Allocate<std::_Container_proxy>
	add	esp, 8

; 579  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ENDP ; std::allocator<std::_Container_proxy>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z PROC ; std::allocator<std::_Container_proxy>::deallocate, COMDAT
; _this$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 573  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 574  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ENDP ; std::allocator<std::_Container_proxy>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ PROC	; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>, COMDAT
; _this$ = ecx

; 552  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ENDP	; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlconv.h
;	COMDAT ??$AtlConvAllocMemory@_W@ATL@@YAXPAPA_WHPA_WH@Z
_TEXT	SEGMENT
tv129 = -244						; size = 4
tv81 = -244						; size = 4
tv65 = -244						; size = 4
_ppReallocBuf$1 = -44					; size = 4
___atl_condVal$2 = -32					; size = 4
___atl_condVal$3 = -20					; size = 4
___atl_condVal$4 = -8					; size = 4
_ppBuff$ = 8						; size = 4
_nLength$ = 12						; size = 4
_pszFixedBuffer$ = 16					; size = 4
_nFixedBufferLength$ = 20				; size = 4
??$AtlConvAllocMemory@_W@ATL@@YAXPAPA_WHPA_WH@Z PROC	; ATL::AtlConvAllocMemory<wchar_t>, COMDAT

; 119  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 244				; 000000f4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-244]
	mov	ecx, 61					; 0000003dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
$LN29@AtlConvAll:

; 120  : 	ATLENSURE_THROW(ppBuff != NULL, E_INVALIDARG);

	cmp	DWORD PTR _ppBuff$[ebp], 0
	je	SHORT $LN32@AtlConvAll
	mov	DWORD PTR tv65[ebp], 1
	jmp	SHORT $LN33@AtlConvAll
$LN32@AtlConvAll:
	mov	DWORD PTR tv65[ebp], 0
$LN33@AtlConvAll:
	mov	eax, DWORD PTR tv65[ebp]
	mov	DWORD PTR ___atl_condVal$4[ebp], eax
$LN26@AtlConvAll:
	cmp	DWORD PTR ___atl_condVal$4[ebp], 0
	jne	SHORT $LN25@AtlConvAll
	push	OFFSET ??_C@_1BM@GBBOFEAE@?$AA_?$AA_?$AAa?$AAt?$AAl?$AA_?$AAc?$AAo?$AAn?$AAd?$AAV?$AAa?$AAl?$AA?$AA@
	push	OFFSET ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
	push	0
	push	120					; 00000078H
	push	OFFSET ??_C@_1KA@BPMCHGPL@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	2
	call	__CrtDbgReportW
	add	esp, 24					; 00000018H
	cmp	eax, 1
	jne	SHORT $LN25@AtlConvAll
	int	3
$LN25@AtlConvAll:
	xor	eax, eax
	jne	SHORT $LN26@AtlConvAll
	cmp	DWORD PTR ___atl_condVal$4[ebp], 0
	jne	SHORT $LN28@AtlConvAll
	push	-2147024809				; 80070057H
	call	?AtlThrowImpl@ATL@@YGXJ@Z		; ATL::AtlThrowImpl
$LN28@AtlConvAll:
	xor	eax, eax
	jne	SHORT $LN29@AtlConvAll
$LN22@AtlConvAll:

; 121  : 	ATLENSURE_THROW(nLength >= 0, E_INVALIDARG);

	cmp	DWORD PTR _nLength$[ebp], 0
	jl	SHORT $LN35@AtlConvAll
	mov	DWORD PTR tv81[ebp], 1
	jmp	SHORT $LN36@AtlConvAll
$LN35@AtlConvAll:
	mov	DWORD PTR tv81[ebp], 0
$LN36@AtlConvAll:
	mov	eax, DWORD PTR tv81[ebp]
	mov	DWORD PTR ___atl_condVal$3[ebp], eax
$LN19@AtlConvAll:
	cmp	DWORD PTR ___atl_condVal$3[ebp], 0
	jne	SHORT $LN18@AtlConvAll
	push	OFFSET ??_C@_1BM@GBBOFEAE@?$AA_?$AA_?$AAa?$AAt?$AAl?$AA_?$AAc?$AAo?$AAn?$AAd?$AAV?$AAa?$AAl?$AA?$AA@
	push	OFFSET ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
	push	0
	push	121					; 00000079H
	push	OFFSET ??_C@_1KA@BPMCHGPL@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	2
	call	__CrtDbgReportW
	add	esp, 24					; 00000018H
	cmp	eax, 1
	jne	SHORT $LN18@AtlConvAll
	int	3
$LN18@AtlConvAll:
	xor	eax, eax
	jne	SHORT $LN19@AtlConvAll
	cmp	DWORD PTR ___atl_condVal$3[ebp], 0
	jne	SHORT $LN21@AtlConvAll
	push	-2147024809				; 80070057H
	call	?AtlThrowImpl@ATL@@YGXJ@Z		; ATL::AtlThrowImpl
$LN21@AtlConvAll:
	xor	eax, eax
	jne	SHORT $LN22@AtlConvAll
$LN15@AtlConvAll:

; 122  : 	ATLENSURE_THROW(pszFixedBuffer != NULL, E_INVALIDARG);

	cmp	DWORD PTR _pszFixedBuffer$[ebp], 0
	je	SHORT $LN38@AtlConvAll
	mov	DWORD PTR tv129[ebp], 1
	jmp	SHORT $LN39@AtlConvAll
$LN38@AtlConvAll:
	mov	DWORD PTR tv129[ebp], 0
$LN39@AtlConvAll:
	mov	eax, DWORD PTR tv129[ebp]
	mov	DWORD PTR ___atl_condVal$2[ebp], eax
$LN12@AtlConvAll:
	cmp	DWORD PTR ___atl_condVal$2[ebp], 0
	jne	SHORT $LN11@AtlConvAll
	push	OFFSET ??_C@_1BM@GBBOFEAE@?$AA_?$AA_?$AAa?$AAt?$AAl?$AA_?$AAc?$AAo?$AAn?$AAd?$AAV?$AAa?$AAl?$AA?$AA@
	push	OFFSET ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
	push	0
	push	122					; 0000007aH
	push	OFFSET ??_C@_1KA@BPMCHGPL@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	2
	call	__CrtDbgReportW
	add	esp, 24					; 00000018H
	cmp	eax, 1
	jne	SHORT $LN11@AtlConvAll
	int	3
$LN11@AtlConvAll:
	xor	eax, eax
	jne	SHORT $LN12@AtlConvAll
	cmp	DWORD PTR ___atl_condVal$2[ebp], 0
	jne	SHORT $LN14@AtlConvAll
	push	-2147024809				; 80070057H
	call	?AtlThrowImpl@ATL@@YGXJ@Z		; ATL::AtlThrowImpl
$LN14@AtlConvAll:
	xor	eax, eax
	jne	SHORT $LN15@AtlConvAll

; 123  : 
; 124  : 	//if buffer malloced, try to realloc.
; 125  : 	if (*ppBuff != pszFixedBuffer)

	mov	eax, DWORD PTR _ppBuff$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _pszFixedBuffer$[ebp]
	je	SHORT $LN8@AtlConvAll

; 126  : 	{
; 127  : 		if( nLength > nFixedBufferLength )

	mov	eax, DWORD PTR _nLength$[ebp]
	cmp	eax, DWORD PTR _nFixedBufferLength$[ebp]
	jle	SHORT $LN7@AtlConvAll

; 128  : 		{
; 129  : 			_CharType* ppReallocBuf = static_cast< _CharType* >( _recalloc(*ppBuff, nLength,sizeof( _CharType ) ) );

	push	2
	mov	eax, DWORD PTR _nLength$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBuff$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	__recalloc
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ppReallocBuf$1[ebp], eax

; 130  : 			if (ppReallocBuf == NULL) 

	cmp	DWORD PTR _ppReallocBuf$1[ebp], 0
	jne	SHORT $LN6@AtlConvAll

; 131  : 			{
; 132  : 				AtlThrow( E_OUTOFMEMORY );

	push	-2147024882				; 8007000eH
	call	?AtlThrowImpl@ATL@@YGXJ@Z		; ATL::AtlThrowImpl
$LN6@AtlConvAll:

; 133  : 			}
; 134  : 			*ppBuff = ppReallocBuf;

	mov	eax, DWORD PTR _ppBuff$[ebp]
	mov	ecx, DWORD PTR _ppReallocBuf$1[ebp]
	mov	DWORD PTR [eax], ecx

; 135  : 		} else

	jmp	SHORT $LN5@AtlConvAll
$LN7@AtlConvAll:

; 136  : 		{
; 137  : 			free(*ppBuff);

	mov	eax, DWORD PTR _ppBuff$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_free
	add	esp, 4

; 138  : 			*ppBuff=pszFixedBuffer;

	mov	eax, DWORD PTR _ppBuff$[ebp]
	mov	ecx, DWORD PTR _pszFixedBuffer$[ebp]
	mov	DWORD PTR [eax], ecx
$LN5@AtlConvAll:

; 139  : 		}
; 140  : 
; 141  : 	} else //Buffer is not currently malloced.

	jmp	SHORT $LN4@AtlConvAll
$LN8@AtlConvAll:

; 142  : 	{
; 143  : 		if( nLength > nFixedBufferLength )

	mov	eax, DWORD PTR _nLength$[ebp]
	cmp	eax, DWORD PTR _nFixedBufferLength$[ebp]
	jle	SHORT $LN3@AtlConvAll

; 144  : 		{
; 145  : 			*ppBuff = static_cast< _CharType* >( calloc(nLength,sizeof( _CharType ) ) );

	push	2
	mov	eax, DWORD PTR _nLength$[ebp]
	push	eax
	call	_calloc
	add	esp, 8
	mov	ecx, DWORD PTR _ppBuff$[ebp]
	mov	DWORD PTR [ecx], eax

; 146  : 		} else

	jmp	SHORT $LN4@AtlConvAll
$LN3@AtlConvAll:

; 147  : 		{			
; 148  : 			*ppBuff=pszFixedBuffer;

	mov	eax, DWORD PTR _ppBuff$[ebp]
	mov	ecx, DWORD PTR _pszFixedBuffer$[ebp]
	mov	DWORD PTR [eax], ecx
$LN4@AtlConvAll:

; 149  : 		}
; 150  : 	}
; 151  : 
; 152  : 	if (*ppBuff == NULL)

	mov	eax, DWORD PTR _ppBuff$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN31@AtlConvAll

; 153  : 	{
; 154  : 		AtlThrow( E_OUTOFMEMORY );

	push	-2147024882				; 8007000eH
	call	?AtlThrowImpl@ATL@@YGXJ@Z		; ATL::AtlThrowImpl
$LN31@AtlConvAll:

; 155  : 	}
; 156  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 244				; 000000f4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$AtlConvAllocMemory@_W@ATL@@YAXPAPA_WHPA_WH@Z ENDP	; ATL::AtlConvAllocMemory<wchar_t>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
;	COMDAT ??$addressof@D@std@@YAPADAAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@D@std@@YAPADAAD@Z PROC			; std::addressof<char>, COMDAT

; 92   : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 93   : 	return (reinterpret_cast<_Ty *>(
; 94   : 		(&const_cast<char&>(
; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR __Val$[ebp]

; 96   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$addressof@D@std@@YAPADAAD@Z ENDP			; std::addressof<char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>, COMDAT
; _this$ = ecx

; 877  : 		void destroy(_Ty *_Ptr)

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 878  : 		{	// destroy object at _Ptr
; 879  : 		_Mytraits::destroy(*this, _Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
	add	esp, 8

; 880  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	push	eax
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
	add	esp, 12					; 0000000cH

; 873  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlconv.h
;	COMDAT ??$AtlConvFreeMemory@_W@ATL@@YAXPA_W0H@Z
_TEXT	SEGMENT
_pBuff$ = 8						; size = 4
_pszFixedBuffer$ = 12					; size = 4
_nFixedBufferLength$ = 16				; size = 4
??$AtlConvFreeMemory@_W@ATL@@YAXPA_W0H@Z PROC		; ATL::AtlConvFreeMemory<wchar_t>, COMDAT

; 163  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 164  : 	(nFixedBufferLength);
; 165  : 	if( pBuff != pszFixedBuffer )

	mov	eax, DWORD PTR _pBuff$[ebp]
	cmp	eax, DWORD PTR _pszFixedBuffer$[ebp]
	je	SHORT $LN2@AtlConvFre

; 166  : 	{
; 167  : 		free( pBuff );

	mov	eax, DWORD PTR _pBuff$[ebp]
	push	eax
	call	_free
	add	esp, 4

; 168  : 	} 	
; 169  : #ifdef _DEBUG
; 170  : 	else

	jmp	SHORT $LN3@AtlConvFre
$LN2@AtlConvFre:

; 171  : 	{		
; 172  : 		memset(pszFixedBuffer,ATLCONV_DEADLAND_FILL,nFixedBufferLength*sizeof(_CharType));

	mov	eax, DWORD PTR _nFixedBufferLength$[ebp]
	shl	eax, 1
	push	eax
	push	254					; 000000feH
	mov	ecx, DWORD PTR _pszFixedBuffer$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH
$LN3@AtlConvFre:

; 173  : 	}
; 174  : #endif
; 175  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$AtlConvFreeMemory@_W@ATL@@YAXPA_W0H@Z ENDP		; ATL::AtlConvFreeMemory<wchar_t>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlconv.h
;	COMDAT ?Init@?$CA2WEX@$0IA@@ATL@@AAEXPBDI@Z
_TEXT	SEGMENT
tv142 = -244						; size = 4
tv84 = -244						; size = 4
_bFailed$ = -44						; size = 4
_nLengthW$ = -32					; size = 4
_nLengthA$ = -20					; size = 4
_this$ = -8						; size = 4
_psz$ = 8						; size = 4
_nCodePage$ = 12					; size = 4
?Init@?$CA2WEX@$0IA@@ATL@@AAEXPBDI@Z PROC		; ATL::CA2WEX<128>::Init, COMDAT
; _this$ = ecx

; 376  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 244				; 000000f4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-244]
	mov	ecx, 61					; 0000003dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 377  : 		if (psz == NULL)

	cmp	DWORD PTR _psz$[ebp], 0
	jne	SHORT $LN4@Init

; 378  : 		{
; 379  : 			m_psz = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 380  : 			return;

	jmp	$LN6@Init
$LN4@Init:

; 381  : 		}
; 382  : 		int nLengthA = static_cast<int>(strlen( psz ))+1;

	mov	eax, DWORD PTR _psz$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	add	eax, 1
	mov	DWORD PTR _nLengthA$[ebp], eax

; 383  : 		int nLengthW = nLengthA;

	mov	eax, DWORD PTR _nLengthA$[ebp]
	mov	DWORD PTR _nLengthW$[ebp], eax

; 384  : 
; 385  : 		AtlConvAllocMemory(&m_psz,nLengthW,m_szBuffer,t_nBufferLength);

	push	128					; 00000080H
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _nLengthW$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$AtlConvAllocMemory@_W@ATL@@YAXPAPA_WHPA_WH@Z ; ATL::AtlConvAllocMemory<wchar_t>
	add	esp, 16					; 00000010H

; 386  : 
; 387  : 		BOOL bFailed=(0 == ::MultiByteToWideChar( nCodePage, 0, psz, nLengthA, m_psz, nLengthW ) );

	mov	esi, esp
	mov	eax, DWORD PTR _nLengthW$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _nLengthA$[ebp]
	push	eax
	mov	ecx, DWORD PTR _psz$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _nCodePage$[ebp]
	push	edx
	call	DWORD PTR __imp__MultiByteToWideChar@24
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $LN7@Init
	mov	DWORD PTR tv84[ebp], 1
	jmp	SHORT $LN8@Init
$LN7@Init:
	mov	DWORD PTR tv84[ebp], 0
$LN8@Init:
	mov	eax, DWORD PTR tv84[ebp]
	mov	DWORD PTR _bFailed$[ebp], eax

; 388  : 		if (bFailed)

	cmp	DWORD PTR _bFailed$[ebp], 0
	je	$LN3@Init

; 389  : 		{
; 390  : 			if (GetLastError()==ERROR_INSUFFICIENT_BUFFER)

	mov	esi, esp
	call	DWORD PTR __imp__GetLastError@0
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 122				; 0000007aH
	jne	$LN3@Init

; 391  : 			{
; 392  : 				nLengthW = ::MultiByteToWideChar( nCodePage, 0, psz, nLengthA, NULL, 0);

	mov	esi, esp
	push	0
	push	0
	mov	eax, DWORD PTR _nLengthA$[ebp]
	push	eax
	mov	ecx, DWORD PTR _psz$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _nCodePage$[ebp]
	push	edx
	call	DWORD PTR __imp__MultiByteToWideChar@24
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _nLengthW$[ebp], eax

; 393  : ATLPREFAST_SUPPRESS(6102)                
; 394  : 				AtlConvAllocMemory(&m_psz,nLengthW,m_szBuffer,t_nBufferLength);

	push	128					; 00000080H
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _nLengthW$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$AtlConvAllocMemory@_W@ATL@@YAXPAPA_WHPA_WH@Z ; ATL::AtlConvAllocMemory<wchar_t>
	add	esp, 16					; 00000010H

; 395  : ATLPREFAST_UNSUPPRESS()
; 396  : 				bFailed=(0 == ::MultiByteToWideChar( nCodePage, 0, psz, nLengthA, m_psz, nLengthW ) );

	mov	esi, esp
	mov	eax, DWORD PTR _nLengthW$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _nLengthA$[ebp]
	push	eax
	mov	ecx, DWORD PTR _psz$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _nCodePage$[ebp]
	push	edx
	call	DWORD PTR __imp__MultiByteToWideChar@24
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $LN9@Init
	mov	DWORD PTR tv142[ebp], 1
	jmp	SHORT $LN10@Init
$LN9@Init:
	mov	DWORD PTR tv142[ebp], 0
$LN10@Init:
	mov	eax, DWORD PTR tv142[ebp]
	mov	DWORD PTR _bFailed$[ebp], eax
$LN3@Init:

; 397  : 			}			
; 398  : 		}
; 399  : 		if (bFailed)

	cmp	DWORD PTR _bFailed$[ebp], 0
	je	SHORT $LN6@Init

; 400  : 		{
; 401  : 			AtlThrowLastWin32();

	call	?AtlThrowLastWin32@ATL@@YGXXZ		; ATL::AtlThrowLastWin32
$LN6@Init:

; 402  : 		}		
; 403  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 244				; 000000f4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?Init@?$CA2WEX@$0IA@@ATL@@AAEXPBDI@Z ENDP		; ATL::CA2WEX<128>::Init
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlconv.h
;	COMDAT ??B?$CA2WEX@$0IA@@ATL@@QBEPA_WXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??B?$CA2WEX@$0IA@@ATL@@QBEPA_WXZ PROC			; ATL::CA2WEX<128>::operator wchar_t *, COMDAT
; _this$ = ecx

; 368  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 369  : 		return( m_psz );

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 370  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??B?$CA2WEX@$0IA@@ATL@@QBEPA_WXZ ENDP			; ATL::CA2WEX<128>::operator wchar_t *
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlconv.h
;	COMDAT ??1?$CA2WEX@$0IA@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$CA2WEX@$0IA@@ATL@@QAE@XZ PROC			; ATL::CA2WEX<128>::~CA2WEX<128>, COMDAT
; _this$ = ecx

; 363  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 364  : 		AtlConvFreeMemory(m_psz,m_szBuffer,t_nBufferLength);

	push	128					; 00000080H
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$AtlConvFreeMemory@_W@ATL@@YAXPA_W0H@Z ; ATL::AtlConvFreeMemory<wchar_t>
	add	esp, 12					; 0000000cH

; 365  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CA2WEX@$0IA@@ATL@@QAE@XZ ENDP			; ATL::CA2WEX<128>::~CA2WEX<128>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlconv.h
;	COMDAT ??0?$CA2WEX@$0IA@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_psz$ = 8						; size = 4
??0?$CA2WEX@$0IA@@ATL@@QAE@PBD@Z PROC			; ATL::CA2WEX<128>::CA2WEX<128>, COMDAT
; _this$ = ecx

; 352  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 353  : 		Init( psz, _AtlGetConversionACP() );

	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	push	eax
	mov	eax, DWORD PTR _psz$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Init@?$CA2WEX@$0IA@@ATL@@AAEXPBDI@Z	; ATL::CA2WEX<128>::Init

; 354  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CA2WEX@$0IA@@ATL@@QAE@PBD@Z ENDP			; ATL::CA2WEX<128>::CA2WEX<128>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\string.h
;	COMDAT ??$strcat_s@$0GE@@@YAHAAY0GE@DPBD@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Source$ = 12						; size = 4
??$strcat_s@$0GE@@@YAHAAY0GE@DPBD@Z PROC		; strcat_s<100>, COMDAT

; 116  : __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(errno_t, strcat_s, char, _Dest, _In_z_ const char *, _Source)

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR __Source$[ebp]
	push	eax
	push	100					; 00000064H
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	_strcat_s
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$strcat_s@$0GE@@@YAHAAY0GE@DPBD@Z ENDP		; strcat_s<100>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\stdlib.h
;	COMDAT ??$_itoa_s@$05@@YAHHAAY05DH@Z
_TEXT	SEGMENT
__Value$ = 8						; size = 4
__Dest$ = 12						; size = 4
__Radix$ = 16						; size = 4
??$_itoa_s@$05@@YAHHAAY05DH@Z PROC			; _itoa_s<6>, COMDAT

; 480  : __DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_1(errno_t, _itoa_s, _In_ int, _Value, char, _Dest, _In_ int, _Radix)

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR __Radix$[ebp]
	push	eax
	push	6
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Value$[ebp]
	push	edx
	call	__itoa_s
	add	esp, 16					; 00000010H
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_itoa_s@$05@@YAHHAAY05DH@Z ENDP			; _itoa_s<6>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\string.h
;	COMDAT ??$strcpy_s@$0GE@@@YAHAAY0GE@DPBD@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Source$ = 12						; size = 4
??$strcpy_s@$0GE@@@YAHAAY0GE@DPBD@Z PROC		; strcpy_s<100>, COMDAT

; 111  : __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(errno_t, strcpy_s, _Post_z_ char, _Dest, _In_z_ const char *, _Source)

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR __Source$[ebp]
	push	eax
	push	100					; 00000064H
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	_strcpy_s
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$strcpy_s@$0GE@@@YAHAAY0GE@DPBD@Z ENDP		; strcpy_s<100>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\game-of-life\scene.cpp
;	COMDAT ?InitWindow@CScene@@QAE_NPAUHINSTANCE__@@H@Z
_TEXT	SEGMENT
_rc$ = -92						; size = 16
_wcex$ = -68						; size = 48
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_hInstance$ = 8						; size = 4
_nCmdShow$ = 12						; size = 4
?InitWindow@CScene@@QAE_NPAUHINSTANCE__@@H@Z PROC	; CScene::InitWindow, COMDAT
; _this$ = ecx

; 426  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 288				; 00000120H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-288]
	mov	ecx, 72					; 00000048H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 427  : 	// Register class
; 428  : 	WNDCLASSEX wcex;
; 429  : 	wcex.cbSize = sizeof( WNDCLASSEX );

	mov	DWORD PTR _wcex$[ebp], 48		; 00000030H

; 430  : 	wcex.style = CS_HREDRAW | CS_VREDRAW;

	mov	DWORD PTR _wcex$[ebp+4], 3

; 431  : 	wcex.lpfnWndProc = CScene::WndProc;

	mov	DWORD PTR _wcex$[ebp+8], OFFSET ?WndProc@CScene@@CGJPAUHWND__@@IIJ@Z ; CScene::WndProc

; 432  : 	wcex.cbClsExtra = 0;

	mov	DWORD PTR _wcex$[ebp+12], 0

; 433  : 	wcex.cbWndExtra = 0;

	mov	DWORD PTR _wcex$[ebp+16], 0

; 434  : 	wcex.hInstance = hInstance;

	mov	eax, DWORD PTR _hInstance$[ebp]
	mov	DWORD PTR _wcex$[ebp+20], eax

; 435  : 	wcex.hIcon = LoadIcon( hInstance, ( LPCTSTR )IDI_TUTORIAL1 );

	mov	esi, esp
	push	107					; 0000006bH
	mov	eax, DWORD PTR _hInstance$[ebp]
	push	eax
	call	DWORD PTR __imp__LoadIconW@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _wcex$[ebp+24], eax

; 436  : 	wcex.hCursor = LoadCursor( NULL, IDC_ARROW );

	mov	esi, esp
	push	32512					; 00007f00H
	push	0
	call	DWORD PTR __imp__LoadCursorW@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _wcex$[ebp+28], eax

; 437  : 	wcex.hbrBackground = ( HBRUSH )( COLOR_WINDOW + 1 );

	mov	DWORD PTR _wcex$[ebp+32], 6

; 438  : 	wcex.lpszMenuName = NULL;

	mov	DWORD PTR _wcex$[ebp+36], 0

; 439  : 	wcex.lpszClassName = L"TutorialWindowClass";

	mov	DWORD PTR _wcex$[ebp+40], OFFSET ??_C@_1CI@OKMLABGO@?$AAT?$AAu?$AAt?$AAo?$AAr?$AAi?$AAa?$AAl?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AAC?$AAl?$AAa?$AAs?$AAs?$AA?$AA@

; 440  : 	wcex.hIconSm = LoadIcon( wcex.hInstance, ( LPCTSTR )IDI_TUTORIAL1 );

	mov	esi, esp
	push	107					; 0000006bH
	mov	eax, DWORD PTR _wcex$[ebp+20]
	push	eax
	call	DWORD PTR __imp__LoadIconW@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _wcex$[ebp+44], eax

; 441  : 	if( !RegisterClassEx( &wcex ) )	return false;

	mov	esi, esp
	lea	eax, DWORD PTR _wcex$[ebp]
	push	eax
	call	DWORD PTR __imp__RegisterClassExW@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	movzx	ecx, ax
	test	ecx, ecx
	jne	SHORT $LN2@InitWindow
	xor	al, al
	jmp	$LN3@InitWindow
$LN2@InitWindow:

; 442  : 
; 443  : 	// Create window
; 444  : 	HInst = hInstance;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _hInstance$[ebp]
	mov	DWORD PTR [eax+24480], ecx

; 445  : 	RECT rc = { 0, 0, 1920, 960 };

	mov	DWORD PTR _rc$[ebp], 0
	mov	DWORD PTR _rc$[ebp+4], 0
	mov	DWORD PTR _rc$[ebp+8], 1920		; 00000780H
	mov	DWORD PTR _rc$[ebp+12], 960		; 000003c0H

; 446  : 	AdjustWindowRect( &rc, WS_OVERLAPPEDWINDOW, FALSE );

	mov	esi, esp
	push	0
	push	13565952				; 00cf0000H
	lea	eax, DWORD PTR _rc$[ebp]
	push	eax
	call	DWORD PTR __imp__AdjustWindowRect@12
	cmp	esi, esp
	call	__RTC_CheckEsp

; 447  : 	HWnd = CreateWindow( L"TutorialWindowClass", L"CO2409 - Graphics Assignment - Shaders", WS_OVERLAPPEDWINDOW,
; 448  : 	                     CW_USEDEFAULT, CW_USEDEFAULT, rc.right - rc.left, rc.bottom - rc.top, NULL, NULL, hInstance, NULL );

	mov	esi, esp
	push	0
	mov	eax, DWORD PTR _hInstance$[ebp]
	push	eax
	push	0
	push	0
	mov	ecx, DWORD PTR _rc$[ebp+12]
	sub	ecx, DWORD PTR _rc$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _rc$[ebp+8]
	sub	edx, DWORD PTR _rc$[ebp]
	push	edx
	push	-2147483648				; 80000000H
	push	-2147483648				; 80000000H
	push	13565952				; 00cf0000H
	push	OFFSET ??_C@_1EO@IKJJOGJD@?$AAC?$AAO?$AA2?$AA4?$AA0?$AA9?$AA?5?$AA?9?$AA?5?$AAG?$AAr?$AAa?$AAp?$AAh?$AAi?$AAc?$AAs?$AA?5?$AAA?$AAs?$AAs?$AAi?$AAg?$AAn?$AAm?$AAe?$AAn?$AAt?$AA?5?$AA?9?$AA?5?$AAS@
	push	OFFSET ??_C@_1CI@OKMLABGO@?$AAT?$AAu?$AAt?$AAo?$AAr?$AAi?$AAa?$AAl?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AAC?$AAl?$AAa?$AAs?$AAs?$AA?$AA@
	push	0
	call	DWORD PTR __imp__CreateWindowExW@48
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24484], eax

; 449  : 	if( !HWnd )	return false;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24484], 0
	jne	SHORT $LN1@InitWindow
	xor	al, al
	jmp	SHORT $LN3@InitWindow
$LN1@InitWindow:

; 450  : 
; 451  : 	ShowWindow( HWnd, nCmdShow );

	mov	esi, esp
	mov	eax, DWORD PTR _nCmdShow$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24484]
	push	edx
	call	DWORD PTR __imp__ShowWindow@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 452  : 
; 453  : 	return true;

	mov	al, 1
$LN3@InitWindow:

; 454  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN8@InitWindow
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 288				; 00000120H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	2
$LN8@InitWindow:
	DD	2
	DD	$LN7@InitWindow
$LN7@InitWindow:
	DD	-68					; ffffffbcH
	DD	48					; 00000030H
	DD	$LN5@InitWindow
	DD	-92					; ffffffa4H
	DD	16					; 00000010H
	DD	$LN6@InitWindow
$LN6@InitWindow:
	DB	114					; 00000072H
	DB	99					; 00000063H
	DB	0
$LN5@InitWindow:
	DB	119					; 00000077H
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	120					; 00000078H
	DB	0
?InitWindow@CScene@@QAE_NPAUHINSTANCE__@@H@Z ENDP	; CScene::InitWindow
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\game-of-life\scene.cpp
;	COMDAT ?RenderMirrors@CScene@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?RenderMirrors@CScene@@QAEXXZ PROC			; CScene::RenderMirrors, COMDAT
; _this$ = ecx

; 360  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 361  : 	
; 362  : 	//*******************************************************************************************************
; 363  : 	// First set the stencil value for all mirror pixels to 1 and clear the mirror to a fixed colour and 
; 364  : 	// set its depth-buffer values to maximum (so we can render "inside" the mirror)
; 365  : 	/*
; 366  : 	D3DXMATRIXA16 mirrorMatrix = mpObjects[0]->GetModel()->GetWorldMatrix();
; 367  : 	WorldMatrixVar->SetMatrix( (float*)mirrorMatrix );
; 368  : 	ModelColourVar->SetRawValue( mpObjects[0]->GetColourV(), 0, 12 );
; 369  : 	mpObjects[0]->Render();
; 370  : 
; 371  : 	//*******************************************************************************************************
; 372  : 	// Next reflect the camera in the mirror
; 373  : 
; 374  : 	// Some mathematics to get as reflected version of the camera - using DirectX helper functions mostly
; 375  : 
; 376  : 	// Create a plane for the mirror
; 377  : 	D3DXPLANE mirrorPlane;
; 378  : 	D3DXVECTOR3 mirrorPoint  = D3DXVECTOR3( mirrorMatrix(3,0), mirrorMatrix(3,1), mirrorMatrix(3,2) );
; 379  : 	D3DXVECTOR3 mirrorNormal = D3DXVECTOR3( mirrorMatrix(2,0), mirrorMatrix(2,1), mirrorMatrix(2,2) );
; 380  : 	D3DXPlaneFromPointNormal( &mirrorPlane, &mirrorPoint, &mirrorNormal );
; 381  : 	
; 382  : 	// Reflect the camera's view matrix in the mirror plane
; 383  : 	D3DXMATRIXA16 reflectMatrix;
; 384  : 	D3DXMatrixReflect( &reflectMatrix, &mirrorPlane );
; 385  : 	D3DXMATRIXA16 reflectViewMatrix = reflectMatrix * Camera->GetViewMatrix();
; 386  : 
; 387  : 	// Reflect the camera's position in the mirror plane
; 388  : 	D3DXVECTOR3 cameraPos = Camera->GetPosition();
; 389  : 	D3DXVECTOR4 reflectCameraPos4; // Initially generate a 4 element vector
; 390  : 	D3DXVec3Transform( &reflectCameraPos4, &cameraPos, &reflectMatrix );
; 391  : 	D3DXVECTOR3 reflectCameraPos = D3DXVECTOR3( (float*)reflectCameraPos4 ); // Drop 4th element
; 392  : 
; 393  : 
; 394  : 	//*******************************************************************************************************
; 395  : 	// Render all the models "inside" the mirror
; 396  : 
; 397  : 	// Set the reflected camera data in the shaders
; 398  : 	ViewMatrixVar->SetMatrix( (float*)&reflectViewMatrix );
; 399  : 	dxCameraPos->SetRawValue( reflectCameraPos, 0, 12 );
; 400  : 	ClipPlaneVar->SetRawValue( mirrorPlane, 0, 16 );
; 401  : 
; 402  : 	// Need to use slightly different techniques to avoid mirror rendering being "inside out"
; 403  : 	
; 404  : 	DrawAllObjects(true);
; 405  : 
; 406  : 	// Restore main camera data in the shaders
; 407  : 	ViewMatrixVar->SetMatrix( (float*)&Camera->GetViewMatrix() );
; 408  : 	dxCameraPos->SetRawValue( Camera->GetPosition(), 0, 12 );
; 409  : 	ClipPlaneVar->SetRawValue( D3DXVECTOR4(0,0,0,0), 0, 16 );
; 410  : 
; 411  : 
; 412  : 	//*******************************************************************************************************
; 413  : 	// Finally draw a "surface" for the mirror - a transparent layer over the mirror contents. This sets the correct depth-buffer values 
; 414  : 	// for the mirror surface, so further rendering won't go "inside" the mirrored scene
; 415  : 
; 416  : 	WorldMatrixVar->SetMatrix( (float*)mpObjects[0]->GetModel()->GetWorldMatrix() );
; 417  : 	mpObjects[0]->RenderMirror();
; 418  : 	*/
; 419  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RenderMirrors@CScene@@QAEXXZ ENDP			; CScene::RenderMirrors
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\game-of-life\scene.cpp
;	COMDAT ?RenderScene@CScene@@QAEXXZ
_TEXT	SEGMENT
$T1 = -392						; size = 64
$T2 = -320						; size = 64
$T3 = -248						; size = 12
_ClearColor$ = -36					; size = 16
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
?RenderScene@CScene@@QAEXXZ PROC			; CScene::RenderScene, COMDAT
; _this$ = ecx

; 323  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 396				; 0000018cH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-396]
	mov	ecx, 99					; 00000063H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 324  : 	// Clear the back buffer - before drawing the geometry clear the entire window to a fixed colour
; 325  : 	float ClearColor[4] = { 0.2f, 0.2f, 0.3f, 1.0f }; // Good idea to match background to ambient colour

	movss	xmm0, DWORD PTR __real@3e4ccccd
	movss	DWORD PTR _ClearColor$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@3e4ccccd
	movss	DWORD PTR _ClearColor$[ebp+4], xmm0
	movss	xmm0, DWORD PTR __real@3e99999a
	movss	DWORD PTR _ClearColor$[ebp+8], xmm0
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _ClearColor$[ebp+12], xmm0

; 326  : 	mpd3dDevice->ClearRenderTargetView( RenderTargetView, ClearColor );

	mov	esi, esp
	lea	eax, DWORD PTR _ClearColor$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24476]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+140]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 327  : 	mpd3dDevice->ClearDepthStencilView( DepthStencilView, D3D10_CLEAR_DEPTH | D3D10_CLEAR_STENCIL , 1.0f, 0 ); // Clear the depth buffer too

	mov	esi, esp
	push	0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	3
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24472]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+144]
	call	ecx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 328  : 
; 329  : 
; 330  : 	//---------------------------
; 331  : 	// Common rendering settings
; 332  : 
; 333  : 	// Common features for all models, set these once only
; 334  : 
; 335  : 	// Pass the camera's matrices to the vertex shader
; 336  : 	ViewMatrixVar->SetMatrix( (float*)&Camera->GetViewMatrix() );

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?GetViewMatrix@CCamera@@QAE?AU_D3DXMATRIXA16@@XZ ; CCamera::GetViewMatrix
	mov	esi, esp
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24408]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24408]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+100]
	call	ecx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 337  : 	ProjMatrixVar->SetMatrix( (float*)&Camera->GetProjectionMatrix() );

	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?GetProjectionMatrix@CCamera@@QAE?AU_D3DXMATRIXA16@@XZ ; CCamera::GetProjectionMatrix
	mov	esi, esp
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24412]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24412]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+100]
	call	ecx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 338  : 
; 339  : 	//pass the camera position
; 340  : 	dxCameraPos->SetRawValue( D3DXVECTOR3( Camera->GetPosition()), 0, 12);

	mov	esi, esp
	push	12					; 0000000cH
	push	0
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?GetPosition@CCamera@@QAE?AUD3DXVECTOR3@@XZ ; CCamera::GetPosition
	mov	ecx, eax
	call	??BD3DXVECTOR3@@QAEPAMXZ		; D3DXVECTOR3::operator float *
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24436]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24436]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+92]
	call	ecx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 341  : 
; 342  : 	//pass the lighting colours
; 343  : 	dxAmbientColour->SetRawValue( AmbientColour, 0, 12  );

	mov	esi, esp
	push	12					; 0000000cH
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24140				; 00005e4cH
	call	??BD3DXVECTOR3@@QAEPAMXZ		; D3DXVECTOR3::operator float *
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24444]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24444]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+92]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 344  : 
; 345  : 	//---------------------------
; 346  : 	// Render each model
; 347  : 	
; 348  : 	//RenderMirrors();
; 349  : 	DrawAllObjects(false);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawAllObjects@CScene@@AAEX_N@Z	; CScene::DrawAllObjects

; 350  : 
; 351  : 
; 352  : 	//---------------------------
; 353  : 	// Display the Scene
; 354  : 
; 355  : 	// After we've finished drawing to the off-screen back buffer, we "present" it to the front buffer (the screen)
; 356  : 	SwapChain->Present( 0, 0 );

	mov	esi, esp
	push	0
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24464]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24464]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+32]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 357  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@RenderScen
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 396				; 0000018cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN5@RenderScen:
	DD	1
	DD	$LN4@RenderScen
$LN4@RenderScen:
	DD	-36					; ffffffdcH
	DD	16					; 00000010H
	DD	$LN3@RenderScen
$LN3@RenderScen:
	DB	67					; 00000043H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	67					; 00000043H
	DB	111					; 0000006fH
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	0
?RenderScene@CScene@@QAEXXZ ENDP			; CScene::RenderScene
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\game-of-life\scene.cpp
;	COMDAT ?UpdateScene@CScene@@QAEXM@Z
_TEXT	SEGMENT
_j$1 = -196						; size = 4
_i$2 = -184						; size = 4
_i$3 = -172						; size = 4
_i$4 = -160						; size = 4
_FPS$ = -148						; size = 4
_buffer$ = -136						; size = 6
_caption$ = -120					; size = 100
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_frameTime$ = 8						; size = 4
?UpdateScene@CScene@@QAEXM@Z PROC			; CScene::UpdateScene, COMDAT
; _this$ = ecx

; 72   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 392				; 00000188H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-392]
	mov	ecx, 98					; 00000062H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 73   : 	//Show Framerate
; 74   : 	char caption[100];
; 75   : 	char buffer[6];
; 76   : 	
; 77   : 	//copy in base text
; 78   : 	strcpy_s( caption,  "CO2409 - Graphics Assignment - Shaders FPS ");

	push	OFFSET ??_C@_0CM@HGOJECN@CO2409?5?9?5Graphics?5Assignment?5?9?5S@
	lea	eax, DWORD PTR _caption$[ebp]
	push	eax
	call	??$strcpy_s@$0GE@@@YAHAAY0GE@DPBD@Z	; strcpy_s<100>
	add	esp, 8

; 79   : 	
; 80   : 	//calculate FPS
; 81   : 	int FPS = int ( 1.0f / frameTime );

	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _frameTime$[ebp]
	cvttss2si eax, xmm0
	mov	DWORD PTR _FPS$[ebp], eax

; 82   : 	
; 83   : 	//convert to string in base 10 and add to caption
; 84   : 	_itoa_s( FPS,buffer,10 );

	push	10					; 0000000aH
	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _FPS$[ebp]
	push	ecx
	call	??$_itoa_s@$05@@YAHHAAY05DH@Z		; _itoa_s<6>
	add	esp, 12					; 0000000cH

; 85   : 	strcat_s( caption, buffer );

	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	lea	ecx, DWORD PTR _caption$[ebp]
	push	ecx
	call	??$strcat_s@$0GE@@@YAHAAY0GE@DPBD@Z	; strcat_s<100>
	add	esp, 8

; 86   : 	
; 87   : 	//add in object and light counts as above
; 88   : 	strcat_s( caption, " O: " );

	push	OFFSET ??_C@_04IHBDCLGJ@?5O?3?5?$AA@
	lea	eax, DWORD PTR _caption$[ebp]
	push	eax
	call	??$strcat_s@$0GE@@@YAHAAY0GE@DPBD@Z	; strcat_s<100>
	add	esp, 8

; 89   : 	_itoa_s( miNumObjects, buffer, 10 );

	push	10					; 0000000aH
	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8008]
	push	edx
	call	??$_itoa_s@$05@@YAHHAAY05DH@Z		; _itoa_s<6>
	add	esp, 12					; 0000000cH

; 90   : 	strcat_s( caption, buffer );

	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	lea	ecx, DWORD PTR _caption$[ebp]
	push	ecx
	call	??$strcat_s@$0GE@@@YAHAAY0GE@DPBD@Z	; strcat_s<100>
	add	esp, 8

; 91   : 
; 92   : 	strcat_s( caption, " L: " );

	push	OFFSET ??_C@_04JFKGIEIH@?5L?3?5?$AA@
	lea	eax, DWORD PTR _caption$[ebp]
	push	eax
	call	??$strcat_s@$0GE@@@YAHAAY0GE@DPBD@Z	; strcat_s<100>
	add	esp, 8

; 93   : 	_itoa_s( miNumLights, buffer, 10 );

	push	10					; 0000000aH
	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8132]
	push	edx
	call	??$_itoa_s@$05@@YAHHAAY05DH@Z		; _itoa_s<6>
	add	esp, 12					; 0000000cH

; 94   : 	strcat_s( caption, buffer );

	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	lea	ecx, DWORD PTR _caption$[ebp]
	push	ecx
	call	??$strcat_s@$0GE@@@YAHAAY0GE@DPBD@Z	; strcat_s<100>
	add	esp, 8

; 95   : 
; 96   : 	//pass the new caption to the window
; 97   : 	SetWindowTextA( HWnd, caption );

	mov	esi, esp
	lea	eax, DWORD PTR _caption$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24484]
	push	edx
	call	DWORD PTR __imp__SetWindowTextA@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 98   : 
; 99   : 	// Control camera position and update its matrices (view matrix, projection matrix) each frame
; 100  : 	// Don't be deceived into thinking that this is a new method to control models - the same code we used previously is in the camera class
; 101  : 	Camera->Control( frameTime, Key_Up, Key_Down, Key_Left, Key_Right, Key_W, Key_S, Key_A, Key_D );

	push	68					; 00000044H
	push	65					; 00000041H
	push	83					; 00000053H
	push	87					; 00000057H
	push	39					; 00000027H
	push	37					; 00000025H
	push	40					; 00000028H
	push	38					; 00000026H
	push	ecx
	movss	xmm0, DWORD PTR _frameTime$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?Control@CCamera@@QAEXMW4EKeyCode@@0000000@Z ; CCamera::Control

; 102  : 	Camera->UpdateMatrices();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?UpdateMatrices@CCamera@@QAEXXZ		; CCamera::UpdateMatrices

; 103  : 	
; 104  : 	// Control cube position and update its world matrix each frame
; 105  : 	mpObjects[mControlObject]->GetModel()->Control( frameTime, Key_I, Key_K, Key_J, Key_L, Key_U, Key_O, Key_Period, Key_Comma );

	push	188					; 000000bcH
	push	190					; 000000beH
	push	79					; 0000004fH
	push	85					; 00000055H
	push	76					; 0000004cH
	push	74					; 0000004aH
	push	75					; 0000004bH
	push	73					; 00000049H
	push	ecx
	movss	xmm0, DWORD PTR _frameTime$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24152]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+8]
	call	?GetModel@CRenderObject@@QAEPAVCModel@@XZ ; CRenderObject::GetModel
	mov	ecx, eax
	call	?Control@CModel@@QAEXMW4EKeyCode@@0000000@Z ; CModel::Control

; 106  : 
; 107  : 	//update all the objects, including calculating the matrix
; 108  : 	for(int i = 0; i < miNumObjects; i++)

	mov	DWORD PTR _i$4[ebp], 0
	jmp	SHORT $LN34@UpdateScen
$LN33@UpdateScen:
	mov	eax, DWORD PTR _i$4[ebp]
	add	eax, 1
	mov	DWORD PTR _i$4[ebp], eax
$LN34@UpdateScen:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$4[ebp]
	cmp	ecx, DWORD PTR [eax+8008]
	jge	SHORT $LN32@UpdateScen

; 109  : 	{
; 110  : 		mpObjects[i]->Update(frameTime);

	push	ecx
	movss	xmm0, DWORD PTR _frameTime$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _i$4[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4+8]
	call	?Update@CRenderObject@@QAEXM@Z		; CRenderObject::Update

; 111  : 	}

	jmp	SHORT $LN33@UpdateScen
$LN32@UpdateScen:

; 112  : 
; 113  : 	//same for the lights
; 114  : 	for(int i = 0; i < miNumLights; i++)

	mov	DWORD PTR _i$3[ebp], 0
	jmp	SHORT $LN31@UpdateScen
$LN30@UpdateScen:
	mov	eax, DWORD PTR _i$3[ebp]
	add	eax, 1
	mov	DWORD PTR _i$3[ebp], eax
$LN31@UpdateScen:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$3[ebp]
	cmp	ecx, DWORD PTR [eax+8132]
	jge	SHORT $LN29@UpdateScen

; 115  : 	{
; 116  : 		mpLights[i]->Update(frameTime);

	push	ecx
	movss	xmm0, DWORD PTR _frameTime$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _i$3[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4+8012]
	call	?Update@CLight@@QAEXM@Z			; CLight::Update

; 117  : 	}

	jmp	SHORT $LN30@UpdateScen
$LN29@UpdateScen:

; 118  : 
; 119  : 
; 120  : 	// Allow user to quit with escape key
; 121  : 	if (KeyHit( Key_Escape )) 

	push	27					; 0000001bH
	call	?KeyHit@@YA_NW4EKeyCode@@@Z		; KeyHit
	add	esp, 4
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN28@UpdateScen

; 122  : 	{
; 123  : 		DestroyWindow( HWnd );

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24484]
	push	ecx
	call	DWORD PTR __imp__DestroyWindow@4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN28@UpdateScen:

; 124  : 	}
; 125  : 
; 126  : 
; 127  : 	//change the controlled object
; 128  : 	if( KeyHit( Key_1 ) )

	push	49					; 00000031H
	call	?KeyHit@@YA_NW4EKeyCode@@@Z		; KeyHit
	add	esp, 4
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN27@UpdateScen

; 129  : 	{
; 130  : 		mControlObject = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24152], 0
$LN27@UpdateScen:

; 131  : 	}
; 132  : 
; 133  : 	if( KeyHit( Key_2 ) )

	push	50					; 00000032H
	call	?KeyHit@@YA_NW4EKeyCode@@@Z		; KeyHit
	add	esp, 4
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN26@UpdateScen

; 134  : 	{
; 135  : 		mControlObject = 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24152], 1
$LN26@UpdateScen:

; 136  : 	}
; 137  : 
; 138  : 	if( KeyHit( Key_3 ) )

	push	51					; 00000033H
	call	?KeyHit@@YA_NW4EKeyCode@@@Z		; KeyHit
	add	esp, 4
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN25@UpdateScen

; 139  : 	{
; 140  : 		mControlObject = 2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24152], 2
$LN25@UpdateScen:

; 141  : 	}
; 142  : 
; 143  : 	if( KeyHit( Key_4 ) )

	push	52					; 00000034H
	call	?KeyHit@@YA_NW4EKeyCode@@@Z		; KeyHit
	add	esp, 4
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN24@UpdateScen

; 144  : 	{
; 145  : 		mControlObject = 3;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24152], 3
$LN24@UpdateScen:

; 146  : 	}
; 147  : 
; 148  : 	if( KeyHit( Key_5 ) )

	push	53					; 00000035H
	call	?KeyHit@@YA_NW4EKeyCode@@@Z		; KeyHit
	add	esp, 4
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN23@UpdateScen

; 149  : 	{
; 150  : 		mControlObject = 4;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24152], 4
$LN23@UpdateScen:

; 151  : 	}
; 152  : 
; 153  : 	if( KeyHit( Key_6 ) )

	push	54					; 00000036H
	call	?KeyHit@@YA_NW4EKeyCode@@@Z		; KeyHit
	add	esp, 4
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN22@UpdateScen

; 154  : 	{
; 155  : 		mControlObject = 5;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24152], 5
$LN22@UpdateScen:

; 156  : 	}
; 157  : 
; 158  : 	if( KeyHit( Key_7 ) )

	push	55					; 00000037H
	call	?KeyHit@@YA_NW4EKeyCode@@@Z		; KeyHit
	add	esp, 4
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN21@UpdateScen

; 159  : 	{
; 160  : 		mControlObject = 6;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24152], 6
$LN21@UpdateScen:

; 161  : 	}
; 162  : 
; 163  : 	if( KeyHit( Key_8 ) )

	push	56					; 00000038H
	call	?KeyHit@@YA_NW4EKeyCode@@@Z		; KeyHit
	add	esp, 4
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN20@UpdateScen

; 164  : 	{
; 165  : 		mControlObject = 7;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24152], 7
$LN20@UpdateScen:

; 166  : 	}
; 167  : 
; 168  : 	if( KeyHit( Key_9 ) )

	push	57					; 00000039H
	call	?KeyHit@@YA_NW4EKeyCode@@@Z		; KeyHit
	add	esp, 4
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN19@UpdateScen

; 169  : 	{
; 170  : 		mControlObject = 8;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24152], 8
$LN19@UpdateScen:

; 171  : 	}
; 172  : 
; 173  : 	if( KeyHit( Key_0 ) )

	push	48					; 00000030H
	call	?KeyHit@@YA_NW4EKeyCode@@@Z		; KeyHit
	add	esp, 4
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN18@UpdateScen

; 174  : 	{
; 175  : 		mControlObject = 9;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24152], 9
$LN18@UpdateScen:

; 176  : 	}
; 177  : 
; 178  : 	if( KeyHit ( Key_Minus ) )

	push	189					; 000000bdH
	call	?KeyHit@@YA_NW4EKeyCode@@@Z		; KeyHit
	add	esp, 4
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN15@UpdateScen

; 179  : 	{
; 180  : 		if ( mControlObject == 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24152], 0
	jne	SHORT $LN16@UpdateScen

; 181  : 		{
; 182  : 			mControlObject = miNumObjects-1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8008]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+24152], ecx

; 183  : 		}
; 184  : 		else

	jmp	SHORT $LN15@UpdateScen
$LN16@UpdateScen:

; 185  : 		{
; 186  : 			mControlObject--;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24152]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+24152], ecx
$LN15@UpdateScen:

; 187  : 		}
; 188  : 	}
; 189  : 
; 190  : 	if( KeyHit ( Key_Plus ) )

	push	187					; 000000bbH
	call	?KeyHit@@YA_NW4EKeyCode@@@Z		; KeyHit
	add	esp, 4
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN12@UpdateScen

; 191  : 	{
; 192  : 		if ( mControlObject == miNumObjects-1 )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8008]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+24152], ecx
	jne	SHORT $LN13@UpdateScen

; 193  : 		{
; 194  : 			mControlObject = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24152], 0

; 195  : 		}
; 196  : 		else

	jmp	SHORT $LN12@UpdateScen
$LN13@UpdateScen:

; 197  : 		{
; 198  : 			mControlObject++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24152]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+24152], ecx
$LN12@UpdateScen:

; 199  : 		}
; 200  : 	}
; 201  : 
; 202  : 	CalcNeighbours();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalcNeighbours@CScene@@AAEXXZ		; CScene::CalcNeighbours

; 203  : 
; 204  : 	for( int i = 0; i < GRIDSIZE; i++ )

	mov	DWORD PTR _i$2[ebp], 0
	jmp	SHORT $LN11@UpdateScen
$LN10@UpdateScen:
	mov	eax, DWORD PTR _i$2[ebp]
	add	eax, 1
	mov	DWORD PTR _i$2[ebp], eax
$LN11@UpdateScen:
	cmp	DWORD PTR _i$2[ebp], 30			; 0000001eH
	jge	$LN9@UpdateScen

; 205  : 	{
; 206  : 		for( int j = 0; j < GRIDSIZE; j++ )

	mov	DWORD PTR _j$1[ebp], 0
	jmp	SHORT $LN8@UpdateScen
$LN7@UpdateScen:
	mov	eax, DWORD PTR _j$1[ebp]
	add	eax, 1
	mov	DWORD PTR _j$1[ebp], eax
$LN8@UpdateScen:
	cmp	DWORD PTR _j$1[ebp], 30			; 0000001eH
	jge	$LN6@UpdateScen

; 207  : 		{
; 208  : 			if( cells[i][j].val == 1 )

	imul	eax, DWORD PTR _i$2[ebp], 360
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [ecx+eax+24488]
	imul	eax, DWORD PTR _j$1[ebp], 12
	cmp	DWORD PTR [edx+eax], 1
	jne	SHORT $LN5@UpdateScen

; 209  : 			{
; 210  : 				if( cells[i][j].adjcell < 2 || cells[i][j].adjcell > 3 )

	imul	eax, DWORD PTR _i$2[ebp], 360
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [ecx+eax+24488]
	imul	eax, DWORD PTR _j$1[ebp], 12
	cmp	DWORD PTR [edx+eax+4], 2
	jl	SHORT $LN3@UpdateScen
	imul	eax, DWORD PTR _i$2[ebp], 360
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [ecx+eax+24488]
	imul	eax, DWORD PTR _j$1[ebp], 12
	cmp	DWORD PTR [edx+eax+4], 3
	jle	SHORT $LN4@UpdateScen
$LN3@UpdateScen:

; 211  : 				{
; 212  : 					SetDead(i,j);

	mov	eax, DWORD PTR _j$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDead@CScene@@AAEXHH@Z		; CScene::SetDead
$LN4@UpdateScen:

; 213  : 				}
; 214  : 			}
; 215  : 			else

	jmp	SHORT $LN1@UpdateScen
$LN5@UpdateScen:

; 216  : 			{
; 217  : 				if( cells[i][j].adjcell > 2 )

	imul	eax, DWORD PTR _i$2[ebp], 360
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [ecx+eax+24488]
	imul	eax, DWORD PTR _j$1[ebp], 12
	cmp	DWORD PTR [edx+eax+4], 2
	jle	SHORT $LN1@UpdateScen

; 218  : 				{
; 219  : 					SetLive(i,j);

	mov	eax, DWORD PTR _j$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLive@CScene@@AAEXHH@Z		; CScene::SetLive
$LN1@UpdateScen:

; 220  : 				}
; 221  : 			}
; 222  : 		}

	jmp	$LN7@UpdateScen
$LN6@UpdateScen:

; 223  : 	}

	jmp	$LN10@UpdateScen
$LN9@UpdateScen:

; 224  : 
; 225  : 	
; 226  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN40@UpdateScen
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 392				; 00000188H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	1
$LN40@UpdateScen:
	DD	2
	DD	$LN39@UpdateScen
$LN39@UpdateScen:
	DD	-120					; ffffff88H
	DD	100					; 00000064H
	DD	$LN37@UpdateScen
	DD	-136					; ffffff78H
	DD	6
	DD	$LN38@UpdateScen
$LN38@UpdateScen:
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	102					; 00000066H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
$LN37@UpdateScen:
	DB	99					; 00000063H
	DB	97					; 00000061H
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	0
?UpdateScene@CScene@@QAEXM@Z ENDP			; CScene::UpdateScene
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\game-of-life\scene.cpp
;	COMDAT ?InitScene@CScene@@QAE_NXZ
_TEXT	SEGMENT
tv359 = -412						; size = 4
tv87 = -412						; size = 4
$T2 = -404						; size = 4
$T3 = -392						; size = 4
$T4 = -380						; size = 12
$T5 = -360						; size = 12
$T6 = -340						; size = 4
$T7 = -328						; size = 4
$T8 = -316						; size = 12
$T9 = -296						; size = 12
$T10 = -276						; size = 12
$T11 = -256						; size = 12
$T12 = -236						; size = 12
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?InitScene@CScene@@QAE_NXZ PROC				; CScene::InitScene, COMDAT
; _this$ = ecx

; 30   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?InitScene@CScene@@QAE_NXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 400				; 00000190H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-412]
	mov	ecx, 100				; 00000064H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 31   : 	//////////////////
; 32   : 	// Create camera
; 33   : 
; 34   : 	Camera = new CCamera();

	push	304					; 00000130H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	$LN18@InitScene
	push	ecx
	movss	xmm0, DWORD PTR __real@461c4000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f490fdb
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T4[ebp]
	call	??0D3DXVECTOR3@@QAE@MMM@Z		; D3DXVECTOR3::D3DXVECTOR3
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T5[ebp]
	call	??0D3DXVECTOR3@@QAE@MMM@Z		; D3DXVECTOR3::D3DXVECTOR3
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, DWORD PTR $T3[ebp]
	call	??0CCamera@@QAE@UD3DXVECTOR3@@0MMM@Z	; CCamera::CCamera
	mov	DWORD PTR tv87[ebp], eax
	jmp	SHORT $LN19@InitScene
$LN18@InitScene:
	mov	DWORD PTR tv87[ebp], 0
$LN19@InitScene:
	mov	ecx, DWORD PTR tv87[ebp]
	mov	DWORD PTR $T2[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR [edx+4], eax

; 35   : 	Camera->SetPosition( D3DXVECTOR3(-15, 20,-40) );

	push	ecx
	movss	xmm0, DWORD PTR __real@c2200000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@41a00000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@c1700000
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T8[ebp]
	call	??0D3DXVECTOR3@@QAE@MMM@Z		; D3DXVECTOR3::D3DXVECTOR3
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?SetPosition@CCamera@@QAEXUD3DXVECTOR3@@@Z ; CCamera::SetPosition

; 36   : 	Camera->SetRotation( D3DXVECTOR3(ToRadians(13.0f), ToRadians(18.0f), 0.0f) ); // ToRadians is a new helper function to convert degrees to radians

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@41900000
	movss	DWORD PTR [esp], xmm0
	call	?ToRadians@@YAMM@Z			; ToRadians
	fstp	DWORD PTR [esp]
	push	ecx
	movss	xmm0, DWORD PTR __real@41500000
	movss	DWORD PTR [esp], xmm0
	call	?ToRadians@@YAMM@Z			; ToRadians
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T9[ebp]
	call	??0D3DXVECTOR3@@QAE@MMM@Z		; D3DXVECTOR3::D3DXVECTOR3
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?SetRotation@CCamera@@QAEXUD3DXVECTOR3@@@Z ; CCamera::SetRotation

; 37   : 	Camera->SetNearClip( 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?SetNearClip@CCamera@@QAEXM@Z		; CCamera::SetNearClip

; 38   : 
; 39   : 	//load all textures and maps
; 40   : 	if (FAILED( D3DX10CreateShaderResourceViewFromFile( mpd3dDevice, L"StoneDiffuseSpecular.dds",		NULL, NULL, &mpMaps[0], NULL ) )) return false;

	push	0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [edx+ecx+8136]
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_1DC@LOBNDLGH@?$AAS?$AAt?$AAo?$AAn?$AAe?$AAD?$AAi?$AAf?$AAf?$AAu?$AAs?$AAe?$AAS?$AAp?$AAe?$AAc?$AAu?$AAl?$AAa?$AAr?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_D3DX10CreateShaderResourceViewFromFileW@24
	test	eax, eax
	jge	SHORT $LN15@InitScene
	xor	al, al
	jmp	$LN16@InitScene
$LN15@InitScene:

; 41   : 	if (FAILED( D3DX10CreateShaderResourceViewFromFile( mpd3dDevice, L"WoodDiffuseSpecular.dds",		NULL, NULL, &mpMaps[1], NULL ) )) return false;

	push	0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [ecx+eax+8136]
	push	edx
	push	0
	push	0
	push	OFFSET ??_C@_1DA@IEJEKIPL@?$AAW?$AAo?$AAo?$AAd?$AAD?$AAi?$AAf?$AAf?$AAu?$AAs?$AAe?$AAS?$AAp?$AAe?$AAc?$AAu?$AAl?$AAa?$AAr?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_D3DX10CreateShaderResourceViewFromFileW@24
	test	eax, eax
	jge	SHORT $LN14@InitScene
	xor	al, al
	jmp	$LN16@InitScene
$LN14@InitScene:

; 42   : 	if (FAILED( D3DX10CreateShaderResourceViewFromFile( mpd3dDevice, L"Moon.jpg",						NULL, NULL, &mpMaps[2], NULL ) )) return false; 

	push	0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [ecx+eax+8136]
	push	edx
	push	0
	push	0
	push	OFFSET ??_C@_1BC@MACPKMCG@?$AAM?$AAo?$AAo?$AAn?$AA?4?$AAj?$AAp?$AAg?$AA?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_D3DX10CreateShaderResourceViewFromFileW@24
	test	eax, eax
	jge	SHORT $LN13@InitScene
	xor	al, al
	jmp	$LN16@InitScene
$LN13@InitScene:

; 43   : 	if (FAILED( D3DX10CreateShaderResourceViewFromFile( mpd3dDevice, L"WallDiffuseSpecular.dds",		NULL, NULL, &mpMaps[3], NULL ) )) return false;

	push	0
	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [edx+ecx+8136]
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_1DA@GABNFLNL@?$AAW?$AAa?$AAl?$AAl?$AAD?$AAi?$AAf?$AAf?$AAu?$AAs?$AAe?$AAS?$AAp?$AAe?$AAc?$AAu?$AAl?$AAa?$AAr?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_D3DX10CreateShaderResourceViewFromFileW@24
	test	eax, eax
	jge	SHORT $LN12@InitScene
	xor	al, al
	jmp	$LN16@InitScene
$LN12@InitScene:

; 44   : 	if (FAILED( D3DX10CreateShaderResourceViewFromFile( mpd3dDevice, L"WallNormalDepth.dds",			NULL, NULL, &mpMaps[4], NULL ) )) return false;

	push	0
	mov	eax, 4
	shl	eax, 2
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [ecx+eax+8136]
	push	edx
	push	0
	push	0
	push	OFFSET ??_C@_1CI@HJHILCKN@?$AAW?$AAa?$AAl?$AAl?$AAN?$AAo?$AAr?$AAm?$AAa?$AAl?$AAD?$AAe?$AAp?$AAt?$AAh?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_D3DX10CreateShaderResourceViewFromFileW@24
	test	eax, eax
	jge	SHORT $LN11@InitScene
	xor	al, al
	jmp	$LN16@InitScene
$LN11@InitScene:

; 45   : 	if (FAILED( D3DX10CreateShaderResourceViewFromFile( mpd3dDevice, L"MetalDiffuseSpecular.dds",		NULL, NULL, &mpMaps[5], NULL ) )) return false;

	push	0
	mov	eax, 4
	imul	ecx, eax, 5
	mov	edx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [edx+ecx+8136]
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_1DC@DJHFCGLD@?$AAM?$AAe?$AAt?$AAa?$AAl?$AAD?$AAi?$AAf?$AAf?$AAu?$AAs?$AAe?$AAS?$AAp?$AAe?$AAc?$AAu?$AAl?$AAa?$AAr?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_D3DX10CreateShaderResourceViewFromFileW@24
	test	eax, eax
	jge	SHORT $LN10@InitScene
	xor	al, al
	jmp	$LN16@InitScene
$LN10@InitScene:

; 46   : 	if (FAILED( D3DX10CreateShaderResourceViewFromFile( mpd3dDevice, L"PatternDiffuseSpecular.dds",		NULL, NULL, &mpMaps[6], NULL ) )) return false;

	push	0
	mov	eax, 4
	imul	ecx, eax, 6
	mov	edx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [edx+ecx+8136]
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_1DG@GOOKDEDK@?$AAP?$AAa?$AAt?$AAt?$AAe?$AAr?$AAn?$AAD?$AAi?$AAf?$AAf?$AAu?$AAs?$AAe?$AAS?$AAp?$AAe?$AAc?$AAu?$AAl?$AAa?$AAr?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_D3DX10CreateShaderResourceViewFromFileW@24
	test	eax, eax
	jge	SHORT $LN9@InitScene
	xor	al, al
	jmp	$LN16@InitScene
$LN9@InitScene:

; 47   : 	if (FAILED( D3DX10CreateShaderResourceViewFromFile( mpd3dDevice, L"PatternNormalDepth.dds",			NULL, NULL, &mpMaps[7], NULL ) )) return false;

	push	0
	mov	eax, 4
	imul	ecx, eax, 7
	mov	edx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [edx+ecx+8136]
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_1CO@NOLHING@?$AAP?$AAa?$AAt?$AAt?$AAe?$AAr?$AAn?$AAN?$AAo?$AAr?$AAm?$AAa?$AAl?$AAD?$AAe?$AAp?$AAt?$AAh?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_D3DX10CreateShaderResourceViewFromFileW@24
	test	eax, eax
	jge	SHORT $LN8@InitScene
	xor	al, al
	jmp	$LN16@InitScene
$LN8@InitScene:

; 48   : 	if (FAILED( D3DX10CreateShaderResourceViewFromFile( mpd3dDevice, L"Glass.jpg",						NULL, NULL, &mpMaps[8], NULL ) )) return false;

	push	0
	mov	eax, 4
	shl	eax, 3
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [ecx+eax+8136]
	push	edx
	push	0
	push	0
	push	OFFSET ??_C@_1BE@DADLEHEK@?$AAG?$AAl?$AAa?$AAs?$AAs?$AA?4?$AAj?$AAp?$AAg?$AA?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_D3DX10CreateShaderResourceViewFromFileW@24
	test	eax, eax
	jge	SHORT $LN7@InitScene
	xor	al, al
	jmp	$LN16@InitScene
$LN7@InitScene:

; 49   : 	if (FAILED( D3DX10CreateShaderResourceViewFromFile( mpd3dDevice, L"Troll1DiffuseSpecular.dds",		NULL, NULL, &mpMaps[9], NULL ) )) return false;

	push	0
	mov	eax, 4
	imul	ecx, eax, 9
	mov	edx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [edx+ecx+8136]
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_1DE@DFEKPPGN@?$AAT?$AAr?$AAo?$AAl?$AAl?$AA1?$AAD?$AAi?$AAf?$AAf?$AAu?$AAs?$AAe?$AAS?$AAp?$AAe?$AAc?$AAu?$AAl?$AAa?$AAr?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_D3DX10CreateShaderResourceViewFromFileW@24
	test	eax, eax
	jge	SHORT $LN6@InitScene
	xor	al, al
	jmp	$LN16@InitScene
$LN6@InitScene:

; 50   : 	if (FAILED( D3DX10CreateShaderResourceViewFromFile( mpd3dDevice, L"Troll2DiffuseSpecular.dds",		NULL, NULL, &mpMaps[10], NULL ) )) return false;

	push	0
	mov	eax, 4
	imul	ecx, eax, 10
	mov	edx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [edx+ecx+8136]
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_1DE@NHBHEBO@?$AAT?$AAr?$AAo?$AAl?$AAl?$AA2?$AAD?$AAi?$AAf?$AAf?$AAu?$AAs?$AAe?$AAS?$AAp?$AAe?$AAc?$AAu?$AAl?$AAa?$AAr?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_D3DX10CreateShaderResourceViewFromFileW@24
	test	eax, eax
	jge	SHORT $LN5@InitScene
	xor	al, al
	jmp	$LN16@InitScene
$LN5@InitScene:

; 51   : 	if (FAILED( D3DX10CreateShaderResourceViewFromFile( mpd3dDevice, L"Troll3DiffuseSpecular.dds",		NULL, NULL, &mpMaps[11], NULL ) )) return false;

	push	0
	mov	eax, 4
	imul	ecx, eax, 11
	mov	edx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [edx+ecx+8136]
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_1DE@KMEIPAPA@?$AAT?$AAr?$AAo?$AAl?$AAl?$AA3?$AAD?$AAi?$AAf?$AAf?$AAu?$AAs?$AAe?$AAS?$AAp?$AAe?$AAc?$AAu?$AAl?$AAa?$AAr?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_D3DX10CreateShaderResourceViewFromFileW@24
	test	eax, eax
	jge	SHORT $LN4@InitScene
	xor	al, al
	jmp	$LN16@InitScene
$LN4@InitScene:

; 52   : 	if (FAILED( D3DX10CreateShaderResourceViewFromFile( mpd3dDevice, L"Troll4DiffuseSpecular.dds",		NULL, NULL, &mpMaps[12], NULL ) )) return false;

	push	0
	mov	eax, 4
	imul	ecx, eax, 12
	mov	edx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [edx+ecx+8136]
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_1DE@HNAGGCPI@?$AAT?$AAr?$AAo?$AAl?$AAl?$AA4?$AAD?$AAi?$AAf?$AAf?$AAu?$AAs?$AAe?$AAS?$AAp?$AAe?$AAc?$AAu?$AAl?$AAa?$AAr?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_D3DX10CreateShaderResourceViewFromFileW@24
	test	eax, eax
	jge	SHORT $LN3@InitScene
	xor	al, al
	jmp	$LN16@InitScene
$LN3@InitScene:

; 53   : 	if (FAILED( D3DX10CreateShaderResourceViewFromFile( mpd3dDevice, L"BrainDiffuseSpecular.dds",		NULL, NULL, &mpMaps[13], NULL ) )) return false;

	push	0
	mov	eax, 4
	imul	ecx, eax, 13
	mov	edx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [edx+ecx+8136]
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_1DC@ONLGGDNI@?$AAB?$AAr?$AAa?$AAi?$AAn?$AAD?$AAi?$AAf?$AAf?$AAu?$AAs?$AAe?$AAS?$AAp?$AAe?$AAc?$AAu?$AAl?$AAa?$AAr?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_D3DX10CreateShaderResourceViewFromFileW@24
	test	eax, eax
	jge	SHORT $LN2@InitScene
	xor	al, al
	jmp	$LN16@InitScene
$LN2@InitScene:

; 54   : 	if (FAILED( D3DX10CreateShaderResourceViewFromFile( mpd3dDevice, L"BrainNormalDepth.dds",			NULL, NULL, &mpMaps[14], NULL ) )) return false;

	push	0
	mov	eax, 4
	imul	ecx, eax, 14
	mov	edx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [edx+ecx+8136]
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_1CK@IHOPDIJ@?$AAB?$AAr?$AAa?$AAi?$AAn?$AAN?$AAo?$AAr?$AAm?$AAa?$AAl?$AAD?$AAe?$AAp?$AAt?$AAh?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_D3DX10CreateShaderResourceViewFromFileW@24
	test	eax, eax
	jge	SHORT $LN1@InitScene
	xor	al, al
	jmp	$LN16@InitScene
$LN1@InitScene:

; 55   : 	miNumMaps = 15;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24136], 15		; 0000000fH

; 56   : 
; 57   : 	//Create the mirror as object 0, makes life easier. 
; 58   : 	mpObjects[0] = new CRenderObject("Mirror.x",	D3DXVECTOR3( -20, 30, 0 ),		D3DXVECTOR3(0.2f, 0.2f, 0.3f), mTechniquesMirror[18], mTechniquesMirror[19], NULL, NULL, false, false, false);

	push	72					; 00000048H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T7[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T7[ebp], 0
	je	$LN20@InitScene
	push	0
	push	0
	push	0
	push	0
	push	0
	mov	eax, 4
	imul	ecx, eax, 19
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+24280]
	push	eax
	mov	ecx, 4
	imul	edx, ecx, 18
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+24280]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR __real@3e99999a
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3e4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3e4ccccd
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T11[ebp]
	call	??0D3DXVECTOR3@@QAE@MMM@Z		; D3DXVECTOR3::D3DXVECTOR3
	sub	esp, 12					; 0000000cH
	mov	edx, esp
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@41f00000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@c1a00000
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T10[ebp]
	call	??0D3DXVECTOR3@@QAE@MMM@Z		; D3DXVECTOR3::D3DXVECTOR3
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	push	OFFSET ??_C@_08MLPDMJMG@Mirror?4x?$AA@
	mov	ecx, DWORD PTR $T7[ebp]
	call	??0CRenderObject@@QAE@QADUD3DXVECTOR3@@1PAUID3D10EffectTechnique@@2PAUID3D10ShaderResourceView@@3_N44@Z ; CRenderObject::CRenderObject
	mov	DWORD PTR tv359[ebp], eax
	jmp	SHORT $LN21@InitScene
$LN20@InitScene:
	mov	DWORD PTR tv359[ebp], 0
$LN21@InitScene:
	mov	ecx, DWORD PTR tv359[ebp]
	mov	DWORD PTR $T6[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T6[ebp]
	mov	DWORD PTR [ecx+eax+8], edx

; 59   : 	mpObjects[0]->GetModel()->SetRotation( D3DXVECTOR3(1, 2, 0)  );

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T12[ebp]
	call	??0D3DXVECTOR3@@QAE@MMM@Z		; D3DXVECTOR3::D3DXVECTOR3
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+8]
	call	?GetModel@CRenderObject@@QAEPAVCModel@@XZ ; CRenderObject::GetModel
	mov	ecx, eax
	call	?SetRotation@CModel@@QAEXUD3DXVECTOR3@@@Z ; CModel::SetRotation

; 60   : 	mpObjects[0]->GetModel()->UpdateMatrix();

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+8]
	call	?GetModel@CRenderObject@@QAEPAVCModel@@XZ ; CRenderObject::GetModel
	mov	ecx, eax
	call	?UpdateMatrix@CModel@@QAEXXZ		; CModel::UpdateMatrix

; 61   : 	miNumObjects++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8008]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8008], ecx

; 62   : 
; 63   : 	CellStuff();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CellStuff@CScene@@AAE_NXZ		; CScene::CellStuff

; 64   : 
; 65   : 	
; 66   : 	return true;

	mov	al, 1
$LN16@InitScene:

; 67   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 412				; 0000019cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?InitScene@CScene@@QAE_NXZ$0:
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?InitScene@CScene@@QAE_NXZ$1:
	mov	eax, DWORD PTR $T7[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?InitScene@CScene@@QAE_NXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-416]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?InitScene@CScene@@QAE_NXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?InitScene@CScene@@QAE_NXZ ENDP				; CScene::InitScene
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\game-of-life\scene.cpp
;	COMDAT ?LoadEffectFile@CScene@@QAE_NXZ
_TEXT	SEGMENT
tv868 = -516						; size = 4
tv863 = -516						; size = 4
tv847 = -516						; size = 4
tv828 = -516						; size = 4
tv810 = -516						; size = 4
tv794 = -516						; size = 4
tv776 = -516						; size = 4
tv761 = -516						; size = 4
tv746 = -516						; size = 4
tv731 = -516						; size = 4
tv716 = -516						; size = 4
tv701 = -516						; size = 4
tv686 = -516						; size = 4
tv671 = -516						; size = 4
tv656 = -516						; size = 4
$T1 = -508						; size = 260
_hr$ = -48						; size = 4
_dwShaderFlags$ = -36					; size = 4
_pErrors$ = -24						; size = 4
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
?LoadEffectFile@CScene@@QAE_NXZ PROC			; CScene::LoadEffectFile, COMDAT
; _this$ = ecx

; 646  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 516				; 00000204H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-516]
	mov	ecx, 129				; 00000081H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 647  : 	ID3D10Blob* pErrors; // This strangely typed variable collects any errors when compiling the effect file
; 648  : 	DWORD dwShaderFlags = D3D10_SHADER_ENABLE_STRICTNESS; // These "flags" are used to set the compiler options

	mov	DWORD PTR _dwShaderFlags$[ebp], 2048	; 00000800H

; 649  : 
; 650  : 	// Load and compile the effect file
; 651  : 	HRESULT hr = D3DX10CreateEffectFromFile( L"GraphicsAssign1.fx", NULL, NULL, "fx_4_0", dwShaderFlags, 0, mpd3dDevice, NULL, NULL, &Effect, &pErrors, NULL );

	push	0
	lea	eax, DWORD PTR _pErrors$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24156				; 00005e5cH
	push	ecx
	push	0
	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	push	0
	mov	ecx, DWORD PTR _dwShaderFlags$[ebp]
	push	ecx
	push	OFFSET ??_C@_06BACILOGA@fx_4_0?$AA@
	push	0
	push	0
	push	OFFSET ??_C@_1CG@MCKIKNIO@?$AAG?$AAr?$AAa?$AAp?$AAh?$AAi?$AAc?$AAs?$AAA?$AAs?$AAs?$AAi?$AAg?$AAn?$AA1?$AA?4?$AAf?$AAx?$AA?$AA@
	call	_D3DX10CreateEffectFromFileW@48
	mov	DWORD PTR _hr$[ebp], eax

; 652  : 	if( FAILED( hr ) )

	cmp	DWORD PTR _hr$[ebp], 0
	jge	$LN3@LoadEffect

; 653  : 	{
; 654  : 		if (pErrors != 0)  MessageBox( NULL, CA2CT(reinterpret_cast<char*>(pErrors->GetBufferPointer())), L"Error", MB_OK ); // Compiler error: display error message

	cmp	DWORD PTR _pErrors$[ebp], 0
	je	SHORT $LN2@LoadEffect
	mov	esi, esp
	push	0
	push	OFFSET ??_C@_1M@ILHOPKA@?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?$AA@
	mov	eax, DWORD PTR _pErrors$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edi, esp
	mov	edx, DWORD PTR _pErrors$[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+12]
	call	eax
	cmp	edi, esp
	call	__RTC_CheckEsp
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0?$CA2WEX@$0IA@@ATL@@QAE@PBD@Z	; ATL::CA2WEX<128>::CA2WEX<128>
	mov	DWORD PTR tv868[ebp], eax
	mov	ecx, DWORD PTR tv868[ebp]
	call	??B?$CA2WEX@$0IA@@ATL@@QBEPA_WXZ	; ATL::CA2WEX<128>::operator wchar_t *
	push	eax
	push	0
	call	DWORD PTR __imp__MessageBoxW@16
	cmp	esi, esp
	call	__RTC_CheckEsp
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1?$CA2WEX@$0IA@@ATL@@QAE@XZ		; ATL::CA2WEX<128>::~CA2WEX<128>
	jmp	SHORT $LN1@LoadEffect
$LN2@LoadEffect:

; 655  : 		else               MessageBox( NULL, L"Error loading FX file. Ensure your FX file is in the same folder as this executable.", L"Error", MB_OK );  // No error message - probably file not found

	mov	esi, esp
	push	0
	push	OFFSET ??_C@_1M@ILHOPKA@?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?$AA@
	push	OFFSET ??_C@_1KK@KKJBPFMN@?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?5?$AAl?$AAo?$AAa?$AAd?$AAi?$AAn?$AAg?$AA?5?$AAF?$AAX?$AA?5?$AAf?$AAi?$AAl?$AAe?$AA?4?$AA?5?$AAE?$AAn?$AAs?$AAu?$AAr?$AAe?$AA?5?$AAy?$AAo@
	push	0
	call	DWORD PTR __imp__MessageBoxW@16
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@LoadEffect:

; 656  : 		return false;

	xor	al, al
	jmp	$LN4@LoadEffect
$LN3@LoadEffect:

; 657  : 	}
; 658  : 
; 659  : 	// Now we can select techniques from the compiled effect file
; 660  : 	// Regular techniques for the main scene
; 661  : 	mTechniques[ 0]	= Effect->GetTechniqueByName( "tPlainColour" );

	mov	esi, esp
	push	OFFSET ??_C@_0N@BLACAFBJ@tPlainColour?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24156]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24156]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+52]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+edx+24160], eax

; 662  : 	mTechniques[ 1]	= Effect->GetTechniqueByName( "tPlainTexture" );

	mov	esi, esp
	push	OFFSET ??_C@_0O@CBIDLEEF@tPlainTexture?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24156]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24156]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+52]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+24160], eax

; 663  : 	mTechniques[ 2]	= Effect->GetTechniqueByName( "tColourChangeTexture" );

	mov	esi, esp
	push	OFFSET ??_C@_0BF@HOFAMMJK@tColourChangeTexture?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24156]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24156]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+52]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+24160], eax

; 664  : 	mTechniques[ 3]	= Effect->GetTechniqueByName( "tLitTexture" );

	mov	esi, esp
	push	OFFSET ??_C@_0M@PFGJBPP@tLitTexture?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24156]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24156]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+52]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, 4
	imul	edx, ecx, 3
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+edx+24160], eax

; 665  : 	mTechniques[ 4]	= Effect->GetTechniqueByName( "t4LitTexture" );

	mov	esi, esp
	push	OFFSET ??_C@_0N@DBNJLAPA@t4LitTexture?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24156]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24156]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+52]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, 4
	shl	ecx, 2
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+24160], eax

; 666  : 	mTechniques[ 5] = Effect->GetTechniqueByName( "t4LitAttenTexture" );

	mov	esi, esp
	push	OFFSET ??_C@_0BC@EBBNGCN@t4LitAttenTexture?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24156]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24156]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+52]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, 4
	imul	edx, ecx, 5
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+edx+24160], eax

; 667  : 	mTechniques[ 6]	= Effect->GetTechniqueByName( "t4LitSpecularMap" );

	mov	esi, esp
	push	OFFSET ??_C@_0BB@NDOCHMBG@t4LitSpecularMap?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24156]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24156]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+52]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, 4
	imul	edx, ecx, 6
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+edx+24160], eax

; 668  : 	mTechniques[ 7]	= Effect->GetTechniqueByName( "tParallaxMap" );

	mov	esi, esp
	push	OFFSET ??_C@_0N@FAEPMAEM@tParallaxMap?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24156]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24156]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+52]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, 4
	imul	edx, ecx, 7
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+edx+24160], eax

; 669  : 	mTechniques[ 8]	= Effect->GetTechniqueByName( "tJelly" );

	mov	esi, esp
	push	OFFSET ??_C@_06ELGFLNMO@tJelly?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24156]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24156]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+52]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, 4
	shl	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+24160], eax

; 670  : 	mTechniques[ 9]	= Effect->GetTechniqueByName( "tCellShading" );

	mov	esi, esp
	push	OFFSET ??_C@_0N@HPAFDOEN@tCellShading?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24156]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24156]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+52]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, 4
	imul	edx, ecx, 9
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+edx+24160], eax

; 671  : 	mTechniques[10] = Effect->GetTechniqueByName( "tCellShadingWrong" );

	mov	esi, esp
	push	OFFSET ??_C@_0BC@IHNCMDEH@tCellShadingWrong?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24156]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24156]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+52]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, 4
	imul	edx, ecx, 10
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+edx+24160], eax

; 672  : 	mTechniques[11] = Effect->GetTechniqueByName( "tHalo" );

	mov	esi, esp
	push	OFFSET ??_C@_05JGDPNHEJ@tHalo?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24156]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24156]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+52]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, 4
	imul	edx, ecx, 11
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+edx+24160], eax

; 673  : 	mTechniques[12] = Effect->GetTechniqueByName( "tSpaceHaloPara" );

	mov	esi, esp
	push	OFFSET ??_C@_0P@FEDIONCO@tSpaceHaloPara?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24156]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24156]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+52]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, 4
	imul	edx, ecx, 12
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+edx+24160], eax

; 674  : 	mTechniques[13] = Effect->GetTechniqueByName( "tSpaceOutlinePara" );

	mov	esi, esp
	push	OFFSET ??_C@_0BC@NABDBAIK@tSpaceOutlinePara?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24156]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24156]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+52]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, 4
	imul	edx, ecx, 13
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+edx+24160], eax

; 675  : 	mTechniques[14] = Effect->GetTechniqueByName( "tLitGlass" );

	mov	esi, esp
	push	OFFSET ??_C@_09JDFCMBBC@tLitGlass?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24156]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24156]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+52]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, 4
	imul	edx, ecx, 14
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+edx+24160], eax

; 676  : 	mTechniques[15] = Effect->GetTechniqueByName( "tSpaceHalo" );

	mov	esi, esp
	push	OFFSET ??_C@_0L@MOJEDPIK@tSpaceHalo?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24156]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24156]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+52]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, 4
	imul	edx, ecx, 15
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+edx+24160], eax

; 677  : 	mTechniques[16] = Effect->GetTechniqueByName( "tSpaceOutline" );

	mov	esi, esp
	push	OFFSET ??_C@_0O@GOICGJFK@tSpaceOutline?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24156]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24156]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+52]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, 4
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+24160], eax

; 678  : 	mTechniques[17] = Effect->GetTechniqueByName( "tTextureMorph" );

	mov	esi, esp
	push	OFFSET ??_C@_0O@CIOABDO@tTextureMorph?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24156]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24156]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+52]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, 4
	imul	edx, ecx, 17
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+edx+24160], eax

; 679  : 	mTechniques[18] = Effect->GetTechniqueByName( "MirrorClear" );		//added to both just to keep the enum consistant.

	mov	esi, esp
	push	OFFSET ??_C@_0M@NCEALFAM@MirrorClear?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24156]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24156]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+52]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, 4
	imul	edx, ecx, 18
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+edx+24160], eax

; 680  : 	mTechniques[19] = Effect->GetTechniqueByName( "MirrorSurface" );	

	mov	esi, esp
	push	OFFSET ??_C@_0O@CFAHMOKA@MirrorSurface?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24156]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24156]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+52]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, 4
	imul	edx, ecx, 19
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+edx+24160], eax

; 681  : 	miNumTechniques = 20;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24400], 20		; 00000014H

; 682  : 
; 683  : 	// Techniques for the mirrored objects
; 684  : 	mTechniquesMirror[ 0] = Effect->GetTechniqueByName( "tPlainColourMirror" );

	mov	esi, esp
	push	OFFSET ??_C@_0BD@EAMCFOMD@tPlainColourMirror?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24156]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24156]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+52]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+edx+24280], eax

; 685  : 	mTechniquesMirror[ 1] = Effect->GetTechniqueByName( "tPlainTextureMirror" );

	mov	esi, esp
	push	OFFSET ??_C@_0BE@GKDAAGPD@tPlainTextureMirror?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24156]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24156]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+52]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+24280], eax

; 686  : 	mTechniquesMirror[ 2] = Effect->GetTechniqueByName( "tColourChangeTextureMirror" );

	mov	esi, esp
	push	OFFSET ??_C@_0BL@BDPLHMPN@tColourChangeTextureMirror?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24156]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24156]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+52]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+24280], eax

; 687  : 	mTechniquesMirror[ 3] = Effect->GetTechniqueByName( "tLitTextureMirror" );

	mov	esi, esp
	push	OFFSET ??_C@_0BC@PLBJLENF@tLitTextureMirror?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24156]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24156]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+52]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, 4
	imul	edx, ecx, 3
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+edx+24280], eax

; 688  : 	mTechniquesMirror[ 4] = Effect->GetTechniqueByName( "t4LitTextureMirror" );

	mov	esi, esp
	push	OFFSET ??_C@_0BD@GNCBGOED@t4LitTextureMirror?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24156]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24156]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+52]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, 4
	shl	ecx, 2
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+24280], eax

; 689  : 	mTechniquesMirror[ 5] = Effect->GetTechniqueByName( "t4LitAttenTextureMirror" );

	mov	esi, esp
	push	OFFSET ??_C@_0BI@EEKKACMN@t4LitAttenTextureMirror?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24156]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24156]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+52]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, 4
	imul	edx, ecx, 5
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+edx+24280], eax

; 690  : 	mTechniquesMirror[ 6] = Effect->GetTechniqueByName( "t4LitSpecularMapMirror" );

	mov	esi, esp
	push	OFFSET ??_C@_0BH@MJFOIGI@t4LitSpecularMapMirror?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24156]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24156]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+52]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, 4
	imul	edx, ecx, 6
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+edx+24280], eax

; 691  : 	mTechniquesMirror[ 7] = Effect->GetTechniqueByName( "tParallaxMapMirror" );

	mov	esi, esp
	push	OFFSET ??_C@_0BD@CIMFECON@tParallaxMapMirror?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24156]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24156]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+52]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, 4
	imul	edx, ecx, 7
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+edx+24280], eax

; 692  : 	mTechniquesMirror[ 8] = Effect->GetTechniqueByName( "tJellyMirror" );

	mov	esi, esp
	push	OFFSET ??_C@_0N@KFADNAIL@tJellyMirror?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24156]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24156]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+52]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, 4
	shl	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+24280], eax

; 693  : 	mTechniquesMirror[ 9] = Effect->GetTechniqueByName( "tCellShadingMirror" );

	mov	esi, esp
	push	OFFSET ??_C@_0BD@NDCFMGPA@tCellShadingMirror?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24156]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24156]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+52]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, 4
	imul	edx, ecx, 9
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+edx+24280], eax

; 694  : 	mTechniquesMirror[10] = Effect->GetTechniqueByName( "tCellShadingWrongMirror" );

	mov	esi, esp
	push	OFFSET ??_C@_0BI@MCEONCDC@tCellShadingWrongMirror?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24156]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24156]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+52]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, 4
	imul	edx, ecx, 10
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+edx+24280], eax

; 695  : 	mTechniquesMirror[11] = Effect->GetTechniqueByName( "tHaloMirror" );

	mov	esi, esp
	push	OFFSET ??_C@_0M@FENFNCKC@tHaloMirror?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24156]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24156]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+52]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, 4
	imul	edx, ecx, 11
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+edx+24280], eax

; 696  : 	mTechniquesMirror[12] = Effect->GetTechniqueByName( "tSpaceHaloParaMirror" );

	mov	esi, esp
	push	OFFSET ??_C@_0BF@KFEJDHPA@tSpaceHaloParaMirror?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24156]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24156]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+52]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, 4
	imul	edx, ecx, 12
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+edx+24280], eax

; 697  : 	mTechniquesMirror[13] = Effect->GetTechniqueByName( "tSpaceOutlineParaMirror" );

	mov	esi, esp
	push	OFFSET ??_C@_0BI@GGPGLIH@tSpaceOutlineParaMirror?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24156]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24156]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+52]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, 4
	imul	edx, ecx, 13
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+edx+24280], eax

; 698  : 	mTechniquesMirror[14] = Effect->GetTechniqueByName( "tLitGlassMirror" );

	mov	esi, esp
	push	OFFSET ??_C@_0BA@BCLLKFIB@tLitGlassMirror?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24156]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24156]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+52]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, 4
	imul	edx, ecx, 14
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+edx+24280], eax

; 699  : 	mTechniquesMirror[15] = Effect->GetTechniqueByName( "tSpaceHaloMirror" );

	mov	esi, esp
	push	OFFSET ??_C@_0BB@CDMINDKK@tSpaceHaloMirror?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24156]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24156]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+52]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, 4
	imul	edx, ecx, 15
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+edx+24280], eax

; 700  : 	mTechniquesMirror[16] = Effect->GetTechniqueByName( "tSpaceOutlineMirror" );

	mov	esi, esp
	push	OFFSET ??_C@_0BE@CKKPKAMN@tSpaceOutlineMirror?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24156]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24156]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+52]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, 4
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+24280], eax

; 701  : 	mTechniquesMirror[17] = Effect->GetTechniqueByName( "tTextureMorphMirror" );

	mov	esi, esp
	push	OFFSET ??_C@_0BE@BLJDFMPB@tTextureMorphMirror?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24156]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24156]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+52]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, 4
	imul	edx, ecx, 17
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+edx+24280], eax

; 702  : 	mTechniquesMirror[18] = Effect->GetTechniqueByName( "MirrorClear" );

	mov	esi, esp
	push	OFFSET ??_C@_0M@NCEALFAM@MirrorClear?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24156]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24156]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+52]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, 4
	imul	edx, ecx, 18
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+edx+24280], eax

; 703  : 	mTechniquesMirror[19] = Effect->GetTechniqueByName( "MirrorSurface" );

	mov	esi, esp
	push	OFFSET ??_C@_0O@CFAHMOKA@MirrorSurface?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24156]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24156]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+52]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, 4
	imul	edx, ecx, 19
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+edx+24280], eax

; 704  : 
; 705  : 	// Create special variables to allow us to access global variables in the shaders from C++
; 706  : 	WorldMatrixVar		= Effect->GetVariableByName( "WorldMatrix" )->AsMatrix();

	mov	esi, esp
	push	OFFSET ??_C@_0M@JIFPIELG@WorldMatrix?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24156]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24156]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+40]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv656[ebp], eax
	mov	eax, DWORD PTR tv656[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	esi, esp
	mov	edx, DWORD PTR tv656[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+48]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24404], eax

; 707  : 	ViewMatrixVar		= Effect->GetVariableByName( "ViewMatrix"  )->AsMatrix();

	mov	esi, esp
	push	OFFSET ??_C@_0L@BCBAMPKD@ViewMatrix?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24156]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24156]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+40]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv671[ebp], eax
	mov	eax, DWORD PTR tv671[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	esi, esp
	mov	edx, DWORD PTR tv671[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+48]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24408], eax

; 708  : 	ProjMatrixVar		= Effect->GetVariableByName( "ProjMatrix"  )->AsMatrix();

	mov	esi, esp
	push	OFFSET ??_C@_0L@FHHLNBJL@ProjMatrix?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24156]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24156]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+40]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv686[ebp], eax
	mov	eax, DWORD PTR tv686[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	esi, esp
	mov	edx, DWORD PTR tv686[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+48]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24412], eax

; 709  : 
; 710  : 	// We access the texture variable in the shader in the same way as we have before for matrices, light data etc.
; 711  : 	// Only difference is that this variable is a "Shader Resource"
; 712  : 	DiffuseMapVar = Effect->GetVariableByName( "DiffuseMap" )->AsShaderResource();

	mov	esi, esp
	push	OFFSET ??_C@_0L@ILIGHKAJ@DiffuseMap?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24156]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24156]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+40]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv701[ebp], eax
	mov	eax, DWORD PTR tv701[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	esi, esp
	mov	edx, DWORD PTR tv701[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+56]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24420], eax

; 713  : 	NormalMapVar = Effect->GetVariableByName( "NormalMap" )->AsShaderResource();

	mov	esi, esp
	push	OFFSET ??_C@_09ILPGELJF@NormalMap?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24156]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24156]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+40]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv716[ebp], eax
	mov	eax, DWORD PTR tv716[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	esi, esp
	mov	edx, DWORD PTR tv716[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+56]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24424], eax

; 714  : 
; 715  : 	//Camera Position
; 716  : 	dxCameraPos = Effect->GetVariableByName( "cameraPos" )->AsVector();

	mov	esi, esp
	push	OFFSET ??_C@_09JBPBDAII@cameraPos?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24156]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24156]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+40]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv731[ebp], eax
	mov	eax, DWORD PTR tv731[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	esi, esp
	mov	edx, DWORD PTR tv731[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+44]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24436], eax

; 717  : 
; 718  : 	// Other shader variables
; 719  : 	ModelColourVar = Effect->GetVariableByName( "ModelColour"  )->AsVector();

	mov	esi, esp
	push	OFFSET ??_C@_0M@FMIDCGNI@ModelColour?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24156]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24156]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+40]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv746[ebp], eax
	mov	eax, DWORD PTR tv746[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	esi, esp
	mov	edx, DWORD PTR tv746[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+44]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24428], eax

; 720  : 
; 721  : 	//Lighting Values
; 722  : 	dxLightPosA = Effect->GetVariableByName( "lightPos" )->AsVector();

	mov	esi, esp
	push	OFFSET ??_C@_08EGHFDCKI@lightPos?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24156]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24156]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+40]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv761[ebp], eax
	mov	eax, DWORD PTR tv761[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	esi, esp
	mov	edx, DWORD PTR tv761[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+44]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24432], eax

; 723  : 	dxLightColourA = Effect->GetVariableByName( "lightColour" )->AsVector();

	mov	esi, esp
	push	OFFSET ??_C@_0M@ICIEANMG@lightColour?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24156]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24156]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+40]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv776[ebp], eax
	mov	eax, DWORD PTR tv776[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	esi, esp
	mov	edx, DWORD PTR tv776[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+44]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24440], eax

; 724  : 	dxLightBrightnessA = Effect->GetVariableByName( "lightBright" )->AsVector();

	mov	esi, esp
	push	OFFSET ??_C@_0M@NEELCHAN@lightBright?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24156]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24156]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+40]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv794[ebp], eax
	mov	eax, DWORD PTR tv794[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	esi, esp
	mov	edx, DWORD PTR tv794[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+44]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24448], eax

; 725  : 	
; 726  : 	dxAmbientColour = Effect->GetVariableByName( "ambientColour" )->AsVector();

	mov	esi, esp
	push	OFFSET ??_C@_0O@OODJBMLI@ambientColour?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24156]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24156]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+40]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv810[ebp], eax
	mov	eax, DWORD PTR tv810[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	esi, esp
	mov	edx, DWORD PTR tv810[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+44]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24444], eax

; 727  : 
; 728  : 	dxWiggle = Effect->GetVariableByName( "wiggle" )->AsScalar();

	mov	esi, esp
	push	OFFSET ??_C@_06LAADFJPH@wiggle?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24156]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24156]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+40]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv828[ebp], eax
	mov	eax, DWORD PTR tv828[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	esi, esp
	mov	edx, DWORD PTR tv828[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+40]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24452], eax

; 729  : 	dxOutlineThickness = Effect->GetVariableByName( "OutlineThickness" )->AsScalar();

	mov	esi, esp
	push	OFFSET ??_C@_0BB@HDLHOHKD@OutlineThickness?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24156]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24156]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+40]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv847[ebp], eax
	mov	eax, DWORD PTR tv847[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	esi, esp
	mov	edx, DWORD PTR tv847[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+40]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24456], eax

; 730  : 
; 731  : 	ClipPlaneVar      = Effect->GetVariableByName( "ClipPlane"      )->AsVector();

	mov	esi, esp
	push	OFFSET ??_C@_09HJHGEJDE@ClipPlane?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24156]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24156]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+40]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv863[ebp], eax
	mov	eax, DWORD PTR tv863[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	esi, esp
	mov	edx, DWORD PTR tv863[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+44]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24460], eax

; 732  : 
; 733  : 	return true;

	mov	al, 1
$LN4@LoadEffect:

; 734  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN9@LoadEffect
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 516				; 00000204H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@LoadEffect:
	DD	1
	DD	$LN8@LoadEffect
$LN8@LoadEffect:
	DD	-24					; ffffffe8H
	DD	4
	DD	$LN7@LoadEffect
$LN7@LoadEffect:
	DB	112					; 00000070H
	DB	69					; 00000045H
	DB	114					; 00000072H
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	115					; 00000073H
	DB	0
?LoadEffectFile@CScene@@QAE_NXZ ENDP			; CScene::LoadEffectFile
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\game-of-life\scene.cpp
;	COMDAT ?ReleaseResources@CScene@@QAEXXZ
_TEXT	SEGMENT
tv128 = -304						; size = 4
tv85 = -304						; size = 4
$T1 = -296						; size = 4
$T2 = -284						; size = 4
$T3 = -272						; size = 4
$T4 = -260						; size = 4
$T5 = -248						; size = 4
_i$6 = -44						; size = 4
_i$7 = -32						; size = 4
_i$8 = -20						; size = 4
_this$ = -8						; size = 4
?ReleaseResources@CScene@@QAEXXZ PROC			; CScene::ReleaseResources, COMDAT
; _this$ = ecx

; 602  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 304				; 00000130H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-304]
	mov	ecx, 76					; 0000004cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 603  : 	// The D3D setup and preparation of the geometry created several objects that use up memory (e.g. textures, vertex/index buffers etc.)
; 604  : 	// Each object that allocates memory (or hardware resources) needs to be "released" when we exit the program
; 605  : 	// There is similar code in every D3D program, but the list of objects that need to be released depends on what was created
; 606  : 	// Test each variable to see if it exists before deletion
; 607  : 	if( mpd3dDevice )     mpd3dDevice->ClearState();

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN17@ReleaseRes
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx]
	mov	esi, esp
	push	eax
	mov	edx, DWORD PTR [ecx+276]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN17@ReleaseRes:

; 608  : 
; 609  : 	delete Camera;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 610  : 
; 611  : 	for(int i = 0; i < miNumObjects; i++)

	mov	DWORD PTR _i$8[ebp], 0
	jmp	SHORT $LN16@ReleaseRes
$LN15@ReleaseRes:
	mov	eax, DWORD PTR _i$8[ebp]
	add	eax, 1
	mov	DWORD PTR _i$8[ebp], eax
$LN16@ReleaseRes:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$8[ebp]
	cmp	ecx, DWORD PTR [eax+8008]
	jge	SHORT $LN14@ReleaseRes

; 612  : 	{
; 613  : 		delete mpObjects[i];

	mov	eax, DWORD PTR _i$8[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+8]
	mov	DWORD PTR $T3[ebp], edx
	mov	eax, DWORD PTR $T3[ebp]
	mov	DWORD PTR $T2[ebp], eax
	cmp	DWORD PTR $T2[ebp], 0
	je	SHORT $LN20@ReleaseRes
	push	1
	mov	ecx, DWORD PTR $T2[ebp]
	call	??_GCRenderObject@@QAEPAXI@Z
	mov	DWORD PTR tv85[ebp], eax
	jmp	SHORT $LN21@ReleaseRes
$LN20@ReleaseRes:
	mov	DWORD PTR tv85[ebp], 0
$LN21@ReleaseRes:

; 614  : 	}

	jmp	SHORT $LN15@ReleaseRes
$LN14@ReleaseRes:

; 615  : 
; 616  : 	for(int i = 0; i < miNumLights; i++)

	mov	DWORD PTR _i$7[ebp], 0
	jmp	SHORT $LN13@ReleaseRes
$LN12@ReleaseRes:
	mov	eax, DWORD PTR _i$7[ebp]
	add	eax, 1
	mov	DWORD PTR _i$7[ebp], eax
$LN13@ReleaseRes:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$7[ebp]
	cmp	ecx, DWORD PTR [eax+8132]
	jge	SHORT $LN11@ReleaseRes

; 617  : 	{
; 618  : 		delete mpLights[i];

	mov	eax, DWORD PTR _i$7[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+8012]
	mov	DWORD PTR $T5[ebp], edx
	mov	eax, DWORD PTR $T5[ebp]
	mov	DWORD PTR $T4[ebp], eax
	cmp	DWORD PTR $T4[ebp], 0
	je	SHORT $LN22@ReleaseRes
	push	1
	mov	ecx, DWORD PTR $T4[ebp]
	call	??_GCLight@@QAEPAXI@Z
	mov	DWORD PTR tv128[ebp], eax
	jmp	SHORT $LN23@ReleaseRes
$LN22@ReleaseRes:
	mov	DWORD PTR tv128[ebp], 0
$LN23@ReleaseRes:

; 619  : 	}

	jmp	SHORT $LN12@ReleaseRes
$LN11@ReleaseRes:

; 620  : 	
; 621  : 	for(int i = 0; i < miNumMaps; i++)

	mov	DWORD PTR _i$6[ebp], 0
	jmp	SHORT $LN10@ReleaseRes
$LN9@ReleaseRes:
	mov	eax, DWORD PTR _i$6[ebp]
	add	eax, 1
	mov	DWORD PTR _i$6[ebp], eax
$LN10@ReleaseRes:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$6[ebp]
	cmp	ecx, DWORD PTR [eax+24136]
	jge	SHORT $LN8@ReleaseRes

; 622  : 	{
; 623  : 		if ( mpMaps[i] )

	mov	eax, DWORD PTR _i$6[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+eax*4+8136], 0
	je	SHORT $LN7@ReleaseRes

; 624  : 			mpMaps[i]->Release();

	mov	eax, DWORD PTR _i$6[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+8136]
	mov	eax, DWORD PTR _i$6[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+eax*4+8136]
	mov	ecx, DWORD PTR [edx]
	mov	esi, esp
	push	eax
	mov	edx, DWORD PTR [ecx+8]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN7@ReleaseRes:

; 625  : 	}

	jmp	SHORT $LN9@ReleaseRes
$LN8@ReleaseRes:

; 626  : 
; 627  : 	if( Effect )           Effect->Release();

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24156], 0
	je	SHORT $LN6@ReleaseRes
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24156]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24156]
	mov	ecx, DWORD PTR [ecx]
	mov	esi, esp
	push	eax
	mov	edx, DWORD PTR [ecx+8]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN6@ReleaseRes:

; 628  : 	if( DepthStencilView ) DepthStencilView->Release();

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24472], 0
	je	SHORT $LN5@ReleaseRes
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24472]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24472]
	mov	ecx, DWORD PTR [ecx]
	mov	esi, esp
	push	eax
	mov	edx, DWORD PTR [ecx+8]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN5@ReleaseRes:

; 629  : 	if( RenderTargetView ) RenderTargetView->Release();

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24476], 0
	je	SHORT $LN4@ReleaseRes
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24476]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24476]
	mov	ecx, DWORD PTR [ecx]
	mov	esi, esp
	push	eax
	mov	edx, DWORD PTR [ecx+8]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN4@ReleaseRes:

; 630  : 	if( DepthStencil )     DepthStencil->Release();

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24468], 0
	je	SHORT $LN3@ReleaseRes
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24468]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24468]
	mov	ecx, DWORD PTR [ecx]
	mov	esi, esp
	push	eax
	mov	edx, DWORD PTR [ecx+8]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@ReleaseRes:

; 631  : 	if( SwapChain )        SwapChain->Release();

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24464], 0
	je	SHORT $LN2@ReleaseRes
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24464]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24464]
	mov	ecx, DWORD PTR [ecx]
	mov	esi, esp
	push	eax
	mov	edx, DWORD PTR [ecx+8]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@ReleaseRes:

; 632  : 	if( mpd3dDevice )     mpd3dDevice->Release();

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN18@ReleaseRes
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx]
	mov	esi, esp
	push	eax
	mov	edx, DWORD PTR [ecx+8]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN18@ReleaseRes:

; 633  : 
; 634  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 304				; 00000130H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?ReleaseResources@CScene@@QAEXXZ ENDP			; CScene::ReleaseResources
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\game-of-life\scene.cpp
;	COMDAT ?InitDevice@CScene@@QAE_NXZ
_TEXT	SEGMENT
_vp$ = -240						; size = 24
_descDSV$ = -208					; size = 20
_descDepth$ = -180					; size = 44
_pBackBuffer$ = -128					; size = 4
_sd$ = -116						; size = 60
_rc$ = -48						; size = 16
_hr$ = -24						; size = 4
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
?InitDevice@CScene@@QAE_NXZ PROC			; CScene::InitDevice, COMDAT
; _this$ = ecx

; 505  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 436				; 000001b4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-436]
	mov	ecx, 109				; 0000006dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 506  : 	// Many DirectX functions return a "HRESULT" variable to indicate success or failure. Microsoft code often uses
; 507  : 	// the FAILED macro to test this variable, you'll see it throughout the code - it's fairly self explanatory.
; 508  : 	HRESULT hr = S_OK;

	mov	DWORD PTR _hr$[ebp], 0

; 509  : 
; 510  : 
; 511  : 	////////////////////////////////
; 512  : 	// Initialise Direct3D
; 513  : 
; 514  : 	// Calculate the visible area the window we are using - the "client rectangle" refered to in the first function is the 
; 515  : 	// size of the interior of the window, i.e. excluding the frame and title
; 516  : 	RECT rc;
; 517  : 	GetClientRect( HWnd, &rc );

	mov	esi, esp
	lea	eax, DWORD PTR _rc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24484]
	push	edx
	call	DWORD PTR __imp__GetClientRect@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 518  : 	mViewportWidth = rc.right - rc.left;

	mov	eax, DWORD PTR _rc$[ebp+8]
	sub	eax, DWORD PTR _rc$[ebp]
	mov	DWORD PTR ?mViewportWidth@CScene@@0HA, eax ; CScene::mViewportWidth

; 519  : 	mViewportHeight = rc.bottom - rc.top;

	mov	eax, DWORD PTR _rc$[ebp+12]
	sub	eax, DWORD PTR _rc$[ebp+4]
	mov	DWORD PTR ?mViewportHeight@CScene@@0HA, eax ; CScene::mViewportHeight

; 520  : 
; 521  : 
; 522  : 	// Create a Direct3D device (i.e. initialise D3D), and create a swap-chain (create a back buffer to render to)
; 523  : 	DXGI_SWAP_CHAIN_DESC sd;         // Structure to contain all the information needed
; 524  : 	ZeroMemory( &sd, sizeof( sd ) ); // Clear the structure to 0 - common Microsoft practice, not really good style

	push	60					; 0000003cH
	push	0
	lea	eax, DWORD PTR _sd$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 525  : 	sd.BufferCount = 1;

	mov	DWORD PTR _sd$[ebp+40], 1

; 526  : 	sd.BufferDesc.Width = mViewportWidth;             // Target window size

	mov	eax, DWORD PTR ?mViewportWidth@CScene@@0HA ; CScene::mViewportWidth
	mov	DWORD PTR _sd$[ebp], eax

; 527  : 	sd.BufferDesc.Height = mViewportHeight;           // --"--

	mov	eax, DWORD PTR ?mViewportHeight@CScene@@0HA ; CScene::mViewportHeight
	mov	DWORD PTR _sd$[ebp+4], eax

; 528  : 	sd.BufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM; // Pixel format of target window

	mov	DWORD PTR _sd$[ebp+16], 28		; 0000001cH

; 529  : 	sd.BufferDesc.RefreshRate.Numerator = 60;          // Refresh rate of monitor

	mov	DWORD PTR _sd$[ebp+8], 60		; 0000003cH

; 530  : 	sd.BufferDesc.RefreshRate.Denominator = 1;         // --"--

	mov	DWORD PTR _sd$[ebp+12], 1

; 531  : 	sd.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;

	mov	DWORD PTR _sd$[ebp+36], 32		; 00000020H

; 532  : 	sd.SampleDesc.Count = 1;

	mov	DWORD PTR _sd$[ebp+28], 1

; 533  : 	sd.SampleDesc.Quality = 0;

	mov	DWORD PTR _sd$[ebp+32], 0

; 534  : 	sd.OutputWindow = HWnd;                          // Target window

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24484]
	mov	DWORD PTR _sd$[ebp+44], ecx

; 535  : 	sd.Windowed = TRUE;                                // Whether to render in a window (TRUE) or go fullscreen (FALSE)

	mov	DWORD PTR _sd$[ebp+48], 1

; 536  : 	hr = D3D10CreateDeviceAndSwapChain( NULL, D3D10_DRIVER_TYPE_HARDWARE, NULL, 2,
; 537  : 										D3D10_SDK_VERSION, &sd, &SwapChain, &mpd3dDevice );

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24464				; 00005f90H
	push	ecx
	lea	edx, DWORD PTR _sd$[ebp]
	push	edx
	push	29					; 0000001dH
	push	2
	push	0
	push	0
	push	0
	call	_D3D10CreateDeviceAndSwapChain@32
	mov	DWORD PTR _hr$[ebp], eax

; 538  : 	if( FAILED( hr ) ) return false;

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $LN5@InitDevice
	xor	al, al
	jmp	$LN6@InitDevice
$LN5@InitDevice:

; 539  : 
; 540  : 
; 541  : 	// Specify the render target as the back-buffer - this is an advanced topic. This code almost always occurs in the standard D3D setup
; 542  : 	ID3D10Texture2D* pBackBuffer;
; 543  : 	hr = SwapChain->GetBuffer( 0, __uuidof( ID3D10Texture2D ), ( LPVOID* )&pBackBuffer );

	mov	esi, esp
	lea	eax, DWORD PTR _pBackBuffer$[ebp]
	push	eax
	push	OFFSET __GUID_9b7e4c04_342c_4106_a19f_4f2704f689f0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24464]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24464]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+36]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax

; 544  : 	if( FAILED( hr ) ) return false;

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $LN4@InitDevice
	xor	al, al
	jmp	$LN6@InitDevice
$LN4@InitDevice:

; 545  : 	hr = mpd3dDevice->CreateRenderTargetView( pBackBuffer, NULL, &RenderTargetView );

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 24476				; 00005f9cH
	mov	esi, esp
	push	eax
	push	0
	mov	ecx, DWORD PTR _pBackBuffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+304]
	call	ecx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax

; 546  : 	pBackBuffer->Release();

	mov	eax, DWORD PTR _pBackBuffer$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	esi, esp
	mov	edx, DWORD PTR _pBackBuffer$[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+8]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 547  : 	if( FAILED( hr ) ) return false;

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $LN3@InitDevice
	xor	al, al
	jmp	$LN6@InitDevice
$LN3@InitDevice:

; 548  : 
; 549  : 
; 550  : 	// Create a texture (bitmap) to use for a depth buffer
; 551  : 	D3D10_TEXTURE2D_DESC descDepth;
; 552  : 	descDepth.Width = mViewportWidth;

	mov	eax, DWORD PTR ?mViewportWidth@CScene@@0HA ; CScene::mViewportWidth
	mov	DWORD PTR _descDepth$[ebp], eax

; 553  : 	descDepth.Height = mViewportHeight;

	mov	eax, DWORD PTR ?mViewportHeight@CScene@@0HA ; CScene::mViewportHeight
	mov	DWORD PTR _descDepth$[ebp+4], eax

; 554  : 	descDepth.MipLevels = 1;

	mov	DWORD PTR _descDepth$[ebp+8], 1

; 555  : 	descDepth.ArraySize = 1;

	mov	DWORD PTR _descDepth$[ebp+12], 1

; 556  : 	descDepth.Format = DXGI_FORMAT_D24_UNORM_S8_UINT;		// 24 bits for depth, 8 for stencil - more memory efficient

	mov	DWORD PTR _descDepth$[ebp+16], 45	; 0000002dH

; 557  : 	//descDepth.Format = DXGI_FORMAT_D32_FLOAT;				// 32 bit float depth only 
; 558  : 	//descDepth.Format = DXGI_FORMAT_D32_FLOAT_S8X24_UINT;	// 32 bit depth + 8 for stencil, 24 unused bytes - more precise depth buffer
; 559  : 	descDepth.SampleDesc.Count = 1;

	mov	DWORD PTR _descDepth$[ebp+20], 1

; 560  : 	descDepth.SampleDesc.Quality = 0;

	mov	DWORD PTR _descDepth$[ebp+24], 0

; 561  : 	descDepth.Usage = D3D10_USAGE_DEFAULT;

	mov	DWORD PTR _descDepth$[ebp+28], 0

; 562  : 	descDepth.BindFlags = D3D10_BIND_DEPTH_STENCIL;

	mov	DWORD PTR _descDepth$[ebp+32], 64	; 00000040H

; 563  : 	descDepth.CPUAccessFlags = 0;

	mov	DWORD PTR _descDepth$[ebp+36], 0

; 564  : 	descDepth.MiscFlags = 0;

	mov	DWORD PTR _descDepth$[ebp+40], 0

; 565  : 	hr = mpd3dDevice->CreateTexture2D( &descDepth, NULL, &DepthStencil );

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 24468				; 00005f94H
	mov	esi, esp
	push	eax
	push	0
	lea	ecx, DWORD PTR _descDepth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+292]
	call	ecx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax

; 566  : 	if( FAILED( hr ) ) return false;

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $LN2@InitDevice
	xor	al, al
	jmp	$LN6@InitDevice
$LN2@InitDevice:

; 567  : 
; 568  : 	// Create the depth stencil view, i.e. indicate that the texture just created is to be used as a depth buffer
; 569  : 	D3D10_DEPTH_STENCIL_VIEW_DESC descDSV;
; 570  : 	descDSV.Format = descDepth.Format;

	mov	eax, DWORD PTR _descDepth$[ebp+16]
	mov	DWORD PTR _descDSV$[ebp], eax

; 571  : 	descDSV.ViewDimension = D3D10_DSV_DIMENSION_TEXTURE2D;

	mov	DWORD PTR _descDSV$[ebp+4], 3

; 572  : 	descDSV.Texture2D.MipSlice = 0;

	mov	DWORD PTR _descDSV$[ebp+8], 0

; 573  : 	hr = mpd3dDevice->CreateDepthStencilView( DepthStencil, &descDSV, &DepthStencilView );

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 24472				; 00005f98H
	mov	esi, esp
	push	eax
	lea	ecx, DWORD PTR _descDSV$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24468]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+308]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax

; 574  : 	if( FAILED( hr ) ) return false;

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $LN1@InitDevice
	xor	al, al
	jmp	$LN6@InitDevice
$LN1@InitDevice:

; 575  : 
; 576  : 	// Select the back buffer and depth buffer to use for rendering now
; 577  : 	mpd3dDevice->OMSetRenderTargets( 1, &RenderTargetView, DepthStencilView );

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24472]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 24476				; 00005f9cH
	push	edx
	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+96]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 578  : 
; 579  : 
; 580  : 	// Setup the viewport - defines which part of the window we will render to, almost always the whole window
; 581  : 	D3D10_VIEWPORT vp;
; 582  : 	vp.Width  = mViewportWidth;

	mov	eax, DWORD PTR ?mViewportWidth@CScene@@0HA ; CScene::mViewportWidth
	mov	DWORD PTR _vp$[ebp+8], eax

; 583  : 	vp.Height = mViewportHeight;

	mov	eax, DWORD PTR ?mViewportHeight@CScene@@0HA ; CScene::mViewportHeight
	mov	DWORD PTR _vp$[ebp+12], eax

; 584  : 	vp.MinDepth = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _vp$[ebp+16], xmm0

; 585  : 	vp.MaxDepth = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _vp$[ebp+20], xmm0

; 586  : 	vp.TopLeftX = 0;

	mov	DWORD PTR _vp$[ebp], 0

; 587  : 	vp.TopLeftY = 0;

	mov	DWORD PTR _vp$[ebp+4], 0

; 588  : 	mpd3dDevice->RSSetViewports( 1, &vp );

	mov	esi, esp
	lea	eax, DWORD PTR _vp$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+120]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 589  : 
; 590  : 	CCamera::SetViewport( mViewportWidth, mViewportHeight );

	mov	eax, DWORD PTR ?mViewportHeight@CScene@@0HA ; CScene::mViewportHeight
	push	eax
	mov	ecx, DWORD PTR ?mViewportWidth@CScene@@0HA ; CScene::mViewportWidth
	push	ecx
	call	?SetViewport@CCamera@@SAXHH@Z		; CCamera::SetViewport
	add	esp, 8

; 591  : 	
; 592  : 	CModel::SetDevice( mpd3dDevice );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?SetDevice@CModel@@SAXPAUID3D10Device@@@Z ; CModel::SetDevice
	add	esp, 4

; 593  : 
; 594  : 	//test->SetDevice( mpd3dDevice );
; 595  : 
; 596  : 	return true;

	mov	al, 1
$LN6@InitDevice:

; 597  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN15@InitDevice
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 436				; 000001b4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN15@InitDevice:
	DD	6
	DD	$LN14@InitDevice
$LN14@InitDevice:
	DD	-48					; ffffffd0H
	DD	16					; 00000010H
	DD	$LN8@InitDevice
	DD	-116					; ffffff8cH
	DD	60					; 0000003cH
	DD	$LN9@InitDevice
	DD	-128					; ffffff80H
	DD	4
	DD	$LN10@InitDevice
	DD	-180					; ffffff4cH
	DD	44					; 0000002cH
	DD	$LN11@InitDevice
	DD	-208					; ffffff30H
	DD	20					; 00000014H
	DD	$LN12@InitDevice
	DD	-240					; ffffff10H
	DD	24					; 00000018H
	DD	$LN13@InitDevice
$LN13@InitDevice:
	DB	118					; 00000076H
	DB	112					; 00000070H
	DB	0
$LN12@InitDevice:
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	99					; 00000063H
	DB	68					; 00000044H
	DB	83					; 00000053H
	DB	86					; 00000056H
	DB	0
$LN11@InitDevice:
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	99					; 00000063H
	DB	68					; 00000044H
	DB	101					; 00000065H
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	104					; 00000068H
	DB	0
$LN10@InitDevice:
	DB	112					; 00000070H
	DB	66					; 00000042H
	DB	97					; 00000061H
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	66					; 00000042H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	102					; 00000066H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
$LN9@InitDevice:
	DB	115					; 00000073H
	DB	100					; 00000064H
	DB	0
$LN8@InitDevice:
	DB	114					; 00000072H
	DB	99					; 00000063H
	DB	0
?InitDevice@CScene@@QAE_NXZ ENDP			; CScene::InitDevice
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\game-of-life\scene.cpp
;	COMDAT ??1CScene@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1CScene@@QAE@XZ PROC					; CScene::~CScene, COMDAT
; _this$ = ecx

; 21   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 22   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1CScene@@QAE@XZ ENDP					; CScene::~CScene
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\game-of-life\scene.cpp
;	COMDAT ??0CScene@@QAE@XZ
_TEXT	SEGMENT
$T1 = -224						; size = 12
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
??0CScene@@QAE@XZ PROC					; CScene::CScene, COMDAT
; _this$ = ecx

; 6    : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24140				; 00005e4cH
	call	??0D3DXVECTOR3@@QAE@XZ			; D3DXVECTOR3::D3DXVECTOR3

; 7    : 	//set counters to 0
; 8    : 	miNumObjects = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8008], 0

; 9    : 	miNumLights = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8132], 0

; 10   : 	miNumMaps = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24136], 0

; 11   : 
; 12   : 	//set the ambient colour for the scene
; 13   : 	AmbientColour = D3DXVECTOR3( 0.2f, 0.2f, 0.2f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3e4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3e4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3e4ccccd
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0D3DXVECTOR3@@QAE@MMM@Z		; D3DXVECTOR3::D3DXVECTOR3
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24140				; 00005e4cH
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 14   : 
; 15   : 	//set the controlled object to the mirror
; 16   : 	mControlObject = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24152], 0

; 17   : 
; 18   : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0CScene@@QAE@XZ ENDP					; CScene::CScene
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\game-of-life\scene.cpp
;	COMDAT ?DrawAllObjects@CScene@@AAEX_N@Z
_TEXT	SEGMENT
$T1 = -332						; size = 64
_i$2 = -68						; size = 4
_mColour$3 = -56					; size = 12
_i$4 = -36						; size = 4
_i$5 = -24						; size = 4
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_mirror$ = 8						; size = 1
?DrawAllObjects@CScene@@AAEX_N@Z PROC			; CScene::DrawAllObjects, COMDAT
; _this$ = ecx

; 275  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 336				; 00000150H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-336]
	mov	ecx, 84					; 00000054H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 276  : 	//
; 277  : 	// Solid objects
; 278  : 	//
; 279  : 	//start rendering AFTER the mirror.
; 280  : 	for(int i = 1; i < miNumObjects; i++)

	mov	DWORD PTR _i$5[ebp], 1
	jmp	SHORT $LN13@DrawAllObj
$LN12@DrawAllObj:
	mov	eax, DWORD PTR _i$5[ebp]
	add	eax, 1
	mov	DWORD PTR _i$5[ebp], eax
$LN13@DrawAllObj:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$5[ebp]
	cmp	ecx, DWORD PTR [eax+8008]
	jge	SHORT $LN11@DrawAllObj

; 281  : 	{
; 282  : 		if( !mpObjects[i]->IsTransparent() )

	mov	eax, DWORD PTR _i$5[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4+8]
	call	?IsTransparent@CRenderObject@@QAE_NXZ	; CRenderObject::IsTransparent
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN10@DrawAllObj

; 283  : 		{
; 284  : 			DrawObject(i, mirror);

	movzx	eax, BYTE PTR _mirror$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$5[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawObject@CScene@@AAEXH_N@Z		; CScene::DrawObject
$LN10@DrawAllObj:

; 285  : 		}
; 286  : 	}

	jmp	SHORT $LN12@DrawAllObj
$LN11@DrawAllObj:

; 287  : 
; 288  : 	//
; 289  : 	// Light objects
; 290  : 	//
; 291  : 
; 292  : 
; 293  : 	for(int i = 0; i < miNumLights; i++)

	mov	DWORD PTR _i$4[ebp], 0
	jmp	SHORT $LN9@DrawAllObj
$LN8@DrawAllObj:
	mov	eax, DWORD PTR _i$4[ebp]
	add	eax, 1
	mov	DWORD PTR _i$4[ebp], eax
$LN9@DrawAllObj:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$4[ebp]
	cmp	ecx, DWORD PTR [eax+8132]
	jge	$LN7@DrawAllObj

; 294  : 	{
; 295  : 		WorldMatrixVar->SetMatrix( (float*)mpLights[i]->GetModel()->GetWorldMatrix() );

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$4[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+8012]
	call	?GetModel@CLight@@QAEPAVCModel@@XZ	; CLight::GetModel
	mov	ecx, eax
	call	?GetWorldMatrix@CModel@@QAE?AU_D3DXMATRIXA16@@XZ ; CModel::GetWorldMatrix
	mov	ecx, eax
	call	??BD3DXMATRIX@@QAEPAMXZ			; D3DXMATRIX::operator float *
	mov	esi, esp
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24404]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24404]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+100]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 296  : 		D3DXVECTOR3 mColour =  mpLights[i]->GetColourV();

	lea	eax, DWORD PTR _mColour$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$4[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+8012]
	call	?GetColourV@CLight@@QAE?AUD3DXVECTOR3@@XZ ; CLight::GetColourV

; 297  : 		ModelColourVar->SetRawValue(mColour, 0, 12 );

	mov	esi, esp
	push	12					; 0000000cH
	push	0
	lea	ecx, DWORD PTR _mColour$3[ebp]
	call	??BD3DXVECTOR3@@QAEPAMXZ		; D3DXVECTOR3::operator float *
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24428]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24428]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+92]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 298  : 		if( mirror )

	movzx	eax, BYTE PTR _mirror$[ebp]
	test	eax, eax
	je	SHORT $LN6@DrawAllObj

; 299  : 		{
; 300  : 			mpLights[i]->GetModel()->Render( mTechniquesMirror[0] );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+24280]
	push	eax
	mov	ecx, DWORD PTR _i$4[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+8012]
	call	?GetModel@CLight@@QAEPAVCModel@@XZ	; CLight::GetModel
	mov	ecx, eax
	call	?Render@CModel@@QAEXPAUID3D10EffectTechnique@@@Z ; CModel::Render

; 301  : 		}
; 302  : 		else

	jmp	SHORT $LN5@DrawAllObj
$LN6@DrawAllObj:

; 303  : 		{
; 304  : 			mpLights[i]->GetModel()->Render( mTechniques[0] );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+24160]
	push	eax
	mov	ecx, DWORD PTR _i$4[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+8012]
	call	?GetModel@CLight@@QAEPAVCModel@@XZ	; CLight::GetModel
	mov	ecx, eax
	call	?Render@CModel@@QAEXPAUID3D10EffectTechnique@@@Z ; CModel::Render
$LN5@DrawAllObj:

; 305  : 		}
; 306  : 	}

	jmp	$LN8@DrawAllObj
$LN7@DrawAllObj:

; 307  : 
; 308  : 	//
; 309  : 	// Transparent objects
; 310  : 	//
; 311  : 
; 312  : 	for(int i = 1; i < miNumObjects; i++)

	mov	DWORD PTR _i$2[ebp], 1
	jmp	SHORT $LN4@DrawAllObj
$LN3@DrawAllObj:
	mov	eax, DWORD PTR _i$2[ebp]
	add	eax, 1
	mov	DWORD PTR _i$2[ebp], eax
$LN4@DrawAllObj:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$2[ebp]
	cmp	ecx, DWORD PTR [eax+8008]
	jge	SHORT $LN14@DrawAllObj

; 313  : 	{
; 314  : 		if( mpObjects[i]->IsTransparent() )

	mov	eax, DWORD PTR _i$2[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4+8]
	call	?IsTransparent@CRenderObject@@QAE_NXZ	; CRenderObject::IsTransparent
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN1@DrawAllObj

; 315  : 		{
; 316  : 			DrawObject(i, mirror);

	movzx	eax, BYTE PTR _mirror$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawObject@CScene@@AAEXH_N@Z		; CScene::DrawObject
$LN1@DrawAllObj:

; 317  : 		}
; 318  : 	}

	jmp	SHORT $LN3@DrawAllObj
$LN14@DrawAllObj:

; 319  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN18@DrawAllObj
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 336				; 00000150H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
$LN18@DrawAllObj:
	DD	1
	DD	$LN17@DrawAllObj
$LN17@DrawAllObj:
	DD	-56					; ffffffc8H
	DD	12					; 0000000cH
	DD	$LN16@DrawAllObj
$LN16@DrawAllObj:
	DB	109					; 0000006dH
	DB	67					; 00000043H
	DB	111					; 0000006fH
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	114					; 00000072H
	DB	0
?DrawAllObjects@CScene@@AAEX_N@Z ENDP			; CScene::DrawAllObjects
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\game-of-life\scene.cpp
;	COMDAT ?DrawObject@CScene@@AAEXH_N@Z
_TEXT	SEGMENT
$T1 = -340						; size = 64
$T2 = -268						; size = 12
$T3 = -248						; size = 12
_thickness$ = -36					; size = 4
_wiggle$ = -24						; size = 4
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_i$ = 8							; size = 4
_mirror$ = 12						; size = 1
?DrawObject@CScene@@AAEXH_N@Z PROC			; CScene::DrawObject, COMDAT
; _this$ = ecx

; 230  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 344				; 00000158H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-344]
	mov	ecx, 86					; 00000056H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 231  : 	//first the wiggle value
; 232  : 	float wiggle =  mpObjects[i]->GetWiggle();

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4+8]
	call	?GetWiggle@CRenderObject@@QAEMXZ	; CRenderObject::GetWiggle
	fstp	DWORD PTR _wiggle$[ebp]

; 233  : 	dxWiggle->SetRawValue( &wiggle, 0, 4);

	mov	esi, esp
	push	4
	push	0
	lea	eax, DWORD PTR _wiggle$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24452]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24452]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+92]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 234  : 
; 235  : 	//outline thickness
; 236  : 	float thickness = mpObjects[i]->GetOutlineThickness();

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4+8]
	call	?GetOutlineThickness@CRenderObject@@QAEMXZ ; CRenderObject::GetOutlineThickness
	fstp	DWORD PTR _thickness$[ebp]

; 237  : 	dxOutlineThickness->SetRawValue( &thickness, 0, 4);

	mov	esi, esp
	push	4
	push	0
	lea	eax, DWORD PTR _thickness$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24456]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24456]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+92]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 238  : 
; 239  : 	//pass the matrix
; 240  : 	WorldMatrixVar->SetMatrix( (float*)mpObjects[i]->GetModel()->GetWorldMatrix() );

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+8]
	call	?GetModel@CRenderObject@@QAEPAVCModel@@XZ ; CRenderObject::GetModel
	mov	ecx, eax
	call	?GetWorldMatrix@CModel@@QAE?AU_D3DXMATRIXA16@@XZ ; CModel::GetWorldMatrix
	mov	ecx, eax
	call	??BD3DXMATRIX@@QAEPAMXZ			; D3DXMATRIX::operator float *
	mov	esi, esp
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24404]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24404]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+100]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 241  : 	
; 242  : 	//pass the textures and maps, if there are any. 
; 243  : 	if( mpObjects[i]->GetTexture() != nullptr )

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4+8]
	call	?GetTexture@CRenderObject@@QAEPAUID3D10ShaderResourceView@@XZ ; CRenderObject::GetTexture
	test	eax, eax
	je	SHORT $LN5@DrawObject

; 244  : 	{
; 245  : 		DiffuseMapVar->SetResource( mpObjects[i]->GetTexture() );

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4+8]
	call	?GetTexture@CRenderObject@@QAEPAUID3D10ShaderResourceView@@XZ ; CRenderObject::GetTexture
	mov	esi, esp
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24420]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24420]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+100]
	call	ecx
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN5@DrawObject:

; 246  : 	}
; 247  : 	if( mpObjects[i]->GetNormalMap() != nullptr )

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4+8]
	call	?GetNormalMap@CRenderObject@@QAEPAUID3D10ShaderResourceView@@XZ ; CRenderObject::GetNormalMap
	test	eax, eax
	je	SHORT $LN4@DrawObject

; 248  : 	{
; 249  : 		NormalMapVar->SetResource( mpObjects[i]->GetNormalMap() );

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4+8]
	call	?GetNormalMap@CRenderObject@@QAEPAUID3D10ShaderResourceView@@XZ ; CRenderObject::GetNormalMap
	mov	esi, esp
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24424]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24424]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+100]
	call	ecx
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN4@DrawObject:

; 250  : 	}
; 251  : 
; 252  : 	//pass the model colour - used for untextured models, texture colour change and outline colour in cell shading
; 253  : 	ModelColourVar->SetRawValue( mpObjects[i]->GetColourV(), 0, 12 );

	mov	esi, esp
	push	12					; 0000000cH
	push	0
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+8]
	call	?GetColourV@CRenderObject@@QAE?AUD3DXVECTOR3@@XZ ; CRenderObject::GetColourV
	mov	ecx, eax
	call	??BD3DXVECTOR3@@QAEPAMXZ		; D3DXVECTOR3::operator float *
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24428]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24428]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+92]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 254  : 	
; 255  : 	//if the object is lit, pass over the 12 closest lights. 
; 256  : 	if( mpObjects[i]->IsLit() )

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4+8]
	call	?IsLit@CRenderObject@@QAE_NXZ		; CRenderObject::IsLit
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN3@DrawObject

; 257  : 	{
; 258  : 		SetLights( mpObjects[i]->GetModel()->GetPosition(), mpLights, miNumLights);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8132]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 8012				; 00001f4cH
	push	edx
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+8]
	call	?GetModel@CRenderObject@@QAEPAVCModel@@XZ ; CRenderObject::GetModel
	mov	ecx, eax
	call	?GetPosition@CModel@@QAE?AUD3DXVECTOR3@@XZ ; CModel::GetPosition
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLights@CScene@@AAEXUD3DXVECTOR3@@QAPAVCLight@@H@Z ; CScene::SetLights
$LN3@DrawObject:

; 259  : 	}
; 260  : 
; 261  : 	// choose how to render the model based on where we are rendering it. 
; 262  : 	if( mirror )

	movzx	eax, BYTE PTR _mirror$[ebp]
	test	eax, eax
	je	SHORT $LN2@DrawObject

; 263  : 	{
; 264  : 		mpObjects[i]->RenderMirror();

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4+8]
	call	?RenderMirror@CRenderObject@@QAEXXZ	; CRenderObject::RenderMirror

; 265  : 	}
; 266  : 	else

	jmp	SHORT $LN1@DrawObject
$LN2@DrawObject:

; 267  : 	{
; 268  : 		mpObjects[i]->Render();

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4+8]
	call	?Render@CRenderObject@@QAEXXZ		; CRenderObject::Render
$LN1@DrawObject:

; 269  : 		
; 270  : 	}
; 271  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN11@DrawObject
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 344				; 00000158H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	3
$LN11@DrawObject:
	DD	2
	DD	$LN10@DrawObject
$LN10@DrawObject:
	DD	-24					; ffffffe8H
	DD	4
	DD	$LN8@DrawObject
	DD	-36					; ffffffdcH
	DD	4
	DD	$LN9@DrawObject
$LN9@DrawObject:
	DB	116					; 00000074H
	DB	104					; 00000068H
	DB	105					; 00000069H
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	115					; 00000073H
	DB	0
$LN8@DrawObject:
	DB	119					; 00000077H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	103					; 00000067H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	0
?DrawObject@CScene@@AAEXH_N@Z ENDP			; CScene::DrawObject
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\game-of-life\scene.cpp
;	COMDAT ?WndProc@CScene@@CGJPAUHWND__@@IIJ@Z
_TEXT	SEGMENT
tv64 = -308						; size = 4
_rc$1 = -108						; size = 16
_hdc$ = -84						; size = 4
_ps$ = -72						; size = 64
__$ArrayPad$ = -4					; size = 4
_hWnd$ = 8						; size = 4
_message$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
?WndProc@CScene@@CGJPAUHWND__@@IIJ@Z PROC		; CScene::WndProc, COMDAT

; 460  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 308				; 00000134H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-308]
	mov	ecx, 77					; 0000004dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 461  : 	PAINTSTRUCT ps;
; 462  : 	HDC hdc;
; 463  : 
; 464  : 	switch( message )

	mov	eax, DWORD PTR _message$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	cmp	DWORD PTR tv64[ebp], 15			; 0000000fH
	ja	SHORT $LN11@WndProc
	cmp	DWORD PTR tv64[ebp], 15			; 0000000fH
	je	SHORT $LN6@WndProc
	cmp	DWORD PTR tv64[ebp], 2
	je	SHORT $LN5@WndProc
	cmp	DWORD PTR tv64[ebp], 5
	je	$LN2@WndProc
	jmp	$LN1@WndProc
$LN11@WndProc:
	cmp	DWORD PTR tv64[ebp], 256		; 00000100H
	je	SHORT $LN4@WndProc
	cmp	DWORD PTR tv64[ebp], 257		; 00000101H
	je	SHORT $LN3@WndProc
	jmp	$LN1@WndProc
$LN6@WndProc:

; 465  : 	{
; 466  : 		case WM_PAINT:
; 467  : 			hdc = BeginPaint( hWnd, &ps );

	mov	esi, esp
	lea	eax, DWORD PTR _ps$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hWnd$[ebp]
	push	ecx
	call	DWORD PTR __imp__BeginPaint@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hdc$[ebp], eax

; 468  : 			EndPaint( hWnd, &ps );

	mov	esi, esp
	lea	eax, DWORD PTR _ps$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hWnd$[ebp]
	push	ecx
	call	DWORD PTR __imp__EndPaint@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 469  : 			break;

	jmp	$LN7@WndProc
$LN5@WndProc:

; 470  : 
; 471  : 		case WM_DESTROY:
; 472  : 			PostQuitMessage( 0 );

	mov	esi, esp
	push	0
	call	DWORD PTR __imp__PostQuitMessage@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 473  : 			break;

	jmp	$LN7@WndProc
$LN4@WndProc:

; 474  : 
; 475  : 		// These windows messages (WM_KEYXXXX) can be used to get keyboard input to the window
; 476  : 		// This application has added some simple functions (not DirectX) to process these messages (all in Input.cpp/h)
; 477  : 		case WM_KEYDOWN:
; 478  : 			KeyDownEvent( static_cast<EKeyState>(wParam) );

	mov	eax, DWORD PTR _wParam$[ebp]
	push	eax
	call	?KeyDownEvent@@YAXW4EKeyState@@@Z	; KeyDownEvent
	add	esp, 4

; 479  : 			break;

	jmp	SHORT $LN7@WndProc
$LN3@WndProc:

; 480  : 
; 481  : 		case WM_KEYUP:
; 482  : 			KeyUpEvent( static_cast<EKeyState>(wParam) );

	mov	eax, DWORD PTR _wParam$[ebp]
	push	eax
	call	?KeyUpEvent@@YAXW4EKeyState@@@Z		; KeyUpEvent
	add	esp, 4

; 483  : 			break;

	jmp	SHORT $LN7@WndProc
$LN2@WndProc:

; 484  : 		// catch window resize
; 485  : 		case WM_SIZE:
; 486  : 			RECT rc;
; 487  : 			GetClientRect( hWnd, &rc );

	mov	esi, esp
	lea	eax, DWORD PTR _rc$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _hWnd$[ebp]
	push	ecx
	call	DWORD PTR __imp__GetClientRect@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 488  : 			mViewportWidth = rc.right - rc.left;

	mov	eax, DWORD PTR _rc$1[ebp+8]
	sub	eax, DWORD PTR _rc$1[ebp]
	mov	DWORD PTR ?mViewportWidth@CScene@@0HA, eax ; CScene::mViewportWidth

; 489  : 			mViewportHeight = rc.bottom - rc.top;

	mov	eax, DWORD PTR _rc$1[ebp+12]
	sub	eax, DWORD PTR _rc$1[ebp+4]
	mov	DWORD PTR ?mViewportHeight@CScene@@0HA, eax ; CScene::mViewportHeight

; 490  : 			// pass to camera
; 491  : 			CCamera::SetViewport( mViewportWidth, mViewportHeight );

	mov	eax, DWORD PTR ?mViewportHeight@CScene@@0HA ; CScene::mViewportHeight
	push	eax
	mov	ecx, DWORD PTR ?mViewportWidth@CScene@@0HA ; CScene::mViewportWidth
	push	ecx
	call	?SetViewport@CCamera@@SAXHH@Z		; CCamera::SetViewport
	add	esp, 8

; 492  : 			break;

	jmp	SHORT $LN7@WndProc
$LN1@WndProc:

; 493  : 		default:
; 494  : 			return DefWindowProc( hWnd, message, wParam, lParam );

	mov	esi, esp
	mov	eax, DWORD PTR _lParam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _wParam$[ebp]
	push	ecx
	mov	edx, DWORD PTR _message$[ebp]
	push	edx
	mov	eax, DWORD PTR _hWnd$[ebp]
	push	eax
	call	DWORD PTR __imp__DefWindowProcW@16
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	SHORT $LN9@WndProc
$LN7@WndProc:

; 495  : 	}
; 496  : 
; 497  : 	return 0;

	xor	eax, eax
$LN9@WndProc:

; 498  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN15@WndProc
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 308				; 00000134H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
	npad	1
$LN15@WndProc:
	DD	2
	DD	$LN14@WndProc
$LN14@WndProc:
	DD	-72					; ffffffb8H
	DD	64					; 00000040H
	DD	$LN12@WndProc
	DD	-108					; ffffff94H
	DD	16					; 00000010H
	DD	$LN13@WndProc
$LN13@WndProc:
	DB	114					; 00000072H
	DB	99					; 00000063H
	DB	0
$LN12@WndProc:
	DB	112					; 00000070H
	DB	115					; 00000073H
	DB	0
?WndProc@CScene@@CGJPAUHWND__@@IIJ@Z ENDP		; CScene::WndProc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\game-of-life\scene.cpp
;	COMDAT ?compareLights@CScene@@CAHPBX0@Z
_TEXT	SEGMENT
_y$ = -20						; size = 4
_x$ = -8						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
?compareLights@CScene@@CAHPBX0@Z PROC			; CScene::compareLights, COMDAT

; 748  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 749  : 	LightIndex* x = (LightIndex*)a;

	mov	eax, DWORD PTR _a$[ebp]
	mov	DWORD PTR _x$[ebp], eax

; 750  : 	LightIndex* y = (LightIndex*)b;

	mov	eax, DWORD PTR _b$[ebp]
	mov	DWORD PTR _y$[ebp], eax

; 751  : 	return int(x->distance - y->distance);

	mov	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR _y$[ebp]
	movss	xmm0, DWORD PTR [eax+4]
	subss	xmm0, DWORD PTR [ecx+4]
	cvttss2si eax, xmm0

; 752  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?compareLights@CScene@@CAHPBX0@Z ENDP			; CScene::compareLights
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\game-of-life\scene.cpp
;	COMDAT ?SetLights@CScene@@AAEXUD3DXVECTOR3@@QAPAVCLight@@H@Z
_TEXT	SEGMENT
tv346 = -1288						; size = 4
tv452 = -1284						; size = 4
tv340 = -1280						; size = 4
tv450 = -1276						; size = 4
tv334 = -1272						; size = 4
$T1 = -1264						; size = 12
$T2 = -1244						; size = 12
$T3 = -1224						; size = 12
$T4 = -1204						; size = 16
$T5 = -1180						; size = 16
$T6 = -1156						; size = 16
_c$7 = -940						; size = 4
_i$8 = -928						; size = 4
_bright$ = -916						; size = 192
_colours$ = -716					; size = 192
_positions$ = -516					; size = 192
_count$ = -316						; size = 4
_i$9 = -304						; size = 4
_vLight$ = -292						; size = 12
_i$10 = -272						; size = 4
_indexes$ = -260					; size = 240
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_source$ = 8						; size = 12
_lightsSource$ = 20					; size = 4
_lightCount$ = 24					; size = 4
?SetLights@CScene@@AAEXUD3DXVECTOR3@@QAPAVCLight@@H@Z PROC ; CScene::SetLights, COMDAT
; _this$ = ecx

; 756  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1288				; 00000508H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-1288]
	mov	ecx, 322				; 00000142H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 757  : 	LightIndex indexes[MAX_LIGHTS];
; 758  : 
; 759  : 	for(int i = 0; i < MAX_LIGHTS; i++)

	mov	DWORD PTR _i$10[ebp], 0
	jmp	SHORT $LN11@SetLights
$LN10@SetLights:
	mov	eax, DWORD PTR _i$10[ebp]
	add	eax, 1
	mov	DWORD PTR _i$10[ebp], eax
$LN11@SetLights:
	cmp	DWORD PTR _i$10[ebp], 30		; 0000001eH
	jge	SHORT $LN9@SetLights

; 760  : 	{
; 761  : 		indexes[i].distance = 777777777.0f;

	mov	eax, DWORD PTR _i$10[ebp]
	movss	xmm0, DWORD PTR __real@4e396fca
	movss	DWORD PTR _indexes$[ebp+eax*8+4], xmm0

; 762  : 	}

	jmp	SHORT $LN10@SetLights
$LN9@SetLights:

; 763  : 
; 764  : 	D3DXVECTOR3 vLight;

	lea	ecx, DWORD PTR _vLight$[ebp]
	call	??0D3DXVECTOR3@@QAE@XZ			; D3DXVECTOR3::D3DXVECTOR3

; 765  : 	for(int i = 0; i < lightCount; i++)

	mov	DWORD PTR _i$9[ebp], 0
	jmp	SHORT $LN8@SetLights
$LN7@SetLights:
	mov	eax, DWORD PTR _i$9[ebp]
	add	eax, 1
	mov	DWORD PTR _i$9[ebp], eax
$LN8@SetLights:
	mov	eax, DWORD PTR _i$9[ebp]
	cmp	eax, DWORD PTR _lightCount$[ebp]
	jge	$LN6@SetLights

; 766  : 	{
; 767  : 		indexes[i].index = i;

	mov	eax, DWORD PTR _i$9[ebp]
	mov	ecx, DWORD PTR _i$9[ebp]
	mov	DWORD PTR _indexes$[ebp+eax*8], ecx

; 768  : 		vLight = lightsSource[i]->GetModel()->GetPosition();

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$9[ebp]
	mov	edx, DWORD PTR _lightsSource$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4]
	call	?GetModel@CLight@@QAEPAVCModel@@XZ	; CLight::GetModel
	mov	ecx, eax
	call	?GetPosition@CModel@@QAE?AUD3DXVECTOR3@@XZ ; CModel::GetPosition
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _vLight$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _vLight$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _vLight$[ebp+8], eax

; 769  : 		indexes[i].distance = square(vLight.x - source.x) + square (vLight.y - source.y) + square(vLight.z - source.z);

	movss	xmm0, DWORD PTR _vLight$[ebp]
	subss	xmm0, DWORD PTR _source$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?square@@YAMM@Z				; square
	add	esp, 4
	fstp	DWORD PTR tv334[ebp]
	movss	xmm0, DWORD PTR tv334[ebp]
	movss	xmm1, DWORD PTR _vLight$[ebp+4]
	subss	xmm1, DWORD PTR _source$[ebp+4]
	push	ecx
	movss	DWORD PTR [esp], xmm1
	movss	DWORD PTR tv450[ebp], xmm0
	call	?square@@YAMM@Z				; square
	add	esp, 4
	fstp	DWORD PTR tv340[ebp]
	movss	xmm0, DWORD PTR tv450[ebp]
	addss	xmm0, DWORD PTR tv340[ebp]
	movss	xmm1, DWORD PTR _vLight$[ebp+8]
	subss	xmm1, DWORD PTR _source$[ebp+8]
	push	ecx
	movss	DWORD PTR [esp], xmm1
	movss	DWORD PTR tv452[ebp], xmm0
	call	?square@@YAMM@Z				; square
	add	esp, 4
	fstp	DWORD PTR tv346[ebp]
	movss	xmm0, DWORD PTR tv452[ebp]
	addss	xmm0, DWORD PTR tv346[ebp]
	mov	eax, DWORD PTR _i$9[ebp]
	movss	DWORD PTR _indexes$[ebp+eax*8+4], xmm0

; 770  : 	}

	jmp	$LN7@SetLights
$LN6@SetLights:

; 771  : 
; 772  : 	qsort( (void*) indexes, MAX_LIGHTS, sizeof(LightIndex), &CScene::compareLights);

	push	OFFSET ?compareLights@CScene@@CAHPBX0@Z	; CScene::compareLights
	push	8
	push	30					; 0000001eH
	lea	eax, DWORD PTR _indexes$[ebp]
	push	eax
	call	_qsort
	add	esp, 16					; 00000010H

; 773  : 
; 774  : 	int count;
; 775  : 	
; 776  : 	if( lightCount < MAX_SHADER_LIGHTS )

	cmp	DWORD PTR _lightCount$[ebp], 12		; 0000000cH
	jge	SHORT $LN5@SetLights

; 777  : 	{
; 778  : 		count = lightCount;

	mov	eax, DWORD PTR _lightCount$[ebp]
	mov	DWORD PTR _count$[ebp], eax

; 779  : 	}
; 780  : 	else

	jmp	SHORT $LN4@SetLights
$LN5@SetLights:

; 781  : 	{
; 782  : 		count = MAX_SHADER_LIGHTS;

	mov	DWORD PTR _count$[ebp], 12		; 0000000cH
$LN4@SetLights:

; 783  : 	}
; 784  : 
; 785  : 	D3DXVECTOR4 positions[MAX_SHADER_LIGHTS];

	push	OFFSET ??0D3DXVECTOR4@@QAE@XZ		; D3DXVECTOR4::D3DXVECTOR4
	push	12					; 0000000cH
	push	16					; 00000010H
	lea	eax, DWORD PTR _positions$[ebp]
	push	eax
	call	??_H@YGXPAXIHP6EPAX0@Z@Z

; 786  : 	D3DXVECTOR4 colours[MAX_SHADER_LIGHTS];

	push	OFFSET ??0D3DXVECTOR4@@QAE@XZ		; D3DXVECTOR4::D3DXVECTOR4
	push	12					; 0000000cH
	push	16					; 00000010H
	lea	eax, DWORD PTR _colours$[ebp]
	push	eax
	call	??_H@YGXPAXIHP6EPAX0@Z@Z

; 787  : 	D3DXVECTOR4 bright[MAX_SHADER_LIGHTS];

	push	OFFSET ??0D3DXVECTOR4@@QAE@XZ		; D3DXVECTOR4::D3DXVECTOR4
	push	12					; 0000000cH
	push	16					; 00000010H
	lea	eax, DWORD PTR _bright$[ebp]
	push	eax
	call	??_H@YGXPAXIHP6EPAX0@Z@Z

; 788  : 
; 789  : 	for(int i = 0; i < count; i++)

	mov	DWORD PTR _i$8[ebp], 0
	jmp	SHORT $LN3@SetLights
$LN2@SetLights:
	mov	eax, DWORD PTR _i$8[ebp]
	add	eax, 1
	mov	DWORD PTR _i$8[ebp], eax
$LN3@SetLights:
	mov	eax, DWORD PTR _i$8[ebp]
	cmp	eax, DWORD PTR _count$[ebp]
	jge	$LN1@SetLights

; 790  : 	{
; 791  : 		int c = indexes[i].index;

	mov	eax, DWORD PTR _i$8[ebp]
	mov	ecx, DWORD PTR _indexes$[ebp+eax*8]
	mov	DWORD PTR _c$7[ebp], ecx

; 792  : 		positions[i] = D3DXVECTOR4 (mpLights[c]->GetModel()->GetPosition(), 0 );

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _c$7[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+8012]
	call	?GetModel@CLight@@QAEPAVCModel@@XZ	; CLight::GetModel
	mov	ecx, eax
	call	?GetPosition@CModel@@QAE?AUD3DXVECTOR3@@XZ ; CModel::GetPosition
	push	eax
	lea	ecx, DWORD PTR $T4[ebp]
	call	??0D3DXVECTOR4@@QAE@ABU_D3DVECTOR@@M@Z	; D3DXVECTOR4::D3DXVECTOR4
	mov	ecx, DWORD PTR _i$8[ebp]
	shl	ecx, 4
	lea	edx, DWORD PTR _positions$[ebp+ecx]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], ecx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+12], eax

; 793  : 		colours[i] = D3DXVECTOR4 ( mpLights[c]->GetColourV(), 0 );

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _c$7[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+8012]
	call	?GetColourV@CLight@@QAE?AUD3DXVECTOR3@@XZ ; CLight::GetColourV
	push	eax
	lea	ecx, DWORD PTR $T5[ebp]
	call	??0D3DXVECTOR4@@QAE@ABU_D3DVECTOR@@M@Z	; D3DXVECTOR4::D3DXVECTOR4
	mov	ecx, DWORD PTR _i$8[ebp]
	shl	ecx, 4
	lea	edx, DWORD PTR _colours$[ebp+ecx]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], ecx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+12], eax

; 794  : 		bright[i] = D3DXVECTOR4( mpLights[c]->GetBrightness(), 0, 0, 0 );   // vector 4 for packing, remaining variables would be useful for light type and angle. 

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _c$7[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4+8012]
	call	?GetBrightness@CLight@@QAEMXZ		; CLight::GetBrightness
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T6[ebp]
	call	??0D3DXVECTOR4@@QAE@MMMM@Z		; D3DXVECTOR4::D3DXVECTOR4
	mov	edx, DWORD PTR _i$8[ebp]
	shl	edx, 4
	lea	ecx, DWORD PTR _bright$[ebp+edx]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax

; 795  : 	}

	jmp	$LN2@SetLights
$LN1@SetLights:

; 796  : 
; 797  : 	dxLightPosA->SetRawValue( positions, 0, 16 * count );

	mov	eax, DWORD PTR _count$[ebp]
	shl	eax, 4
	mov	esi, esp
	push	eax
	push	0
	lea	ecx, DWORD PTR _positions$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24432]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24432]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+92]
	call	ecx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 798  : 	dxLightColourA->SetRawValue( colours, 0, 16 * count );

	mov	eax, DWORD PTR _count$[ebp]
	shl	eax, 4
	mov	esi, esp
	push	eax
	push	0
	lea	ecx, DWORD PTR _colours$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24440]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24440]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+92]
	call	ecx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 799  : 	dxLightBrightnessA->SetRawValue( bright, 0, 16 * count );

	mov	eax, DWORD PTR _count$[ebp]
	shl	eax, 4
	mov	esi, esp
	push	eax
	push	0
	lea	ecx, DWORD PTR _bright$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24448]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24448]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+92]
	call	ecx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 800  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN20@SetLights
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 1288				; 00000508H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
	npad	1
$LN20@SetLights:
	DD	5
	DD	$LN19@SetLights
$LN19@SetLights:
	DD	-260					; fffffefcH
	DD	240					; 000000f0H
	DD	$LN14@SetLights
	DD	-292					; fffffedcH
	DD	12					; 0000000cH
	DD	$LN15@SetLights
	DD	-516					; fffffdfcH
	DD	192					; 000000c0H
	DD	$LN16@SetLights
	DD	-716					; fffffd34H
	DD	192					; 000000c0H
	DD	$LN17@SetLights
	DD	-916					; fffffc6cH
	DD	192					; 000000c0H
	DD	$LN18@SetLights
$LN18@SetLights:
	DB	98					; 00000062H
	DB	114					; 00000072H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	104					; 00000068H
	DB	116					; 00000074H
	DB	0
$LN17@SetLights:
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	114					; 00000072H
	DB	115					; 00000073H
	DB	0
$LN16@SetLights:
	DB	112					; 00000070H
	DB	111					; 0000006fH
	DB	115					; 00000073H
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	115					; 00000073H
	DB	0
$LN15@SetLights:
	DB	118					; 00000076H
	DB	76					; 0000004cH
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	104					; 00000068H
	DB	116					; 00000074H
	DB	0
$LN14@SetLights:
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	120					; 00000078H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	0
?SetLights@CScene@@AAEXUD3DXVECTOR3@@QAPAVCLight@@H@Z ENDP ; CScene::SetLights
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\game-of-life\scene.cpp
;	COMDAT ?CalcNeighbours@CScene@@AAEXXZ
_TEXT	SEGMENT
_l$1 = -56						; size = 4
_k$2 = -44						; size = 4
_j$3 = -32						; size = 4
_i$4 = -20						; size = 4
_this$ = -8						; size = 4
?CalcNeighbours@CScene@@AAEXXZ PROC			; CScene::CalcNeighbours, COMDAT
; _this$ = ecx

; 1075 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 252				; 000000fcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-252]
	mov	ecx, 63					; 0000003fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1076 : 	for( int i = 0; i < GRIDSIZE; i++ )

	mov	DWORD PTR _i$4[ebp], 0
	jmp	SHORT $LN15@CalcNeighb
$LN14@CalcNeighb:
	mov	eax, DWORD PTR _i$4[ebp]
	add	eax, 1
	mov	DWORD PTR _i$4[ebp], eax
$LN15@CalcNeighb:
	cmp	DWORD PTR _i$4[ebp], 30			; 0000001eH
	jge	$LN16@CalcNeighb

; 1077 : 	{
; 1078 : 		for( int j = 0; j < GRIDSIZE; j++ )

	mov	DWORD PTR _j$3[ebp], 0
	jmp	SHORT $LN12@CalcNeighb
$LN11@CalcNeighb:
	mov	eax, DWORD PTR _j$3[ebp]
	add	eax, 1
	mov	DWORD PTR _j$3[ebp], eax
$LN12@CalcNeighb:
	cmp	DWORD PTR _j$3[ebp], 30			; 0000001eH
	jge	$LN10@CalcNeighb

; 1079 : 		{
; 1080 : 			cells[i][j].adjcell = 0;

	imul	eax, DWORD PTR _i$4[ebp], 360
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [ecx+eax+24488]
	imul	eax, DWORD PTR _j$3[ebp], 12
	mov	DWORD PTR [edx+eax+4], 0

; 1081 : 			for( int k = -1; k < 2; k++ )

	mov	DWORD PTR _k$2[ebp], -1
	jmp	SHORT $LN9@CalcNeighb
$LN8@CalcNeighb:
	mov	eax, DWORD PTR _k$2[ebp]
	add	eax, 1
	mov	DWORD PTR _k$2[ebp], eax
$LN9@CalcNeighb:
	cmp	DWORD PTR _k$2[ebp], 2
	jge	$LN7@CalcNeighb

; 1082 : 			{
; 1083 : 
; 1084 : 				for( int l = -1; l < 2; l++ )

	mov	DWORD PTR _l$1[ebp], -1
	jmp	SHORT $LN6@CalcNeighb
$LN5@CalcNeighb:
	mov	eax, DWORD PTR _l$1[ebp]
	add	eax, 1
	mov	DWORD PTR _l$1[ebp], eax
$LN6@CalcNeighb:
	cmp	DWORD PTR _l$1[ebp], 2
	jge	$LN4@CalcNeighb

; 1085 : 				{
; 1086 : 					if( l == 0  && k == 0)

	cmp	DWORD PTR _l$1[ebp], 0
	jne	SHORT $LN3@CalcNeighb
	cmp	DWORD PTR _k$2[ebp], 0
	jne	SHORT $LN3@CalcNeighb

; 1087 : 					{
; 1088 : 						continue;

	jmp	SHORT $LN5@CalcNeighb
$LN3@CalcNeighb:

; 1089 : 					}
; 1090 : 
; 1091 : 					if( 
; 1092 : 						((i + k) >= 0) && 
; 1093 : 						((i + k) < GRIDSIZE) && 
; 1094 : 						((j+l) >= 0) && 
; 1095 : 						((j+l) < GRIDSIZE)
; 1096 : 						)

	mov	eax, DWORD PTR _i$4[ebp]
	add	eax, DWORD PTR _k$2[ebp]
	js	SHORT $LN2@CalcNeighb
	mov	eax, DWORD PTR _i$4[ebp]
	add	eax, DWORD PTR _k$2[ebp]
	cmp	eax, 30					; 0000001eH
	jge	SHORT $LN2@CalcNeighb
	mov	eax, DWORD PTR _j$3[ebp]
	add	eax, DWORD PTR _l$1[ebp]
	js	SHORT $LN2@CalcNeighb
	mov	eax, DWORD PTR _j$3[ebp]
	add	eax, DWORD PTR _l$1[ebp]
	cmp	eax, 30					; 0000001eH
	jge	SHORT $LN2@CalcNeighb

; 1097 : 					{
; 1098 : 						if( cells[i + k][j + l].val == 1 )

	mov	eax, DWORD PTR _i$4[ebp]
	add	eax, DWORD PTR _k$2[ebp]
	imul	ecx, eax, 360
	mov	edx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [edx+ecx+24488]
	mov	ecx, DWORD PTR _j$3[ebp]
	add	ecx, DWORD PTR _l$1[ebp]
	imul	edx, ecx, 12
	cmp	DWORD PTR [eax+edx], 1
	jne	SHORT $LN2@CalcNeighb

; 1099 : 						{
; 1100 : 							cells[i][j].adjcell++;

	imul	eax, DWORD PTR _j$3[ebp], 12
	imul	ecx, DWORD PTR _i$4[ebp], 360
	mov	edx, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [edx+ecx+24488]
	mov	edx, DWORD PTR [ecx+eax+4]
	add	edx, 1
	imul	eax, DWORD PTR _j$3[ebp], 12
	imul	ecx, DWORD PTR _i$4[ebp], 360
	mov	esi, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [esi+ecx+24488]
	mov	DWORD PTR [ecx+eax+4], edx
$LN2@CalcNeighb:

; 1101 : 						}
; 1102 : 					}
; 1103 : 				}

	jmp	$LN5@CalcNeighb
$LN4@CalcNeighb:

; 1104 : 			}

	jmp	$LN8@CalcNeighb
$LN7@CalcNeighb:

; 1105 : 		}

	jmp	$LN11@CalcNeighb
$LN10@CalcNeighb:

; 1106 : 	}

	jmp	$LN14@CalcNeighb
$LN16@CalcNeighb:

; 1107 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CalcNeighbours@CScene@@AAEXXZ ENDP			; CScene::CalcNeighbours
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\game-of-life\scene.cpp
;	COMDAT ?SetDead@CScene@@AAEXHH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$ = 8							; size = 4
_j$ = 12						; size = 4
?SetDead@CScene@@AAEXHH@Z PROC				; CScene::SetDead, COMDAT
; _this$ = ecx

; 1116 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1117 : 	cells[i][j].myObject->SetColour( 1.0f, 1.0f, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	imul	eax, DWORD PTR _i$[ebp], 360
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [ecx+eax+24488]
	imul	eax, DWORD PTR _j$[ebp], 12
	mov	ecx, DWORD PTR [edx+eax+8]
	call	?SetColour@CRenderObject@@QAEXMMM@Z	; CRenderObject::SetColour

; 1118 : 	cells[i][j].val = 0;

	imul	eax, DWORD PTR _i$[ebp], 360
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [ecx+eax+24488]
	imul	eax, DWORD PTR _j$[ebp], 12
	mov	DWORD PTR [edx+eax], 0

; 1119 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?SetDead@CScene@@AAEXHH@Z ENDP				; CScene::SetDead
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\game-of-life\scene.cpp
;	COMDAT ?SetLive@CScene@@AAEXHH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$ = 8							; size = 4
_j$ = 12						; size = 4
?SetLive@CScene@@AAEXHH@Z PROC				; CScene::SetLive, COMDAT
; _this$ = ecx

; 1110 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1111 : 	cells[i][j].myObject->SetColour( 0.2f, 0.8f, 0.2f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3e4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3e4ccccd
	movss	DWORD PTR [esp], xmm0
	imul	eax, DWORD PTR _i$[ebp], 360
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [ecx+eax+24488]
	imul	eax, DWORD PTR _j$[ebp], 12
	mov	ecx, DWORD PTR [edx+eax+8]
	call	?SetColour@CRenderObject@@QAEXMMM@Z	; CRenderObject::SetColour

; 1112 : 	cells[i][j].val = 1;

	imul	eax, DWORD PTR _i$[ebp], 360
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [ecx+eax+24488]
	imul	eax, DWORD PTR _j$[ebp], 12
	mov	DWORD PTR [edx+eax], 1

; 1113 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?SetLive@CScene@@AAEXHH@Z ENDP				; CScene::SetLive
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\game-of-life\scene.cpp
;	COMDAT ?CellStuff@CScene@@AAE_NXZ
_TEXT	SEGMENT
tv144 = -312						; size = 4
$T2 = -304						; size = 12
$T3 = -284						; size = 12
$T4 = -264						; size = 4
$T5 = -252						; size = 4
_j$6 = -48						; size = 4
_i$7 = -36						; size = 4
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?CellStuff@CScene@@AAE_NXZ PROC				; CScene::CellStuff, COMDAT
; _this$ = ecx

; 1040 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?CellStuff@CScene@@AAE_NXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 300				; 0000012cH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-312]
	mov	ecx, 75					; 0000004bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1041 : 	for( int i = 0; i < GRIDSIZE; i++ )

	mov	DWORD PTR _i$7[ebp], 0
	jmp	SHORT $LN6@CellStuff
$LN5@CellStuff:
	mov	eax, DWORD PTR _i$7[ebp]
	add	eax, 1
	mov	DWORD PTR _i$7[ebp], eax
$LN6@CellStuff:
	cmp	DWORD PTR _i$7[ebp], 30			; 0000001eH
	jge	$LN4@CellStuff

; 1042 : 	{
; 1043 : 		for( int j = 0; j < GRIDSIZE; j++ )

	mov	DWORD PTR _j$6[ebp], 0
	jmp	SHORT $LN3@CellStuff
$LN2@CellStuff:
	mov	eax, DWORD PTR _j$6[ebp]
	add	eax, 1
	mov	DWORD PTR _j$6[ebp], eax
$LN3@CellStuff:
	cmp	DWORD PTR _j$6[ebp], 30			; 0000001eH
	jge	$LN1@CellStuff

; 1044 : 		{
; 1045 : 			cells[i][j].val = 0;

	imul	eax, DWORD PTR _i$7[ebp], 360
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [ecx+eax+24488]
	imul	eax, DWORD PTR _j$6[ebp], 12
	mov	DWORD PTR [edx+eax], 0

; 1046 : 			cells[i][j].myObject = new CRenderObject("Cube.x", D3DXVECTOR3(i, 0.0f, j), D3DXVECTOR3(1.0f, 1.0f, 1.0f), mTechniques[PlainColour],NULL);

	push	72					; 00000048H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T5[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T5[ebp], 0
	je	$LN9@CellStuff
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+24160]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T3[ebp]
	call	??0D3DXVECTOR3@@QAE@MMM@Z		; D3DXVECTOR3::D3DXVECTOR3
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	cvtsi2ss xmm0, DWORD PTR _j$6[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _i$7[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0D3DXVECTOR3@@QAE@MMM@Z		; D3DXVECTOR3::D3DXVECTOR3
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	push	OFFSET ??_C@_06HGKAGIBP@Cube?4x?$AA@
	mov	ecx, DWORD PTR $T5[ebp]
	call	??0CRenderObject@@QAE@QADUD3DXVECTOR3@@1PAUID3D10EffectTechnique@@2PAUID3D10ShaderResourceView@@3_N44@Z ; CRenderObject::CRenderObject
	mov	DWORD PTR tv144[ebp], eax
	jmp	SHORT $LN10@CellStuff
$LN9@CellStuff:
	mov	DWORD PTR tv144[ebp], 0
$LN10@CellStuff:
	mov	ecx, DWORD PTR tv144[ebp]
	mov	DWORD PTR $T4[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	imul	edx, DWORD PTR _i$7[ebp], 360
	mov	eax, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [eax+edx+24488]
	imul	edx, DWORD PTR _j$6[ebp], 12
	mov	eax, DWORD PTR $T4[ebp]
	mov	DWORD PTR [ecx+edx+8], eax

; 1047 : 			cells[i][j].myObject->GetModel()->SetScale(0.1f);

	push	ecx
	movss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR [esp], xmm0
	imul	eax, DWORD PTR _i$7[ebp], 360
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [ecx+eax+24488]
	imul	eax, DWORD PTR _j$6[ebp], 12
	mov	ecx, DWORD PTR [edx+eax+8]
	call	?GetModel@CRenderObject@@QAEPAVCModel@@XZ ; CRenderObject::GetModel
	mov	ecx, eax
	call	?SetScale@CModel@@QAEXM@Z		; CModel::SetScale

; 1048 : 			cells[i][j].adjcell = 0;

	imul	eax, DWORD PTR _i$7[ebp], 360
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [ecx+eax+24488]
	imul	eax, DWORD PTR _j$6[ebp], 12
	mov	DWORD PTR [edx+eax+4], 0

; 1049 : 			mpObjects[miNumObjects] = cells[i][j].myObject;

	imul	eax, DWORD PTR _i$7[ebp], 360
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [ecx+eax+24488]
	imul	eax, DWORD PTR _j$6[ebp], 12
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+8008]
	mov	esi, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx+eax+8]
	mov	DWORD PTR [esi+ecx*4+8], edx

; 1050 : 			miNumObjects++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8008]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8008], ecx

; 1051 : 		}

	jmp	$LN2@CellStuff
$LN1@CellStuff:

; 1052 : 	}

	jmp	$LN5@CellStuff
$LN4@CellStuff:

; 1053 : 
; 1054 : 	SetLive(5,5);

	push	5
	push	5
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLive@CScene@@AAEXHH@Z		; CScene::SetLive

; 1055 : 	SetLive(5,6);

	push	6
	push	5
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLive@CScene@@AAEXHH@Z		; CScene::SetLive

; 1056 : 	SetLive(6,5);

	push	5
	push	6
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLive@CScene@@AAEXHH@Z		; CScene::SetLive

; 1057 : 	SetLive(6,6);

	push	6
	push	6
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLive@CScene@@AAEXHH@Z		; CScene::SetLive

; 1058 : 
; 1059 : 	SetLive(10,10);

	push	10					; 0000000aH
	push	10					; 0000000aH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLive@CScene@@AAEXHH@Z		; CScene::SetLive

; 1060 : 	SetLive(11,10);

	push	10					; 0000000aH
	push	11					; 0000000bH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLive@CScene@@AAEXHH@Z		; CScene::SetLive

; 1061 : 	SetLive(12,10);

	push	10					; 0000000aH
	push	12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLive@CScene@@AAEXHH@Z		; CScene::SetLive

; 1062 : 	
; 1063 : 	SetLive(20, 20);

	push	20					; 00000014H
	push	20					; 00000014H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLive@CScene@@AAEXHH@Z		; CScene::SetLive

; 1064 : 	SetLive(20, 21);

	push	21					; 00000015H
	push	20					; 00000014H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLive@CScene@@AAEXHH@Z		; CScene::SetLive

; 1065 : 	SetLive(20, 22);

	push	22					; 00000016H
	push	20					; 00000014H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLive@CScene@@AAEXHH@Z		; CScene::SetLive

; 1066 : //	SetLive(21, 22);
; 1067 : //	SetLive(22, 21);
; 1068 : 
; 1069 : 	CalcNeighbours();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalcNeighbours@CScene@@AAEXXZ		; CScene::CalcNeighbours

; 1070 : 
; 1071 : 	return true;

	mov	al, 1

; 1072 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 312				; 00000138H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CellStuff@CScene@@AAE_NXZ$0:
	mov	eax, DWORD PTR $T5[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?CellStuff@CScene@@AAE_NXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-316]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?CellStuff@CScene@@AAE_NXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?CellStuff@CScene@@AAE_NXZ ENDP				; CScene::CellStuff
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\game-of-life\scene.cpp
;	COMDAT ?TestItems@CScene@@AAE_NXZ
_TEXT	SEGMENT
tv194 = -480						; size = 4
tv180 = -480						; size = 4
tv168 = -480						; size = 4
tv142 = -480						; size = 4
$T2 = -472						; size = 12
$T3 = -452						; size = 12
$T4 = -432						; size = 28
$T5 = -396						; size = 12
$T6 = -376						; size = 4
$T7 = -364						; size = 4
$T8 = -352						; size = 4
$T9 = -340						; size = 4
$T10 = -328						; size = 12
$T11 = -308						; size = 12
$T12 = -288						; size = 4
$T13 = -276						; size = 4
$T14 = -261						; size = 1
_i$15 = -60						; size = 4
_temp$ = -48						; size = 4
_i$16 = -36						; size = 4
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?TestItems@CScene@@AAE_NXZ PROC				; CScene::TestItems, COMDAT
; _this$ = ecx

; 949  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?TestItems@CScene@@AAE_NXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 468				; 000001d4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-480]
	mov	ecx, 117				; 00000075H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 950  : 	for( int i = 0; i < 30; i++)

	mov	DWORD PTR _i$16[ebp], 0
	jmp	SHORT $LN7@TestItems
$LN6@TestItems:
	mov	eax, DWORD PTR _i$16[ebp]
	add	eax, 1
	mov	DWORD PTR _i$16[ebp], eax
$LN7@TestItems:
	cmp	DWORD PTR _i$16[ebp], 30		; 0000001eH
	jge	$LN5@TestItems

; 951  : 	{
; 952  : 		mpObjects[miNumObjects] = new CRenderObject("Teapot.x",D3DXVECTOR3(250, 10, i*30.0f), D3DXVECTOR3(1.0f, i/10.0f, i/10.0f), mTechniques[0], mTechniquesMirror[0], NULL, NULL, NULL, NULL);

	push	72					; 00000048H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T7[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T7[ebp], 0
	je	$LN10@TestItems
	push	0
	push	0
	push	0
	push	0
	push	0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+24280]
	push	eax
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+24160]
	push	ecx
	cvtsi2ss xmm0, DWORD PTR _i$16[ebp]
	divss	xmm0, DWORD PTR __real@41200000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _i$16[ebp]
	divss	xmm0, DWORD PTR __real@41200000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T3[ebp]
	call	??0D3DXVECTOR3@@QAE@MMM@Z		; D3DXVECTOR3::D3DXVECTOR3
	sub	esp, 12					; 0000000cH
	mov	edx, esp
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax
	cvtsi2ss xmm0, DWORD PTR _i$16[ebp]
	mulss	xmm0, DWORD PTR __real@41f00000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@437a0000
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0D3DXVECTOR3@@QAE@MMM@Z		; D3DXVECTOR3::D3DXVECTOR3
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	push	OFFSET ??_C@_08KCKKFACH@Teapot?4x?$AA@
	mov	ecx, DWORD PTR $T7[ebp]
	call	??0CRenderObject@@QAE@QADUD3DXVECTOR3@@1PAUID3D10EffectTechnique@@2PAUID3D10ShaderResourceView@@3_N44@Z ; CRenderObject::CRenderObject
	mov	DWORD PTR tv142[ebp], eax
	jmp	SHORT $LN11@TestItems
$LN10@TestItems:
	mov	DWORD PTR tv142[ebp], 0
$LN11@TestItems:
	mov	ecx, DWORD PTR tv142[ebp]
	mov	DWORD PTR $T6[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8008]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T6[ebp]
	mov	DWORD PTR [ecx+eax*4+8], edx

; 953  : 		miNumObjects++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8008]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8008], ecx

; 954  : 	}

	jmp	$LN6@TestItems
$LN5@TestItems:

; 955  : 
; 956  : 	CModel* temp;
; 957  : 	for(int i = 0; i < 10; i++ )

	mov	DWORD PTR _i$15[ebp], 0
	jmp	SHORT $LN4@TestItems
$LN3@TestItems:
	mov	eax, DWORD PTR _i$15[ebp]
	add	eax, 1
	mov	DWORD PTR _i$15[ebp], eax
$LN4@TestItems:
	cmp	DWORD PTR _i$15[ebp], 10		; 0000000aH
	jge	$LN2@TestItems

; 958  : 	{
; 959  : 		temp = new CModel;

	push	1936					; 00000790H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T9[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T9[ebp], 0
	je	$LN12@TestItems
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T10[ebp]
	call	??0D3DXVECTOR3@@QAE@MMM@Z		; D3DXVECTOR3::D3DXVECTOR3
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T11[ebp]
	call	??0D3DXVECTOR3@@QAE@MMM@Z		; D3DXVECTOR3::D3DXVECTOR3
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, DWORD PTR $T9[ebp]
	call	??0CModel@@QAE@UD3DXVECTOR3@@0M@Z	; CModel::CModel
	mov	DWORD PTR tv168[ebp], eax
	jmp	SHORT $LN13@TestItems
$LN12@TestItems:
	mov	DWORD PTR tv168[ebp], 0
$LN13@TestItems:
	mov	ecx, DWORD PTR tv168[ebp]
	mov	DWORD PTR $T8[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR $T8[ebp]
	mov	DWORD PTR _temp$[ebp], edx

; 960  : 		mpLights[miNumLights] = new CLight();

	push	92					; 0000005cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T13[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	cmp	DWORD PTR $T13[ebp], 0
	je	SHORT $LN14@TestItems
	mov	ecx, DWORD PTR $T13[ebp]
	call	??0CLight@@QAE@XZ			; CLight::CLight
	mov	DWORD PTR tv180[ebp], eax
	jmp	SHORT $LN15@TestItems
$LN14@TestItems:
	mov	DWORD PTR tv180[ebp], 0
$LN15@TestItems:
	mov	eax, DWORD PTR tv180[ebp]
	mov	DWORD PTR $T12[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8132]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T12[ebp]
	mov	DWORD PTR [eax+edx*4+8012], ecx

; 961  : 		if (!temp->	Load( "Sphere.x", mTechniques[0] )) return false;

	push	OFFSET ??_C@_08EEMGLHJD@Sphere?4x?$AA@
	lea	ecx, DWORD PTR $T4[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 3
	push	0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+24160]
	push	eax
	lea	ecx, DWORD PTR $T4[ebp]
	push	ecx
	mov	ecx, DWORD PTR _temp$[ebp]
	call	?Load@CModel@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUID3D10EffectTechnique@@_N@Z ; CModel::Load
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN16@TestItems
	mov	DWORD PTR tv194[ebp], 1
	jmp	SHORT $LN17@TestItems
$LN16@TestItems:
	mov	DWORD PTR tv194[ebp], 0
$LN17@TestItems:
	mov	al, BYTE PTR tv194[ebp]
	mov	BYTE PTR $T14[ebp], al
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T4[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	movzx	ecx, BYTE PTR $T14[ebp]
	test	ecx, ecx
	je	SHORT $LN1@TestItems
	xor	al, al
	jmp	$LN8@TestItems
$LN1@TestItems:

; 962  : 		mpLights[miNumLights]->SetModel(temp);

	mov	eax, DWORD PTR _temp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8132]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+8012]
	call	?SetModel@CLight@@QAEXPAVCModel@@@Z	; CLight::SetModel

; 963  : 		mpLights[miNumLights]->SetColour(i/10.0f, i/10.0f, 1.0f);

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _i$15[ebp]
	divss	xmm0, DWORD PTR __real@41200000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _i$15[ebp]
	divss	xmm0, DWORD PTR __real@41200000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8132]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+8012]
	call	?SetColour@CLight@@QAEXMMM@Z		; CLight::SetColour

; 964  : 		mpLights[miNumLights]->GetModel()->SetPosition( D3DXVECTOR3(200, 10, i*30.0f) );

	cvtsi2ss xmm0, DWORD PTR _i$15[ebp]
	mulss	xmm0, DWORD PTR __real@41f00000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@43480000
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T5[ebp]
	call	??0D3DXVECTOR3@@QAE@MMM@Z		; D3DXVECTOR3::D3DXVECTOR3
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8132]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+8012]
	call	?GetModel@CLight@@QAEPAVCModel@@XZ	; CLight::GetModel
	mov	ecx, eax
	call	?SetPosition@CModel@@QAEXUD3DXVECTOR3@@@Z ; CModel::SetPosition

; 965  : 		mpLights[miNumLights]->GetModel()->SetScale( i/10.0f );

	cvtsi2ss xmm0, DWORD PTR _i$15[ebp]
	divss	xmm0, DWORD PTR __real@41200000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8132]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+8012]
	call	?GetModel@CLight@@QAEPAVCModel@@XZ	; CLight::GetModel
	mov	ecx, eax
	call	?SetScale@CModel@@QAEXM@Z		; CModel::SetScale

; 966  : 		mpLights[miNumLights]->GetModel()->UpdateMatrix();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8132]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+8012]
	call	?GetModel@CLight@@QAEPAVCModel@@XZ	; CLight::GetModel
	mov	ecx, eax
	call	?UpdateMatrix@CModel@@QAEXXZ		; CModel::UpdateMatrix

; 967  : 		miNumLights++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8132]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8132], ecx

; 968  : 	}

	jmp	$LN3@TestItems
$LN2@TestItems:

; 969  : 	return true;

	mov	al, 1
$LN8@TestItems:

; 970  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 480				; 000001e0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?TestItems@CScene@@AAE_NXZ$0:
	mov	eax, DWORD PTR $T7[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?TestItems@CScene@@AAE_NXZ$1:
	mov	eax, DWORD PTR $T9[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?TestItems@CScene@@AAE_NXZ$2:
	mov	eax, DWORD PTR $T13[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?TestItems@CScene@@AAE_NXZ$3:
	lea	ecx, DWORD PTR $T4[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?TestItems@CScene@@AAE_NXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-484]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?TestItems@CScene@@AAE_NXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?TestItems@CScene@@AAE_NXZ ENDP				; CScene::TestItems
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\game-of-life\scene.cpp
;	COMDAT ?SceneItems@CScene@@AAE_NXZ
_TEXT	SEGMENT
tv740 = -1080						; size = 4
tv694 = -1080						; size = 4
tv636 = -1080						; size = 4
tv557 = -1080						; size = 4
tv499 = -1080						; size = 4
tv361 = -1080						; size = 4
tv347 = -1080						; size = 4
tv335 = -1080						; size = 4
tv251 = -1080						; size = 4
tv237 = -1080						; size = 4
tv225 = -1080						; size = 4
tv142 = -1080						; size = 4
tv128 = -1080						; size = 4
tv84 = -1080						; size = 4
$T2 = -1072						; size = 28
$T3 = -1036						; size = 12
$T4 = -1016						; size = 28
$T5 = -980						; size = 12
$T6 = -960						; size = 28
$T7 = -924						; size = 12
$T8 = -904						; size = 12
$T9 = -884						; size = 12
$T10 = -864						; size = 12
$T11 = -844						; size = 12
$T12 = -824						; size = 12
$T13 = -804						; size = 12
$T14 = -784						; size = 12
$T15 = -764						; size = 12
$T16 = -744						; size = 12
$T17 = -724						; size = 12
$T18 = -704						; size = 12
$T19 = -684						; size = 4
$T20 = -672						; size = 4
$T21 = -660						; size = 12
$T22 = -640						; size = 12
$T23 = -620						; size = 4
$T24 = -608						; size = 4
$T25 = -593						; size = 1
$T26 = -584						; size = 4
$T27 = -572						; size = 4
$T28 = -560						; size = 12
$T29 = -540						; size = 12
$T30 = -520						; size = 4
$T31 = -508						; size = 4
$T32 = -493						; size = 1
$T33 = -484						; size = 4
$T34 = -472						; size = 4
$T35 = -460						; size = 12
$T36 = -440						; size = 12
$T37 = -420						; size = 4
$T38 = -408						; size = 4
$T39 = -393						; size = 1
$T40 = -384						; size = 4
$T41 = -372						; size = 4
$T42 = -360						; size = 4
$T43 = -348						; size = 4
$T44 = -336						; size = 4
$T45 = -324						; size = 4
$T46 = -312						; size = 4
$T47 = -300						; size = 4
$T48 = -288						; size = 4
$T49 = -276						; size = 4
_temp$ = -72						; size = 4
_zOff$ = -60						; size = 4
_yOff$ = -48						; size = 4
_xOff$ = -36						; size = 4
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?SceneItems@CScene@@AAE_NXZ PROC			; CScene::SceneItems, COMDAT
; _this$ = ecx

; 973  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SceneItems@CScene@@AAE_NXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 1068				; 0000042cH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-1080]
	mov	ecx, 267				; 0000010bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 974  : 	float xOff = -250.0f;

	movss	xmm0, DWORD PTR __real@c37a0000
	movss	DWORD PTR _xOff$[ebp], xmm0

; 975  : 	float yOff =  5.0f;

	movss	xmm0, DWORD PTR __real@40a00000
	movss	DWORD PTR _yOff$[ebp], xmm0

; 976  : 	float zOff = 50.0f;

	movss	xmm0, DWORD PTR __real@42480000
	movss	DWORD PTR _zOff$[ebp], xmm0

; 977  : 
; 978  : 	CModel* temp;
; 979  : 
; 980  : 	temp = new CModel;

	push	1936					; 00000790H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T20[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T20[ebp], 0
	je	$LN6@SceneItems
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T21[ebp]
	call	??0D3DXVECTOR3@@QAE@MMM@Z		; D3DXVECTOR3::D3DXVECTOR3
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T22[ebp]
	call	??0D3DXVECTOR3@@QAE@MMM@Z		; D3DXVECTOR3::D3DXVECTOR3
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, DWORD PTR $T20[ebp]
	call	??0CModel@@QAE@UD3DXVECTOR3@@0M@Z	; CModel::CModel
	mov	DWORD PTR tv84[ebp], eax
	jmp	SHORT $LN7@SceneItems
$LN6@SceneItems:
	mov	DWORD PTR tv84[ebp], 0
$LN7@SceneItems:
	mov	ecx, DWORD PTR tv84[ebp]
	mov	DWORD PTR $T19[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR $T19[ebp]
	mov	DWORD PTR _temp$[ebp], edx

; 981  : 	mpLights[miNumLights] = new CLight();

	push	92					; 0000005cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T24[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T24[ebp], 0
	je	SHORT $LN8@SceneItems
	mov	ecx, DWORD PTR $T24[ebp]
	call	??0CLight@@QAE@XZ			; CLight::CLight
	mov	DWORD PTR tv128[ebp], eax
	jmp	SHORT $LN9@SceneItems
$LN8@SceneItems:
	mov	DWORD PTR tv128[ebp], 0
$LN9@SceneItems:
	mov	eax, DWORD PTR tv128[ebp]
	mov	DWORD PTR $T23[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8132]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T23[ebp]
	mov	DWORD PTR [eax+edx*4+8012], ecx

; 982  : 	if (!temp->	Load( "Sphere.x", mTechniques[0] )) return false;

	push	OFFSET ??_C@_08EEMGLHJD@Sphere?4x?$AA@
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	push	0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+24160]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _temp$[ebp]
	call	?Load@CModel@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUID3D10EffectTechnique@@_N@Z ; CModel::Load
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN10@SceneItems
	mov	DWORD PTR tv142[ebp], 1
	jmp	SHORT $LN11@SceneItems
$LN10@SceneItems:
	mov	DWORD PTR tv142[ebp], 0
$LN11@SceneItems:
	mov	al, BYTE PTR tv142[ebp]
	mov	BYTE PTR $T25[ebp], al
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	movzx	ecx, BYTE PTR $T25[ebp]
	test	ecx, ecx
	je	SHORT $LN3@SceneItems
	xor	al, al
	jmp	$LN4@SceneItems
$LN3@SceneItems:

; 983  : 	mpLights[miNumLights]->SetModel(temp);

	mov	eax, DWORD PTR _temp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8132]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+8012]
	call	?SetModel@CLight@@QAEXPAVCModel@@@Z	; CLight::SetModel

; 984  : 	mpLights[miNumLights]->SetColour(1.0f, 1.0f, 1.0f);

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8132]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+8012]
	call	?SetColour@CLight@@QAEXMMM@Z		; CLight::SetColour

; 985  : 	mpLights[miNumLights]->GetModel()->SetPosition( D3DXVECTOR3(xOff, yOff+50.0f, zOff) );

	push	ecx
	movss	xmm0, DWORD PTR _zOff$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _yOff$[ebp]
	addss	xmm0, DWORD PTR __real@42480000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xOff$[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T3[ebp]
	call	??0D3DXVECTOR3@@QAE@MMM@Z		; D3DXVECTOR3::D3DXVECTOR3
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8132]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+8012]
	call	?GetModel@CLight@@QAEPAVCModel@@XZ	; CLight::GetModel
	mov	ecx, eax
	call	?SetPosition@CModel@@QAEXUD3DXVECTOR3@@@Z ; CModel::SetPosition

; 986  : 	mpLights[miNumLights]->GetModel()->SetScale( 0.2f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3e4ccccd
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8132]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+8012]
	call	?GetModel@CLight@@QAEPAVCModel@@XZ	; CLight::GetModel
	mov	ecx, eax
	call	?SetScale@CModel@@QAEXM@Z		; CModel::SetScale

; 987  : 	mpLights[miNumLights]->SetBrightness( 10.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8132]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+8012]
	call	?SetBrightness@CLight@@QAEXM@Z		; CLight::SetBrightness

; 988  : 	mpLights[miNumLights]->GetModel()->UpdateMatrix();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8132]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+8012]
	call	?GetModel@CLight@@QAEPAVCModel@@XZ	; CLight::GetModel
	mov	ecx, eax
	call	?UpdateMatrix@CModel@@QAEXXZ		; CModel::UpdateMatrix

; 989  : 	miNumLights++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8132]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8132], ecx

; 990  : 
; 991  : 	temp = new CModel;

	push	1936					; 00000790H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T27[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 3
	cmp	DWORD PTR $T27[ebp], 0
	je	$LN12@SceneItems
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T28[ebp]
	call	??0D3DXVECTOR3@@QAE@MMM@Z		; D3DXVECTOR3::D3DXVECTOR3
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T29[ebp]
	call	??0D3DXVECTOR3@@QAE@MMM@Z		; D3DXVECTOR3::D3DXVECTOR3
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, DWORD PTR $T27[ebp]
	call	??0CModel@@QAE@UD3DXVECTOR3@@0M@Z	; CModel::CModel
	mov	DWORD PTR tv225[ebp], eax
	jmp	SHORT $LN13@SceneItems
$LN12@SceneItems:
	mov	DWORD PTR tv225[ebp], 0
$LN13@SceneItems:
	mov	ecx, DWORD PTR tv225[ebp]
	mov	DWORD PTR $T26[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR $T26[ebp]
	mov	DWORD PTR _temp$[ebp], edx

; 992  : 	mpLights[miNumLights] = new CLight();

	push	92					; 0000005cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T31[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 4
	cmp	DWORD PTR $T31[ebp], 0
	je	SHORT $LN14@SceneItems
	mov	ecx, DWORD PTR $T31[ebp]
	call	??0CLight@@QAE@XZ			; CLight::CLight
	mov	DWORD PTR tv237[ebp], eax
	jmp	SHORT $LN15@SceneItems
$LN14@SceneItems:
	mov	DWORD PTR tv237[ebp], 0
$LN15@SceneItems:
	mov	eax, DWORD PTR tv237[ebp]
	mov	DWORD PTR $T30[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8132]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T30[ebp]
	mov	DWORD PTR [eax+edx*4+8012], ecx

; 993  : 	if (!temp->	Load( "Sphere.x", mTechniques[0] )) return false;

	push	OFFSET ??_C@_08EEMGLHJD@Sphere?4x?$AA@
	lea	ecx, DWORD PTR $T4[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 5
	push	0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+24160]
	push	eax
	lea	ecx, DWORD PTR $T4[ebp]
	push	ecx
	mov	ecx, DWORD PTR _temp$[ebp]
	call	?Load@CModel@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUID3D10EffectTechnique@@_N@Z ; CModel::Load
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN16@SceneItems
	mov	DWORD PTR tv251[ebp], 1
	jmp	SHORT $LN17@SceneItems
$LN16@SceneItems:
	mov	DWORD PTR tv251[ebp], 0
$LN17@SceneItems:
	mov	al, BYTE PTR tv251[ebp]
	mov	BYTE PTR $T32[ebp], al
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T4[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	movzx	ecx, BYTE PTR $T32[ebp]
	test	ecx, ecx
	je	SHORT $LN2@SceneItems
	xor	al, al
	jmp	$LN4@SceneItems
$LN2@SceneItems:

; 994  : 	mpLights[miNumLights]->SetModel(temp);

	mov	eax, DWORD PTR _temp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8132]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+8012]
	call	?SetModel@CLight@@QAEXPAVCModel@@@Z	; CLight::SetModel

; 995  : 	mpLights[miNumLights]->SetColour(1.0f, 1.0f, 1.0f);

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8132]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+8012]
	call	?SetColour@CLight@@QAEXMMM@Z		; CLight::SetColour

; 996  : 	mpLights[miNumLights]->GetModel()->SetPosition( D3DXVECTOR3(xOff, yOff+80.0f, zOff+30.0f) );

	movss	xmm0, DWORD PTR _zOff$[ebp]
	addss	xmm0, DWORD PTR __real@41f00000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _yOff$[ebp]
	addss	xmm0, DWORD PTR __real@42a00000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xOff$[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T5[ebp]
	call	??0D3DXVECTOR3@@QAE@MMM@Z		; D3DXVECTOR3::D3DXVECTOR3
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8132]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+8012]
	call	?GetModel@CLight@@QAEPAVCModel@@XZ	; CLight::GetModel
	mov	ecx, eax
	call	?SetPosition@CModel@@QAEXUD3DXVECTOR3@@@Z ; CModel::SetPosition

; 997  : 	mpLights[miNumLights]->GetModel()->SetScale( 0.2f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3e4ccccd
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8132]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+8012]
	call	?GetModel@CLight@@QAEPAVCModel@@XZ	; CLight::GetModel
	mov	ecx, eax
	call	?SetScale@CModel@@QAEXM@Z		; CModel::SetScale

; 998  : 	mpLights[miNumLights]->SetBrightness( 40.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@42200000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8132]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+8012]
	call	?SetBrightness@CLight@@QAEXM@Z		; CLight::SetBrightness

; 999  : 	mpLights[miNumLights]->GetModel()->UpdateMatrix();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8132]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+8012]
	call	?GetModel@CLight@@QAEPAVCModel@@XZ	; CLight::GetModel
	mov	ecx, eax
	call	?UpdateMatrix@CModel@@QAEXXZ		; CModel::UpdateMatrix

; 1000 : 	miNumLights++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8132]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8132], ecx

; 1001 : 
; 1002 : 	temp = new CModel;

	push	1936					; 00000790H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T34[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 6
	cmp	DWORD PTR $T34[ebp], 0
	je	$LN18@SceneItems
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T35[ebp]
	call	??0D3DXVECTOR3@@QAE@MMM@Z		; D3DXVECTOR3::D3DXVECTOR3
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T36[ebp]
	call	??0D3DXVECTOR3@@QAE@MMM@Z		; D3DXVECTOR3::D3DXVECTOR3
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, DWORD PTR $T34[ebp]
	call	??0CModel@@QAE@UD3DXVECTOR3@@0M@Z	; CModel::CModel
	mov	DWORD PTR tv335[ebp], eax
	jmp	SHORT $LN19@SceneItems
$LN18@SceneItems:
	mov	DWORD PTR tv335[ebp], 0
$LN19@SceneItems:
	mov	ecx, DWORD PTR tv335[ebp]
	mov	DWORD PTR $T33[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR $T33[ebp]
	mov	DWORD PTR _temp$[ebp], edx

; 1003 : 	mpLights[miNumLights] = new CLight();

	push	92					; 0000005cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T38[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 7
	cmp	DWORD PTR $T38[ebp], 0
	je	SHORT $LN20@SceneItems
	mov	ecx, DWORD PTR $T38[ebp]
	call	??0CLight@@QAE@XZ			; CLight::CLight
	mov	DWORD PTR tv347[ebp], eax
	jmp	SHORT $LN21@SceneItems
$LN20@SceneItems:
	mov	DWORD PTR tv347[ebp], 0
$LN21@SceneItems:
	mov	eax, DWORD PTR tv347[ebp]
	mov	DWORD PTR $T37[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8132]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T37[ebp]
	mov	DWORD PTR [eax+edx*4+8012], ecx

; 1004 : 	if (!temp->	Load( "Sphere.x", mTechniques[0] )) return false;

	push	OFFSET ??_C@_08EEMGLHJD@Sphere?4x?$AA@
	lea	ecx, DWORD PTR $T6[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 8
	push	0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+24160]
	push	eax
	lea	ecx, DWORD PTR $T6[ebp]
	push	ecx
	mov	ecx, DWORD PTR _temp$[ebp]
	call	?Load@CModel@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUID3D10EffectTechnique@@_N@Z ; CModel::Load
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN22@SceneItems
	mov	DWORD PTR tv361[ebp], 1
	jmp	SHORT $LN23@SceneItems
$LN22@SceneItems:
	mov	DWORD PTR tv361[ebp], 0
$LN23@SceneItems:
	mov	al, BYTE PTR tv361[ebp]
	mov	BYTE PTR $T39[ebp], al
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T6[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	movzx	ecx, BYTE PTR $T39[ebp]
	test	ecx, ecx
	je	SHORT $LN1@SceneItems
	xor	al, al
	jmp	$LN4@SceneItems
$LN1@SceneItems:

; 1005 : 	mpLights[miNumLights]->SetModel(temp);

	mov	eax, DWORD PTR _temp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8132]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+8012]
	call	?SetModel@CLight@@QAEXPAVCModel@@@Z	; CLight::SetModel

; 1006 : 	mpLights[miNumLights]->SetColour(1.0f, 1.0f, 1.0f);

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8132]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+8012]
	call	?SetColour@CLight@@QAEXMMM@Z		; CLight::SetColour

; 1007 : 	mpLights[miNumLights]->GetModel()->SetPosition( D3DXVECTOR3(xOff, yOff+80.0f, zOff-30.0f) );

	movss	xmm0, DWORD PTR _zOff$[ebp]
	subss	xmm0, DWORD PTR __real@41f00000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _yOff$[ebp]
	addss	xmm0, DWORD PTR __real@42a00000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xOff$[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T7[ebp]
	call	??0D3DXVECTOR3@@QAE@MMM@Z		; D3DXVECTOR3::D3DXVECTOR3
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8132]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+8012]
	call	?GetModel@CLight@@QAEPAVCModel@@XZ	; CLight::GetModel
	mov	ecx, eax
	call	?SetPosition@CModel@@QAEXUD3DXVECTOR3@@@Z ; CModel::SetPosition

; 1008 : 	mpLights[miNumLights]->GetModel()->SetScale( 0.2f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3e4ccccd
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8132]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+8012]
	call	?GetModel@CLight@@QAEPAVCModel@@XZ	; CLight::GetModel
	mov	ecx, eax
	call	?SetScale@CModel@@QAEXM@Z		; CModel::SetScale

; 1009 : 	mpLights[miNumLights]->SetBrightness( 40.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@42200000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8132]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+8012]
	call	?SetBrightness@CLight@@QAEXM@Z		; CLight::SetBrightness

; 1010 : 	mpLights[miNumLights]->GetModel()->UpdateMatrix();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8132]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+8012]
	call	?GetModel@CLight@@QAEPAVCModel@@XZ	; CLight::GetModel
	mov	ecx, eax
	call	?UpdateMatrix@CModel@@QAEXXZ		; CModel::UpdateMatrix

; 1011 : 	miNumLights++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8132]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8132], ecx

; 1012 : 
; 1013 : 	mpObjects[miNumObjects] = new CRenderObject("Troll.x", D3DXVECTOR3(xOff, yOff, 25.0f+zOff), D3DXVECTOR3( 0.8f, 0.8f, 0.0f ), mTechniques[TripleOutline], mTechniquesMirror[TripleOutline], mpMaps[9], NULL, true, true, false ); 

	push	72					; 00000048H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T41[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 9
	cmp	DWORD PTR $T41[ebp], 0
	je	$LN24@SceneItems
	push	0
	push	1
	push	1
	push	0
	mov	eax, 4
	imul	ecx, eax, 9
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+8136]
	push	eax
	mov	ecx, 4
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+24280]
	push	eax
	mov	ecx, 4
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+24160]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T9[ebp]
	call	??0D3DXVECTOR3@@QAE@MMM@Z		; D3DXVECTOR3::D3DXVECTOR3
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	movss	xmm0, DWORD PTR __real@41c80000
	addss	xmm0, DWORD PTR _zOff$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _yOff$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xOff$[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T8[ebp]
	call	??0D3DXVECTOR3@@QAE@MMM@Z		; D3DXVECTOR3::D3DXVECTOR3
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	push	OFFSET ??_C@_07DBODOLME@Troll?4x?$AA@
	mov	ecx, DWORD PTR $T41[ebp]
	call	??0CRenderObject@@QAE@QADUD3DXVECTOR3@@1PAUID3D10EffectTechnique@@2PAUID3D10ShaderResourceView@@3_N44@Z ; CRenderObject::CRenderObject
	mov	DWORD PTR tv499[ebp], eax
	jmp	SHORT $LN25@SceneItems
$LN24@SceneItems:
	mov	DWORD PTR tv499[ebp], 0
$LN25@SceneItems:
	mov	ecx, DWORD PTR tv499[ebp]
	mov	DWORD PTR $T40[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8008]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T40[ebp]
	mov	DWORD PTR [ecx+eax*4+8], edx

; 1014 : 	mpObjects[miNumObjects]->GetModel()->SetScale(10.0f);

	push	ecx
	movss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8008]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+8]
	call	?GetModel@CRenderObject@@QAEPAVCModel@@XZ ; CRenderObject::GetModel
	mov	ecx, eax
	call	?SetScale@CModel@@QAEXM@Z		; CModel::SetScale

; 1015 : 	miNumObjects++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8008]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8008], ecx

; 1016 : 
; 1017 : 	mpObjects[miNumObjects] = new CRenderObject("Troll.x", D3DXVECTOR3(xOff, yOff, -25.0f+zOff), D3DXVECTOR3( 0.8f, 0.8f, 0.0f ), mTechniques[TextureMorph], mTechniquesMirror[TextureMorph], mpMaps[10], mpMaps[11], true, false, false ); 

	push	72					; 00000048H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T43[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 10		; 0000000aH
	cmp	DWORD PTR $T43[ebp], 0
	je	$LN26@SceneItems
	push	0
	push	0
	push	1
	mov	eax, 4
	imul	ecx, eax, 11
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+8136]
	push	eax
	mov	ecx, 4
	imul	edx, ecx, 10
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+8136]
	push	ecx
	mov	edx, 4
	imul	eax, edx, 17
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+24280]
	push	edx
	mov	eax, 4
	imul	ecx, eax, 17
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+24160]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T11[ebp]
	call	??0D3DXVECTOR3@@QAE@MMM@Z		; D3DXVECTOR3::D3DXVECTOR3
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	movss	xmm0, DWORD PTR __real@c1c80000
	addss	xmm0, DWORD PTR _zOff$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _yOff$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xOff$[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T10[ebp]
	call	??0D3DXVECTOR3@@QAE@MMM@Z		; D3DXVECTOR3::D3DXVECTOR3
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	push	OFFSET ??_C@_07DBODOLME@Troll?4x?$AA@
	mov	ecx, DWORD PTR $T43[ebp]
	call	??0CRenderObject@@QAE@QADUD3DXVECTOR3@@1PAUID3D10EffectTechnique@@2PAUID3D10ShaderResourceView@@3_N44@Z ; CRenderObject::CRenderObject
	mov	DWORD PTR tv557[ebp], eax
	jmp	SHORT $LN27@SceneItems
$LN26@SceneItems:
	mov	DWORD PTR tv557[ebp], 0
$LN27@SceneItems:
	mov	ecx, DWORD PTR tv557[ebp]
	mov	DWORD PTR $T42[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8008]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T42[ebp]
	mov	DWORD PTR [ecx+eax*4+8], edx

; 1018 : 	mpObjects[miNumObjects]->GetModel()->SetScale(10.0f);

	push	ecx
	movss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8008]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+8]
	call	?GetModel@CRenderObject@@QAEPAVCModel@@XZ ; CRenderObject::GetModel
	mov	ecx, eax
	call	?SetScale@CModel@@QAEXM@Z		; CModel::SetScale

; 1019 : 	mpObjects[miNumObjects]->GetModel()->SetRotation(D3DXVECTOR3( 0.0f, (float)D3DX_PI, 0.0f ) );

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@40490fdb
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T12[ebp]
	call	??0D3DXVECTOR3@@QAE@MMM@Z		; D3DXVECTOR3::D3DXVECTOR3
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8008]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+8]
	call	?GetModel@CRenderObject@@QAEPAVCModel@@XZ ; CRenderObject::GetModel
	mov	ecx, eax
	call	?SetRotation@CModel@@QAEXUD3DXVECTOR3@@@Z ; CModel::SetRotation

; 1020 : 	mpObjects[miNumObjects]->SetWiggle( 2.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8008]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+8]
	call	?SetWiggle@CRenderObject@@QAEXM@Z	; CRenderObject::SetWiggle

; 1021 : 	miNumObjects++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8008]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8008], ecx

; 1022 : 
; 1023 : 	mpObjects[miNumObjects] = new CRenderObject("Cube.x", D3DXVECTOR3( xOff, yOff+5.0f, zOff), D3DXVECTOR3( 1.0f, 1.0f, 1.0f ), mTechniques[ParallaxMapped], mTechniquesMirror[ParallaxMapped], mpMaps[6], mpMaps[7], true, false, true);

	push	72					; 00000048H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T45[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 11		; 0000000bH
	cmp	DWORD PTR $T45[ebp], 0
	je	$LN28@SceneItems
	push	1
	push	0
	push	1
	mov	eax, 4
	imul	ecx, eax, 7
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+8136]
	push	eax
	mov	ecx, 4
	imul	edx, ecx, 6
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+8136]
	push	ecx
	mov	edx, 4
	imul	eax, edx, 7
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+24280]
	push	edx
	mov	eax, 4
	imul	ecx, eax, 7
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+24160]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T14[ebp]
	call	??0D3DXVECTOR3@@QAE@MMM@Z		; D3DXVECTOR3::D3DXVECTOR3
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	push	ecx
	movss	xmm0, DWORD PTR _zOff$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _yOff$[ebp]
	addss	xmm0, DWORD PTR __real@40a00000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xOff$[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T13[ebp]
	call	??0D3DXVECTOR3@@QAE@MMM@Z		; D3DXVECTOR3::D3DXVECTOR3
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	push	OFFSET ??_C@_06HGKAGIBP@Cube?4x?$AA@
	mov	ecx, DWORD PTR $T45[ebp]
	call	??0CRenderObject@@QAE@QADUD3DXVECTOR3@@1PAUID3D10EffectTechnique@@2PAUID3D10ShaderResourceView@@3_N44@Z ; CRenderObject::CRenderObject
	mov	DWORD PTR tv636[ebp], eax
	jmp	SHORT $LN29@SceneItems
$LN28@SceneItems:
	mov	DWORD PTR tv636[ebp], 0
$LN29@SceneItems:
	mov	ecx, DWORD PTR tv636[ebp]
	mov	DWORD PTR $T44[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8008]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T44[ebp]
	mov	DWORD PTR [ecx+eax*4+8], edx

; 1024 : 	mpObjects[miNumObjects]->GetModel()->SetScale(1.5f);

	push	ecx
	movss	xmm0, DWORD PTR __real@3fc00000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8008]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+8]
	call	?GetModel@CRenderObject@@QAEPAVCModel@@XZ ; CRenderObject::GetModel
	mov	ecx, eax
	call	?SetScale@CModel@@QAEXM@Z		; CModel::SetScale

; 1025 : 	miNumObjects++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8008]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8008], ecx

; 1026 : 
; 1027 : 	mpObjects[miNumObjects] = new CRenderObject("Teapot.x", D3DXVECTOR3( xOff, yOff+12.5f, zOff), D3DXVECTOR3( 1.0f, 1.0f, 1.0f ), mTechniques[ParallaxMapped], mTechniquesMirror[ParallaxMapped], mpMaps[13], mpMaps[14], true, false, true);

	push	72					; 00000048H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T47[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 12		; 0000000cH
	cmp	DWORD PTR $T47[ebp], 0
	je	$LN30@SceneItems
	push	1
	push	0
	push	1
	mov	eax, 4
	imul	ecx, eax, 14
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+8136]
	push	eax
	mov	ecx, 4
	imul	edx, ecx, 13
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+8136]
	push	ecx
	mov	edx, 4
	imul	eax, edx, 7
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+24280]
	push	edx
	mov	eax, 4
	imul	ecx, eax, 7
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+24160]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T16[ebp]
	call	??0D3DXVECTOR3@@QAE@MMM@Z		; D3DXVECTOR3::D3DXVECTOR3
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	push	ecx
	movss	xmm0, DWORD PTR _zOff$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _yOff$[ebp]
	addss	xmm0, DWORD PTR __real@41480000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xOff$[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T15[ebp]
	call	??0D3DXVECTOR3@@QAE@MMM@Z		; D3DXVECTOR3::D3DXVECTOR3
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	push	OFFSET ??_C@_08KCKKFACH@Teapot?4x?$AA@
	mov	ecx, DWORD PTR $T47[ebp]
	call	??0CRenderObject@@QAE@QADUD3DXVECTOR3@@1PAUID3D10EffectTechnique@@2PAUID3D10ShaderResourceView@@3_N44@Z ; CRenderObject::CRenderObject
	mov	DWORD PTR tv694[ebp], eax
	jmp	SHORT $LN31@SceneItems
$LN30@SceneItems:
	mov	DWORD PTR tv694[ebp], 0
$LN31@SceneItems:
	mov	ecx, DWORD PTR tv694[ebp]
	mov	DWORD PTR $T46[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8008]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T46[ebp]
	mov	DWORD PTR [ecx+eax*4+8], edx

; 1028 : 	miNumObjects++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8008]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8008], ecx

; 1029 : 
; 1030 : 	
; 1031 : 	mpObjects[miNumObjects] = new CRenderObject("Cube.x", D3DXVECTOR3(xOff, yOff+15.0f, zOff), D3DXVECTOR3( 0.8f, 0.8f, 0.0f ), mTechniques[LitGlass], mTechniquesMirror[LitGlass], mpMaps[8], NULL, true, true, false ); 

	push	72					; 00000048H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T49[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 13		; 0000000dH
	cmp	DWORD PTR $T49[ebp], 0
	je	$LN32@SceneItems
	push	0
	push	1
	push	1
	push	0
	mov	eax, 4
	shl	eax, 3
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+8136]
	push	edx
	mov	eax, 4
	imul	ecx, eax, 14
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+24280]
	push	eax
	mov	ecx, 4
	imul	edx, ecx, 14
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+24160]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T18[ebp]
	call	??0D3DXVECTOR3@@QAE@MMM@Z		; D3DXVECTOR3::D3DXVECTOR3
	sub	esp, 12					; 0000000cH
	mov	edx, esp
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax
	push	ecx
	movss	xmm0, DWORD PTR _zOff$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _yOff$[ebp]
	addss	xmm0, DWORD PTR __real@41700000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xOff$[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T17[ebp]
	call	??0D3DXVECTOR3@@QAE@MMM@Z		; D3DXVECTOR3::D3DXVECTOR3
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	push	OFFSET ??_C@_06HGKAGIBP@Cube?4x?$AA@
	mov	ecx, DWORD PTR $T49[ebp]
	call	??0CRenderObject@@QAE@QADUD3DXVECTOR3@@1PAUID3D10EffectTechnique@@2PAUID3D10ShaderResourceView@@3_N44@Z ; CRenderObject::CRenderObject
	mov	DWORD PTR tv740[ebp], eax
	jmp	SHORT $LN33@SceneItems
$LN32@SceneItems:
	mov	DWORD PTR tv740[ebp], 0
$LN33@SceneItems:
	mov	ecx, DWORD PTR tv740[ebp]
	mov	DWORD PTR $T48[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8008]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T48[ebp]
	mov	DWORD PTR [ecx+eax*4+8], edx

; 1032 : 	mpObjects[miNumObjects]->GetModel()->SetScale(10.0f);

	push	ecx
	movss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8008]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+8]
	call	?GetModel@CRenderObject@@QAEPAVCModel@@XZ ; CRenderObject::GetModel
	mov	ecx, eax
	call	?SetScale@CModel@@QAEXM@Z		; CModel::SetScale

; 1033 : 	miNumObjects++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8008]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8008], ecx

; 1034 : 	
; 1035 : 
; 1036 : 	return true;

	mov	al, 1
$LN4@SceneItems:

; 1037 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 1080				; 00000438H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SceneItems@CScene@@AAE_NXZ$0:
	mov	eax, DWORD PTR $T20[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?SceneItems@CScene@@AAE_NXZ$1:
	mov	eax, DWORD PTR $T24[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?SceneItems@CScene@@AAE_NXZ$2:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SceneItems@CScene@@AAE_NXZ$3:
	mov	eax, DWORD PTR $T27[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?SceneItems@CScene@@AAE_NXZ$4:
	mov	eax, DWORD PTR $T31[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?SceneItems@CScene@@AAE_NXZ$5:
	lea	ecx, DWORD PTR $T4[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SceneItems@CScene@@AAE_NXZ$6:
	mov	eax, DWORD PTR $T34[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?SceneItems@CScene@@AAE_NXZ$7:
	mov	eax, DWORD PTR $T38[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?SceneItems@CScene@@AAE_NXZ$8:
	lea	ecx, DWORD PTR $T6[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SceneItems@CScene@@AAE_NXZ$9:
	mov	eax, DWORD PTR $T41[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?SceneItems@CScene@@AAE_NXZ$10:
	mov	eax, DWORD PTR $T43[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?SceneItems@CScene@@AAE_NXZ$11:
	mov	eax, DWORD PTR $T45[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?SceneItems@CScene@@AAE_NXZ$12:
	mov	eax, DWORD PTR $T47[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?SceneItems@CScene@@AAE_NXZ$13:
	mov	eax, DWORD PTR $T49[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?SceneItems@CScene@@AAE_NXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-1084]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?SceneItems@CScene@@AAE_NXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?SceneItems@CScene@@AAE_NXZ ENDP			; CScene::SceneItems
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\game-of-life\scene.cpp
;	COMDAT ?BasicItems@CScene@@AAE_NXZ
_TEXT	SEGMENT
tv1218 = -1684						; size = 4
tv1204 = -1684						; size = 4
tv1192 = -1684						; size = 4
tv1103 = -1684						; size = 4
tv1089 = -1684						; size = 4
tv1077 = -1684						; size = 4
tv982 = -1684						; size = 4
tv968 = -1684						; size = 4
tv924 = -1684						; size = 4
tv900 = -1684						; size = 4
tv846 = -1684						; size = 4
tv789 = -1684						; size = 4
tv732 = -1684						; size = 4
tv675 = -1684						; size = 4
tv621 = -1684						; size = 4
tv576 = -1684						; size = 4
tv531 = -1684						; size = 4
tv448 = -1684						; size = 4
tv389 = -1684						; size = 4
tv344 = -1684						; size = 4
tv299 = -1684						; size = 4
tv247 = -1684						; size = 4
tv195 = -1684						; size = 4
tv140 = -1684						; size = 4
$T2 = -1676						; size = 12
$T3 = -1656						; size = 12
$T4 = -1636						; size = 12
$T5 = -1616						; size = 12
$T6 = -1596						; size = 12
$T7 = -1576						; size = 12
$T8 = -1556						; size = 12
$T9 = -1536						; size = 12
$T10 = -1516						; size = 12
$T11 = -1496						; size = 12
$T12 = -1476						; size = 12
$T13 = -1456						; size = 12
$T14 = -1436						; size = 12
$T15 = -1416						; size = 12
$T16 = -1396						; size = 12
$T17 = -1376						; size = 12
$T18 = -1356						; size = 12
$T19 = -1336						; size = 12
$T20 = -1316						; size = 12
$T21 = -1296						; size = 12
$T22 = -1276						; size = 12
$T23 = -1256						; size = 12
$T24 = -1236						; size = 12
$T25 = -1216						; size = 12
$T26 = -1196						; size = 12
$T27 = -1176						; size = 12
$T28 = -1156						; size = 12
$T29 = -1136						; size = 12
$T30 = -1116						; size = 12
$T31 = -1096						; size = 12
$T32 = -1076						; size = 4
$T33 = -1064						; size = 4
$T34 = -1052						; size = 4
$T35 = -1040						; size = 28
$T36 = -1004						; size = 4
$T37 = -992						; size = 12
$T38 = -972						; size = 4
$T39 = -960						; size = 12
$T40 = -940						; size = 4
$T41 = -928						; size = 4
$T42 = -916						; size = 4
$T43 = -904						; size = 4
$T44 = -892						; size = 4
$T45 = -880						; size = 28
$T46 = -844						; size = 4
$T47 = -832						; size = 4
$T48 = -820						; size = 12
$T49 = -800						; size = 4
$T50 = -788						; size = 4
$T51 = -776						; size = 4
$T52 = -764						; size = 4
$T53 = -752						; size = 4
$T54 = -740						; size = 4
$T55 = -728						; size = 28
$T56 = -692						; size = 4
$T57 = -680						; size = 12
$T58 = -660						; size = 4
$T59 = -648						; size = 4
$T60 = -636						; size = 4
$T61 = -624						; size = 4
$T62 = -612						; size = 4
$T63 = -600						; size = 4
$T64 = -588						; size = 4
$T65 = -576						; size = 4
$T66 = -564						; size = 4
$T67 = -552						; size = 4
$T68 = -540						; size = 4
$T69 = -528						; size = 4
$T70 = -516						; size = 4
$T71 = -504						; size = 12
$T72 = -484						; size = 12
$T73 = -464						; size = 4
$T74 = -452						; size = 4
$T75 = -437						; size = 1
$T76 = -428						; size = 4
$T77 = -416						; size = 4
$T78 = -404						; size = 12
$T79 = -384						; size = 12
$T80 = -364						; size = 4
$T81 = -352						; size = 4
$T82 = -337						; size = 1
$T83 = -328						; size = 4
$T84 = -316						; size = 4
$T85 = -304						; size = 12
$T86 = -284						; size = 12
$T87 = -264						; size = 4
$T88 = -252						; size = 4
$T89 = -237						; size = 1
_temp$ = -36						; size = 4
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?BasicItems@CScene@@AAE_NXZ PROC			; CScene::BasicItems, COMDAT
; _this$ = ecx

; 803  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?BasicItems@CScene@@AAE_NXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 1672				; 00000688H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-1684]
	mov	ecx, 418				; 000001a2H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 804  : 	
; 805  : 	//Parallax mapped cube
; 806  : 	mpObjects[miNumObjects] = new CRenderObject("Cube.x",	D3DXVECTOR3(0, 10, 0),			D3DXVECTOR3(1.0f, 1.0f, 1.0f), mTechniques[7], mTechniquesMirror[7], mpMaps[3], mpMaps[4], true, false, true);

	push	72					; 00000048H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T33[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T33[ebp], 0
	je	$LN6@BasicItems
	push	1
	push	0
	push	1
	mov	eax, 4
	shl	eax, 2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+8136]
	push	edx
	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+8136]
	push	eax
	mov	ecx, 4
	imul	edx, ecx, 7
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+24280]
	push	ecx
	mov	edx, 4
	imul	eax, edx, 7
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+24160]
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T3[ebp]
	call	??0D3DXVECTOR3@@QAE@MMM@Z		; D3DXVECTOR3::D3DXVECTOR3
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0D3DXVECTOR3@@QAE@MMM@Z		; D3DXVECTOR3::D3DXVECTOR3
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	push	OFFSET ??_C@_06HGKAGIBP@Cube?4x?$AA@
	mov	ecx, DWORD PTR $T33[ebp]
	call	??0CRenderObject@@QAE@QADUD3DXVECTOR3@@1PAUID3D10EffectTechnique@@2PAUID3D10ShaderResourceView@@3_N44@Z ; CRenderObject::CRenderObject
	mov	DWORD PTR tv140[ebp], eax
	jmp	SHORT $LN7@BasicItems
$LN6@BasicItems:
	mov	DWORD PTR tv140[ebp], 0
$LN7@BasicItems:
	mov	ecx, DWORD PTR tv140[ebp]
	mov	DWORD PTR $T32[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8008]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T32[ebp]
	mov	DWORD PTR [ecx+eax*4+8], edx

; 807  : 	mpObjects[miNumObjects]->SetSpinY(0.5f);

	push	ecx
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8008]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+8]
	call	?SetSpinY@CRenderObject@@QAEXM@Z	; CRenderObject::SetSpinY

; 808  : 	miNumObjects++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8008]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8008], ecx

; 809  : 
; 810  : 	//Parallax mapped cube
; 811  : 	mpObjects[miNumObjects] = new CRenderObject("Cube.x",	D3DXVECTOR3(0, 10, 40),			D3DXVECTOR3(1.0f, 1.0f, 1.0f), mTechniques[7], mTechniquesMirror[7], mpMaps[6], mpMaps[7], true, false, true);

	push	72					; 00000048H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T36[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T36[ebp], 0
	je	$LN8@BasicItems
	push	1
	push	0
	push	1
	mov	eax, 4
	imul	ecx, eax, 7
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+8136]
	push	eax
	mov	ecx, 4
	imul	edx, ecx, 6
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+8136]
	push	ecx
	mov	edx, 4
	imul	eax, edx, 7
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+24280]
	push	edx
	mov	eax, 4
	imul	ecx, eax, 7
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+24160]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T5[ebp]
	call	??0D3DXVECTOR3@@QAE@MMM@Z		; D3DXVECTOR3::D3DXVECTOR3
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	push	ecx
	movss	xmm0, DWORD PTR __real@42200000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T4[ebp]
	call	??0D3DXVECTOR3@@QAE@MMM@Z		; D3DXVECTOR3::D3DXVECTOR3
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	push	OFFSET ??_C@_06HGKAGIBP@Cube?4x?$AA@
	mov	ecx, DWORD PTR $T36[ebp]
	call	??0CRenderObject@@QAE@QADUD3DXVECTOR3@@1PAUID3D10EffectTechnique@@2PAUID3D10ShaderResourceView@@3_N44@Z ; CRenderObject::CRenderObject
	mov	DWORD PTR tv195[ebp], eax
	jmp	SHORT $LN9@BasicItems
$LN8@BasicItems:
	mov	DWORD PTR tv195[ebp], 0
$LN9@BasicItems:
	mov	ecx, DWORD PTR tv195[ebp]
	mov	DWORD PTR $T34[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8008]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T34[ebp]
	mov	DWORD PTR [ecx+eax*4+8], edx

; 812  : 	mpObjects[miNumObjects]->SetSpinY(0.5f);

	push	ecx
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8008]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+8]
	call	?SetSpinY@CRenderObject@@QAEXM@Z	; CRenderObject::SetSpinY

; 813  : 	miNumObjects++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8008]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8008], ecx

; 814  : 	
; 815  : 	//Jelly cube 
; 816  : 	
; 817  : 	mpObjects[miNumObjects] = new CRenderObject("Cube.x",	D3DXVECTOR3(40, 10, 40),		D3DXVECTOR3(1.0f, 1.0f, 1.0f), mTechniques[8], mTechniquesMirror[8], mpMaps[6], NULL, true, true);

	push	72					; 00000048H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T40[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	cmp	DWORD PTR $T40[ebp], 0
	je	$LN10@BasicItems
	push	0
	push	1
	push	1
	push	0
	mov	eax, 4
	imul	ecx, eax, 6
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+8136]
	push	eax
	mov	ecx, 4
	shl	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+24280]
	push	eax
	mov	ecx, 4
	shl	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+24160]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T7[ebp]
	call	??0D3DXVECTOR3@@QAE@MMM@Z		; D3DXVECTOR3::D3DXVECTOR3
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	push	ecx
	movss	xmm0, DWORD PTR __real@42200000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@42200000
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T6[ebp]
	call	??0D3DXVECTOR3@@QAE@MMM@Z		; D3DXVECTOR3::D3DXVECTOR3
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	push	OFFSET ??_C@_06HGKAGIBP@Cube?4x?$AA@
	mov	ecx, DWORD PTR $T40[ebp]
	call	??0CRenderObject@@QAE@QADUD3DXVECTOR3@@1PAUID3D10EffectTechnique@@2PAUID3D10ShaderResourceView@@3_N44@Z ; CRenderObject::CRenderObject
	mov	DWORD PTR tv247[ebp], eax
	jmp	SHORT $LN11@BasicItems
$LN10@BasicItems:
	mov	DWORD PTR tv247[ebp], 0
$LN11@BasicItems:
	mov	ecx, DWORD PTR tv247[ebp]
	mov	DWORD PTR $T38[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8008]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T38[ebp]
	mov	DWORD PTR [ecx+eax*4+8], edx

; 818  : 	mpObjects[miNumObjects]->SetWiggle( 2.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8008]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+8]
	call	?SetWiggle@CRenderObject@@QAEXM@Z	; CRenderObject::SetWiggle

; 819  : 	miNumObjects++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8008]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8008], ecx

; 820  : 	
; 821  : 	//Basic Cube
; 822  : 	mpObjects[miNumObjects] = new CRenderObject("Cube.x",	D3DXVECTOR3( 20, 10, 0 ),		D3DXVECTOR3(1.0f, 1.0f, 1.0f), mTechniques[1], mTechniquesMirror[1], mpMaps[0], NULL, false, false);

	push	72					; 00000048H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T42[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 3
	cmp	DWORD PTR $T42[ebp], 0
	je	$LN12@BasicItems
	push	0
	push	0
	push	0
	push	0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+8136]
	push	eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+24280]
	push	eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+24160]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T9[ebp]
	call	??0D3DXVECTOR3@@QAE@MMM@Z		; D3DXVECTOR3::D3DXVECTOR3
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@41a00000
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T8[ebp]
	call	??0D3DXVECTOR3@@QAE@MMM@Z		; D3DXVECTOR3::D3DXVECTOR3
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	push	OFFSET ??_C@_06HGKAGIBP@Cube?4x?$AA@
	mov	ecx, DWORD PTR $T42[ebp]
	call	??0CRenderObject@@QAE@QADUD3DXVECTOR3@@1PAUID3D10EffectTechnique@@2PAUID3D10ShaderResourceView@@3_N44@Z ; CRenderObject::CRenderObject
	mov	DWORD PTR tv299[ebp], eax
	jmp	SHORT $LN13@BasicItems
$LN12@BasicItems:
	mov	DWORD PTR tv299[ebp], 0
$LN13@BasicItems:
	mov	ecx, DWORD PTR tv299[ebp]
	mov	DWORD PTR $T41[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8008]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T41[ebp]
	mov	DWORD PTR [ecx+eax*4+8], edx

; 823  : 	miNumObjects++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8008]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8008], ecx

; 824  : 	
; 825  : 	//Specular mapped cube
; 826  : 	
; 827  : 	mpObjects[miNumObjects] = new CRenderObject("Cube.x",	D3DXVECTOR3(-20, 10, 0),		D3DXVECTOR3(1.0f, 1.0f, 1.0f), mTechniques[6], mTechniquesMirror[6], mpMaps[0], NULL, true, false);

	push	72					; 00000048H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T44[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 4
	cmp	DWORD PTR $T44[ebp], 0
	je	$LN14@BasicItems
	push	0
	push	0
	push	1
	push	0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+8136]
	push	eax
	mov	ecx, 4
	imul	edx, ecx, 6
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+24280]
	push	ecx
	mov	edx, 4
	imul	eax, edx, 6
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+24160]
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T11[ebp]
	call	??0D3DXVECTOR3@@QAE@MMM@Z		; D3DXVECTOR3::D3DXVECTOR3
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@c1a00000
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T10[ebp]
	call	??0D3DXVECTOR3@@QAE@MMM@Z		; D3DXVECTOR3::D3DXVECTOR3
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	push	OFFSET ??_C@_06HGKAGIBP@Cube?4x?$AA@
	mov	ecx, DWORD PTR $T44[ebp]
	call	??0CRenderObject@@QAE@QADUD3DXVECTOR3@@1PAUID3D10EffectTechnique@@2PAUID3D10ShaderResourceView@@3_N44@Z ; CRenderObject::CRenderObject
	mov	DWORD PTR tv344[ebp], eax
	jmp	SHORT $LN15@BasicItems
$LN14@BasicItems:
	mov	DWORD PTR tv344[ebp], 0
$LN15@BasicItems:
	mov	ecx, DWORD PTR tv344[ebp]
	mov	DWORD PTR $T43[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8008]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T43[ebp]
	mov	DWORD PTR [ecx+eax*4+8], edx

; 828  : 	miNumObjects++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8008]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8008], ecx

; 829  : 	
; 830  : 	//Shiny Teapot
; 831  : 	mpObjects[miNumObjects] = new CRenderObject("Teapot.x",	D3DXVECTOR3( 15, 5, 15 ),		D3DXVECTOR3(1.0f, 1.0f, 1.0f), mTechniques[5], mTechniquesMirror[5], mpMaps[2], NULL, true, false);

	push	72					; 00000048H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T47[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 5
	cmp	DWORD PTR $T47[ebp], 0
	je	$LN16@BasicItems
	push	0
	push	0
	push	1
	push	0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+8136]
	push	edx
	mov	eax, 4
	imul	ecx, eax, 5
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+24280]
	push	eax
	mov	ecx, 4
	imul	edx, ecx, 5
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+24160]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T13[ebp]
	call	??0D3DXVECTOR3@@QAE@MMM@Z		; D3DXVECTOR3::D3DXVECTOR3
	sub	esp, 12					; 0000000cH
	mov	edx, esp
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax
	push	ecx
	movss	xmm0, DWORD PTR __real@41700000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@40a00000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@41700000
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T12[ebp]
	call	??0D3DXVECTOR3@@QAE@MMM@Z		; D3DXVECTOR3::D3DXVECTOR3
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	push	OFFSET ??_C@_08KCKKFACH@Teapot?4x?$AA@
	mov	ecx, DWORD PTR $T47[ebp]
	call	??0CRenderObject@@QAE@QADUD3DXVECTOR3@@1PAUID3D10EffectTechnique@@2PAUID3D10ShaderResourceView@@3_N44@Z ; CRenderObject::CRenderObject
	mov	DWORD PTR tv389[ebp], eax
	jmp	SHORT $LN17@BasicItems
$LN16@BasicItems:
	mov	DWORD PTR tv389[ebp], 0
$LN17@BasicItems:
	mov	ecx, DWORD PTR tv389[ebp]
	mov	DWORD PTR $T46[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8008]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T46[ebp]
	mov	DWORD PTR [ecx+eax*4+8], edx

; 832  : 	mpObjects[miNumObjects]->SetSpinX(5.0f);

	push	ecx
	movss	xmm0, DWORD PTR __real@40a00000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8008]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+8]
	call	?SetSpinX@CRenderObject@@QAEXM@Z	; CRenderObject::SetSpinX

; 833  : 	mpObjects[miNumObjects]->SetSpinZ(2.5f);

	push	ecx
	movss	xmm0, DWORD PTR __real@40200000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8008]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+8]
	call	?SetSpinZ@CRenderObject@@QAEXM@Z	; CRenderObject::SetSpinZ

; 834  : 	miNumObjects++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8008]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8008], ecx

; 835  : 
; 836  : 	//Additive Blending Sphere
; 837  : 	
; 838  : 	mpObjects[miNumObjects] = new CRenderObject("Sphere.x",	D3DXVECTOR3(50, 30, 10),		D3DXVECTOR3(1.0f, 1.0f, 1.0f), mTechniques[2], mTechniquesMirror[2], mpMaps[0], NULL, false, true);

	push	72					; 00000048H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T50[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 6
	cmp	DWORD PTR $T50[ebp], 0
	je	$LN18@BasicItems
	push	0
	push	1
	push	0
	push	0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+8136]
	push	eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+24280]
	push	eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+24160]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T15[ebp]
	call	??0D3DXVECTOR3@@QAE@MMM@Z		; D3DXVECTOR3::D3DXVECTOR3
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	push	ecx
	movss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@41f00000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@42480000
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T14[ebp]
	call	??0D3DXVECTOR3@@QAE@MMM@Z		; D3DXVECTOR3::D3DXVECTOR3
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	push	OFFSET ??_C@_08EEMGLHJD@Sphere?4x?$AA@
	mov	ecx, DWORD PTR $T50[ebp]
	call	??0CRenderObject@@QAE@QADUD3DXVECTOR3@@1PAUID3D10EffectTechnique@@2PAUID3D10ShaderResourceView@@3_N44@Z ; CRenderObject::CRenderObject
	mov	DWORD PTR tv448[ebp], eax
	jmp	SHORT $LN19@BasicItems
$LN18@BasicItems:
	mov	DWORD PTR tv448[ebp], 0
$LN19@BasicItems:
	mov	ecx, DWORD PTR tv448[ebp]
	mov	DWORD PTR $T49[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8008]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T49[ebp]
	mov	DWORD PTR [ecx+eax*4+8], edx

; 839  : 	mpObjects[miNumObjects]->SetColourCycle();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8008]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+8]
	call	?SetColourCycle@CRenderObject@@QAEXXZ	; CRenderObject::SetColourCycle

; 840  : 	miNumObjects++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8008]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8008], ecx

; 841  : 	
; 842  : 	//4 Lit test cube
; 843  : 	mpObjects[miNumObjects] = new CRenderObject("Cube.x",	D3DXVECTOR3( 180, 5, 152 ),		D3DXVECTOR3(1.0f, 1.0f, 1.0f), mTechniques[4], mTechniquesMirror[4], mpMaps[0], NULL, true, false);

	push	72					; 00000048H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T52[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 7
	cmp	DWORD PTR $T52[ebp], 0
	je	$LN20@BasicItems
	push	0
	push	0
	push	1
	push	0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+8136]
	push	eax
	mov	ecx, 4
	shl	ecx, 2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+24280]
	push	eax
	mov	ecx, 4
	shl	ecx, 2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+24160]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T17[ebp]
	call	??0D3DXVECTOR3@@QAE@MMM@Z		; D3DXVECTOR3::D3DXVECTOR3
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	push	ecx
	movss	xmm0, DWORD PTR __real@43180000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@40a00000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@43340000
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T16[ebp]
	call	??0D3DXVECTOR3@@QAE@MMM@Z		; D3DXVECTOR3::D3DXVECTOR3
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	push	OFFSET ??_C@_06HGKAGIBP@Cube?4x?$AA@
	mov	ecx, DWORD PTR $T52[ebp]
	call	??0CRenderObject@@QAE@QADUD3DXVECTOR3@@1PAUID3D10EffectTechnique@@2PAUID3D10ShaderResourceView@@3_N44@Z ; CRenderObject::CRenderObject
	mov	DWORD PTR tv531[ebp], eax
	jmp	SHORT $LN21@BasicItems
$LN20@BasicItems:
	mov	DWORD PTR tv531[ebp], 0
$LN21@BasicItems:
	mov	ecx, DWORD PTR tv531[ebp]
	mov	DWORD PTR $T51[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8008]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T51[ebp]
	mov	DWORD PTR [ecx+eax*4+8], edx

; 844  : 	miNumObjects++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8008]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8008], ecx

; 845  : 
; 846  : 	//Disco Cube
; 847  : 	mpObjects[miNumObjects] = new CRenderObject("Cube.x",	D3DXVECTOR3( 200, 5, 200 ),		D3DXVECTOR3(1.0f, 1.0f, 1.0f), mTechniques[6], mTechniquesMirror[6], mpMaps[0], NULL, true, false);

	push	72					; 00000048H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T54[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 8
	cmp	DWORD PTR $T54[ebp], 0
	je	$LN22@BasicItems
	push	0
	push	0
	push	1
	push	0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+8136]
	push	eax
	mov	ecx, 4
	imul	edx, ecx, 6
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+24280]
	push	ecx
	mov	edx, 4
	imul	eax, edx, 6
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+24160]
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T19[ebp]
	call	??0D3DXVECTOR3@@QAE@MMM@Z		; D3DXVECTOR3::D3DXVECTOR3
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	push	ecx
	movss	xmm0, DWORD PTR __real@43480000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@40a00000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@43480000
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T18[ebp]
	call	??0D3DXVECTOR3@@QAE@MMM@Z		; D3DXVECTOR3::D3DXVECTOR3
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	push	OFFSET ??_C@_06HGKAGIBP@Cube?4x?$AA@
	mov	ecx, DWORD PTR $T54[ebp]
	call	??0CRenderObject@@QAE@QADUD3DXVECTOR3@@1PAUID3D10EffectTechnique@@2PAUID3D10ShaderResourceView@@3_N44@Z ; CRenderObject::CRenderObject
	mov	DWORD PTR tv576[ebp], eax
	jmp	SHORT $LN23@BasicItems
$LN22@BasicItems:
	mov	DWORD PTR tv576[ebp], 0
$LN23@BasicItems:
	mov	ecx, DWORD PTR tv576[ebp]
	mov	DWORD PTR $T53[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8008]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T53[ebp]
	mov	DWORD PTR [ecx+eax*4+8], edx

; 848  : 	miNumObjects++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8008]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8008], ecx

; 849  : 
; 850  : 	//Cell Shaded Troll
; 851  : 	mpObjects[miNumObjects] = new CRenderObject("Troll.x",	D3DXVECTOR3( 0, 0, -10 ),		D3DXVECTOR3( 0.0f, 0.0f, 0.0f), mTechniques[9], mTechniquesMirror[9], mpMaps[5], NULL, true, false);

	push	72					; 00000048H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T58[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 9
	cmp	DWORD PTR $T58[ebp], 0
	je	$LN24@BasicItems
	push	0
	push	0
	push	1
	push	0
	mov	eax, 4
	imul	ecx, eax, 5
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+8136]
	push	eax
	mov	ecx, 4
	imul	edx, ecx, 9
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+24280]
	push	ecx
	mov	edx, 4
	imul	eax, edx, 9
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+24160]
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T21[ebp]
	call	??0D3DXVECTOR3@@QAE@MMM@Z		; D3DXVECTOR3::D3DXVECTOR3
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	push	ecx
	movss	xmm0, DWORD PTR __real@c1200000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T20[ebp]
	call	??0D3DXVECTOR3@@QAE@MMM@Z		; D3DXVECTOR3::D3DXVECTOR3
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	push	OFFSET ??_C@_07DBODOLME@Troll?4x?$AA@
	mov	ecx, DWORD PTR $T58[ebp]
	call	??0CRenderObject@@QAE@QADUD3DXVECTOR3@@1PAUID3D10EffectTechnique@@2PAUID3D10ShaderResourceView@@3_N44@Z ; CRenderObject::CRenderObject
	mov	DWORD PTR tv621[ebp], eax
	jmp	SHORT $LN25@BasicItems
$LN24@BasicItems:
	mov	DWORD PTR tv621[ebp], 0
$LN25@BasicItems:
	mov	ecx, DWORD PTR tv621[ebp]
	mov	DWORD PTR $T56[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8008]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T56[ebp]
	mov	DWORD PTR [ecx+eax*4+8], edx

; 852  : 	mpObjects[miNumObjects]->GetModel()->SetScale( 5.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@40a00000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8008]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+8]
	call	?GetModel@CRenderObject@@QAEPAVCModel@@XZ ; CRenderObject::GetModel
	mov	ecx, eax
	call	?SetScale@CModel@@QAEXM@Z		; CModel::SetScale

; 853  : 	miNumObjects++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8008]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8008], ecx

; 854  : 
; 855  : 	//Wrongly Cell Shaded Troll
; 856  : 	mpObjects[miNumObjects] = new CRenderObject("Troll.x",	D3DXVECTOR3( 0, 0, -30 ),		D3DXVECTOR3( 0.0f, 0.0f, 0.0f), mTechniques[10], mTechniquesMirror[10], mpMaps[5], NULL, true, false);

	push	72					; 00000048H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T60[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 10		; 0000000aH
	cmp	DWORD PTR $T60[ebp], 0
	je	$LN26@BasicItems
	push	0
	push	0
	push	1
	push	0
	mov	eax, 4
	imul	ecx, eax, 5
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+8136]
	push	eax
	mov	ecx, 4
	imul	edx, ecx, 10
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+24280]
	push	ecx
	mov	edx, 4
	imul	eax, edx, 10
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+24160]
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T23[ebp]
	call	??0D3DXVECTOR3@@QAE@MMM@Z		; D3DXVECTOR3::D3DXVECTOR3
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	push	ecx
	movss	xmm0, DWORD PTR __real@c1f00000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T22[ebp]
	call	??0D3DXVECTOR3@@QAE@MMM@Z		; D3DXVECTOR3::D3DXVECTOR3
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	push	OFFSET ??_C@_07DBODOLME@Troll?4x?$AA@
	mov	ecx, DWORD PTR $T60[ebp]
	call	??0CRenderObject@@QAE@QADUD3DXVECTOR3@@1PAUID3D10EffectTechnique@@2PAUID3D10ShaderResourceView@@3_N44@Z ; CRenderObject::CRenderObject
	mov	DWORD PTR tv675[ebp], eax
	jmp	SHORT $LN27@BasicItems
$LN26@BasicItems:
	mov	DWORD PTR tv675[ebp], 0
$LN27@BasicItems:
	mov	ecx, DWORD PTR tv675[ebp]
	mov	DWORD PTR $T59[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8008]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T59[ebp]
	mov	DWORD PTR [ecx+eax*4+8], edx

; 857  : 	mpObjects[miNumObjects]->GetModel()->SetScale( 5.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@40a00000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8008]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+8]
	call	?GetModel@CRenderObject@@QAEPAVCModel@@XZ ; CRenderObject::GetModel
	mov	ecx, eax
	call	?SetScale@CModel@@QAEXM@Z		; CModel::SetScale

; 858  : 	miNumObjects++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8008]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8008], ecx

; 859  : 
; 860  : 	//Halo Troll
; 861  : 	
; 862  : 	mpObjects[miNumObjects] = new CRenderObject("Troll.x",	D3DXVECTOR3( 20, 5, -10 ),		D3DXVECTOR3( 0.5f, 0.5f, 0.0f), mTechniques[11], mTechniquesMirror[11], mpMaps[3], mpMaps[4], true, true, true);

	push	72					; 00000048H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T62[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 11		; 0000000bH
	cmp	DWORD PTR $T62[ebp], 0
	je	$LN28@BasicItems
	push	1
	push	1
	push	1
	mov	eax, 4
	shl	eax, 2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+8136]
	push	edx
	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+8136]
	push	eax
	mov	ecx, 4
	imul	edx, ecx, 11
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+24280]
	push	ecx
	mov	edx, 4
	imul	eax, edx, 11
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+24160]
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T25[ebp]
	call	??0D3DXVECTOR3@@QAE@MMM@Z		; D3DXVECTOR3::D3DXVECTOR3
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	push	ecx
	movss	xmm0, DWORD PTR __real@c1200000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@40a00000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@41a00000
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T24[ebp]
	call	??0D3DXVECTOR3@@QAE@MMM@Z		; D3DXVECTOR3::D3DXVECTOR3
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	push	OFFSET ??_C@_07DBODOLME@Troll?4x?$AA@
	mov	ecx, DWORD PTR $T62[ebp]
	call	??0CRenderObject@@QAE@QADUD3DXVECTOR3@@1PAUID3D10EffectTechnique@@2PAUID3D10ShaderResourceView@@3_N44@Z ; CRenderObject::CRenderObject
	mov	DWORD PTR tv732[ebp], eax
	jmp	SHORT $LN29@BasicItems
$LN28@BasicItems:
	mov	DWORD PTR tv732[ebp], 0
$LN29@BasicItems:
	mov	ecx, DWORD PTR tv732[ebp]
	mov	DWORD PTR $T61[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8008]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T61[ebp]
	mov	DWORD PTR [ecx+eax*4+8], edx

; 863  : 	mpObjects[miNumObjects]->GetModel()->SetScale( 5.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@40a00000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8008]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+8]
	call	?GetModel@CRenderObject@@QAEPAVCModel@@XZ ; CRenderObject::GetModel
	mov	ecx, eax
	call	?SetScale@CModel@@QAEXM@Z		; CModel::SetScale

; 864  : 	miNumObjects++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8008]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8008], ecx

; 865  : 
; 866  : 
; 867  : 	//Space Halo Troll
; 868  : 	mpObjects[miNumObjects] = new CRenderObject("Troll.x",	D3DXVECTOR3( 50, 5, -10 ),		D3DXVECTOR3( 0.5f, 0.5f, 0.0f), mTechniques[12], mTechniquesMirror[12], mpMaps[6], mpMaps[7], true, true, true);

	push	72					; 00000048H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T64[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 12		; 0000000cH
	cmp	DWORD PTR $T64[ebp], 0
	je	$LN30@BasicItems
	push	1
	push	1
	push	1
	mov	eax, 4
	imul	ecx, eax, 7
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+8136]
	push	eax
	mov	ecx, 4
	imul	edx, ecx, 6
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+8136]
	push	ecx
	mov	edx, 4
	imul	eax, edx, 12
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+24280]
	push	edx
	mov	eax, 4
	imul	ecx, eax, 12
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+24160]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T27[ebp]
	call	??0D3DXVECTOR3@@QAE@MMM@Z		; D3DXVECTOR3::D3DXVECTOR3
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	push	ecx
	movss	xmm0, DWORD PTR __real@c1200000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@40a00000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@42480000
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T26[ebp]
	call	??0D3DXVECTOR3@@QAE@MMM@Z		; D3DXVECTOR3::D3DXVECTOR3
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	push	OFFSET ??_C@_07DBODOLME@Troll?4x?$AA@
	mov	ecx, DWORD PTR $T64[ebp]
	call	??0CRenderObject@@QAE@QADUD3DXVECTOR3@@1PAUID3D10EffectTechnique@@2PAUID3D10ShaderResourceView@@3_N44@Z ; CRenderObject::CRenderObject
	mov	DWORD PTR tv789[ebp], eax
	jmp	SHORT $LN31@BasicItems
$LN30@BasicItems:
	mov	DWORD PTR tv789[ebp], 0
$LN31@BasicItems:
	mov	ecx, DWORD PTR tv789[ebp]
	mov	DWORD PTR $T63[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8008]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T63[ebp]
	mov	DWORD PTR [ecx+eax*4+8], edx

; 869  : 	mpObjects[miNumObjects]->GetModel()->SetScale( 5.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@40a00000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8008]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+8]
	call	?GetModel@CRenderObject@@QAEPAVCModel@@XZ ; CRenderObject::GetModel
	mov	ecx, eax
	call	?SetScale@CModel@@QAEXM@Z		; CModel::SetScale

; 870  : 	miNumObjects++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8008]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8008], ecx

; 871  : 
; 872  : 	//Space Halo Troll
; 873  : 	mpObjects[miNumObjects] = new CRenderObject("Troll.x",	D3DXVECTOR3( 80, 5, -10 ),		D3DXVECTOR3( 0.5f, 0.5f, 0.0f), mTechniques[13], mTechniquesMirror[13], mpMaps[6], mpMaps[7], true, true, true);

	push	72					; 00000048H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T66[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 13		; 0000000dH
	cmp	DWORD PTR $T66[ebp], 0
	je	$LN32@BasicItems
	push	1
	push	1
	push	1
	mov	eax, 4
	imul	ecx, eax, 7
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+8136]
	push	eax
	mov	ecx, 4
	imul	edx, ecx, 6
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+8136]
	push	ecx
	mov	edx, 4
	imul	eax, edx, 13
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+24280]
	push	edx
	mov	eax, 4
	imul	ecx, eax, 13
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+24160]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T29[ebp]
	call	??0D3DXVECTOR3@@QAE@MMM@Z		; D3DXVECTOR3::D3DXVECTOR3
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	push	ecx
	movss	xmm0, DWORD PTR __real@c1200000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@40a00000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@42a00000
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T28[ebp]
	call	??0D3DXVECTOR3@@QAE@MMM@Z		; D3DXVECTOR3::D3DXVECTOR3
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	push	OFFSET ??_C@_07DBODOLME@Troll?4x?$AA@
	mov	ecx, DWORD PTR $T66[ebp]
	call	??0CRenderObject@@QAE@QADUD3DXVECTOR3@@1PAUID3D10EffectTechnique@@2PAUID3D10ShaderResourceView@@3_N44@Z ; CRenderObject::CRenderObject
	mov	DWORD PTR tv846[ebp], eax
	jmp	SHORT $LN33@BasicItems
$LN32@BasicItems:
	mov	DWORD PTR tv846[ebp], 0
$LN33@BasicItems:
	mov	ecx, DWORD PTR tv846[ebp]
	mov	DWORD PTR $T65[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8008]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T65[ebp]
	mov	DWORD PTR [ecx+eax*4+8], edx

; 874  : 	mpObjects[miNumObjects]->GetModel()->SetScale( 5.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@40a00000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8008]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+8]
	call	?GetModel@CRenderObject@@QAEPAVCModel@@XZ ; CRenderObject::GetModel
	mov	ecx, eax
	call	?SetScale@CModel@@QAEXM@Z		; CModel::SetScale

; 875  : 	miNumObjects++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8008]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8008], ecx

; 876  : 	
; 877  : 
; 878  : 	//Floor
; 879  : 	mpObjects[miNumObjects] = new CRenderObject("Floor.x",	D3DXVECTOR3(0,0,0),				D3DXVECTOR3(1.0f, 1.0f, 1.0f), mTechniques[6], mTechniquesMirror[6], mpMaps[1], NULL, true, false);

	push	72					; 00000048H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T68[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 14		; 0000000eH
	cmp	DWORD PTR $T68[ebp], 0
	je	$LN34@BasicItems
	push	0
	push	0
	push	1
	push	0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+8136]
	push	edx
	mov	eax, 4
	imul	ecx, eax, 6
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+24280]
	push	eax
	mov	ecx, 4
	imul	edx, ecx, 6
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+24160]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T31[ebp]
	call	??0D3DXVECTOR3@@QAE@MMM@Z		; D3DXVECTOR3::D3DXVECTOR3
	sub	esp, 12					; 0000000cH
	mov	edx, esp
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T30[ebp]
	call	??0D3DXVECTOR3@@QAE@MMM@Z		; D3DXVECTOR3::D3DXVECTOR3
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	push	OFFSET ??_C@_07MPPKGAHN@Floor?4x?$AA@
	mov	ecx, DWORD PTR $T68[ebp]
	call	??0CRenderObject@@QAE@QADUD3DXVECTOR3@@1PAUID3D10EffectTechnique@@2PAUID3D10ShaderResourceView@@3_N44@Z ; CRenderObject::CRenderObject
	mov	DWORD PTR tv900[ebp], eax
	jmp	SHORT $LN35@BasicItems
$LN34@BasicItems:
	mov	DWORD PTR tv900[ebp], 0
$LN35@BasicItems:
	mov	ecx, DWORD PTR tv900[ebp]
	mov	DWORD PTR $T67[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8008]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T67[ebp]
	mov	DWORD PTR [ecx+eax*4+8], edx

; 880  : 	miNumObjects++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8008]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8008], ecx

; 881  : 
; 882  : 
; 883  : 	CModel* temp;
; 884  : 	
; 885  : 	//Light 1 - Orbit Light
; 886  : 	temp = new CModel;

	push	1936					; 00000790H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T70[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 15		; 0000000fH
	cmp	DWORD PTR $T70[ebp], 0
	je	$LN36@BasicItems
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T71[ebp]
	call	??0D3DXVECTOR3@@QAE@MMM@Z		; D3DXVECTOR3::D3DXVECTOR3
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T72[ebp]
	call	??0D3DXVECTOR3@@QAE@MMM@Z		; D3DXVECTOR3::D3DXVECTOR3
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, DWORD PTR $T70[ebp]
	call	??0CModel@@QAE@UD3DXVECTOR3@@0M@Z	; CModel::CModel
	mov	DWORD PTR tv924[ebp], eax
	jmp	SHORT $LN37@BasicItems
$LN36@BasicItems:
	mov	DWORD PTR tv924[ebp], 0
$LN37@BasicItems:
	mov	ecx, DWORD PTR tv924[ebp]
	mov	DWORD PTR $T69[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR $T69[ebp]
	mov	DWORD PTR _temp$[ebp], edx

; 887  : 	mpLights[miNumLights] = new CLight();

	push	92					; 0000005cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T74[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 16		; 00000010H
	cmp	DWORD PTR $T74[ebp], 0
	je	SHORT $LN38@BasicItems
	mov	ecx, DWORD PTR $T74[ebp]
	call	??0CLight@@QAE@XZ			; CLight::CLight
	mov	DWORD PTR tv968[ebp], eax
	jmp	SHORT $LN39@BasicItems
$LN38@BasicItems:
	mov	DWORD PTR tv968[ebp], 0
$LN39@BasicItems:
	mov	eax, DWORD PTR tv968[ebp]
	mov	DWORD PTR $T73[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8132]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T73[ebp]
	mov	DWORD PTR [eax+edx*4+8012], ecx

; 888  : 	if (!temp->	Load( "Sphere.x", mTechniques[0] )) return false;

	push	OFFSET ??_C@_08EEMGLHJD@Sphere?4x?$AA@
	lea	ecx, DWORD PTR $T35[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 17		; 00000011H
	push	0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+24160]
	push	eax
	lea	ecx, DWORD PTR $T35[ebp]
	push	ecx
	mov	ecx, DWORD PTR _temp$[ebp]
	call	?Load@CModel@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUID3D10EffectTechnique@@_N@Z ; CModel::Load
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN40@BasicItems
	mov	DWORD PTR tv982[ebp], 1
	jmp	SHORT $LN41@BasicItems
$LN40@BasicItems:
	mov	DWORD PTR tv982[ebp], 0
$LN41@BasicItems:
	mov	al, BYTE PTR tv982[ebp]
	mov	BYTE PTR $T75[ebp], al
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T35[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	movzx	ecx, BYTE PTR $T75[ebp]
	test	ecx, ecx
	je	SHORT $LN3@BasicItems
	xor	al, al
	jmp	$LN4@BasicItems
$LN3@BasicItems:

; 889  : 	mpLights[miNumLights]->SetModel(temp);

	mov	eax, DWORD PTR _temp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8132]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+8012]
	call	?SetModel@CLight@@QAEXPAVCModel@@@Z	; CLight::SetModel

; 890  : 	mpLights[miNumLights]->SetColour(1.0f, 0.0f, 0.7f);

	push	ecx
	movss	xmm0, DWORD PTR __real@3f333333
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8132]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+8012]
	call	?SetColour@CLight@@QAEXMMM@Z		; CLight::SetColour

; 891  : 	mpLights[miNumLights]->GetModel()->SetPosition( D3DXVECTOR3(30, 10, 0) );

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@41f00000
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T37[ebp]
	call	??0D3DXVECTOR3@@QAE@MMM@Z		; D3DXVECTOR3::D3DXVECTOR3
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8132]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+8012]
	call	?GetModel@CLight@@QAEPAVCModel@@XZ	; CLight::GetModel
	mov	ecx, eax
	call	?SetPosition@CModel@@QAEXUD3DXVECTOR3@@@Z ; CModel::SetPosition

; 892  : 	mpLights[miNumLights]->GetModel()->SetScale( 0.1f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8132]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+8012]
	call	?GetModel@CLight@@QAEPAVCModel@@XZ	; CLight::GetModel
	mov	ecx, eax
	call	?SetScale@CModel@@QAEXM@Z		; CModel::SetScale

; 893  : 	mpLights[miNumLights]->SetBrightness( 10.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8132]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+8012]
	call	?SetBrightness@CLight@@QAEXM@Z		; CLight::SetBrightness

; 894  : 	mpLights[miNumLights]->SetOrbit(  D3DXVECTOR3(0, 20, 0), 25.0f, 0.1f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@41c80000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@41a00000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T39[ebp]
	call	??0D3DXVECTOR3@@QAE@MMM@Z		; D3DXVECTOR3::D3DXVECTOR3
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8132]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+8012]
	call	?SetOrbit@CLight@@QAEXUD3DXVECTOR3@@MM@Z ; CLight::SetOrbit

; 895  : 	mpLights[miNumLights]->SetColourCycle( 17.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@41880000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8132]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+8012]
	call	?SetColourCycle@CLight@@QAEXM@Z		; CLight::SetColourCycle

; 896  : 
; 897  : 	miNumLights++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8132]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8132], ecx

; 898  : 	
; 899  : 	//Light 2 - Pulse Light
; 900  : 	temp = new CModel;

	push	1936					; 00000790H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T77[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 18		; 00000012H
	cmp	DWORD PTR $T77[ebp], 0
	je	$LN42@BasicItems
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T78[ebp]
	call	??0D3DXVECTOR3@@QAE@MMM@Z		; D3DXVECTOR3::D3DXVECTOR3
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T79[ebp]
	call	??0D3DXVECTOR3@@QAE@MMM@Z		; D3DXVECTOR3::D3DXVECTOR3
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, DWORD PTR $T77[ebp]
	call	??0CModel@@QAE@UD3DXVECTOR3@@0M@Z	; CModel::CModel
	mov	DWORD PTR tv1077[ebp], eax
	jmp	SHORT $LN43@BasicItems
$LN42@BasicItems:
	mov	DWORD PTR tv1077[ebp], 0
$LN43@BasicItems:
	mov	ecx, DWORD PTR tv1077[ebp]
	mov	DWORD PTR $T76[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR $T76[ebp]
	mov	DWORD PTR _temp$[ebp], edx

; 901  : 	mpLights[miNumLights] = new CLight();

	push	92					; 0000005cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T81[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 19		; 00000013H
	cmp	DWORD PTR $T81[ebp], 0
	je	SHORT $LN44@BasicItems
	mov	ecx, DWORD PTR $T81[ebp]
	call	??0CLight@@QAE@XZ			; CLight::CLight
	mov	DWORD PTR tv1089[ebp], eax
	jmp	SHORT $LN45@BasicItems
$LN44@BasicItems:
	mov	DWORD PTR tv1089[ebp], 0
$LN45@BasicItems:
	mov	eax, DWORD PTR tv1089[ebp]
	mov	DWORD PTR $T80[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8132]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T80[ebp]
	mov	DWORD PTR [eax+edx*4+8012], ecx

; 902  : 	if (!temp->	Load( "Sphere.x", mTechniques[0] )) return false;

	push	OFFSET ??_C@_08EEMGLHJD@Sphere?4x?$AA@
	lea	ecx, DWORD PTR $T45[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 20		; 00000014H
	push	0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+24160]
	push	eax
	lea	ecx, DWORD PTR $T45[ebp]
	push	ecx
	mov	ecx, DWORD PTR _temp$[ebp]
	call	?Load@CModel@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUID3D10EffectTechnique@@_N@Z ; CModel::Load
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN46@BasicItems
	mov	DWORD PTR tv1103[ebp], 1
	jmp	SHORT $LN47@BasicItems
$LN46@BasicItems:
	mov	DWORD PTR tv1103[ebp], 0
$LN47@BasicItems:
	mov	al, BYTE PTR tv1103[ebp]
	mov	BYTE PTR $T82[ebp], al
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T45[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	movzx	ecx, BYTE PTR $T82[ebp]
	test	ecx, ecx
	je	SHORT $LN2@BasicItems
	xor	al, al
	jmp	$LN4@BasicItems
$LN2@BasicItems:

; 903  : 	mpLights[miNumLights]->SetModel(temp);

	mov	eax, DWORD PTR _temp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8132]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+8012]
	call	?SetModel@CLight@@QAEXPAVCModel@@@Z	; CLight::SetModel

; 904  : 	mpLights[miNumLights]->SetColour(1.0f, 0.8f, 0.2f);

	push	ecx
	movss	xmm0, DWORD PTR __real@3e4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8132]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+8012]
	call	?SetColour@CLight@@QAEXMMM@Z		; CLight::SetColour

; 905  : 	mpLights[miNumLights]->GetModel()->SetPosition( D3DXVECTOR3(-20, 30, 50) );

	push	ecx
	movss	xmm0, DWORD PTR __real@42480000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@41f00000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@c1a00000
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T48[ebp]
	call	??0D3DXVECTOR3@@QAE@MMM@Z		; D3DXVECTOR3::D3DXVECTOR3
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8132]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+8012]
	call	?GetModel@CLight@@QAEPAVCModel@@XZ	; CLight::GetModel
	mov	ecx, eax
	call	?SetPosition@CModel@@QAEXUD3DXVECTOR3@@@Z ; CModel::SetPosition

; 906  : 	mpLights[miNumLights]->GetModel()->SetScale( 0.2f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3e4ccccd
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8132]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+8012]
	call	?GetModel@CLight@@QAEPAVCModel@@XZ	; CLight::GetModel
	mov	ecx, eax
	call	?SetScale@CModel@@QAEXM@Z		; CModel::SetScale

; 907  : 	mpLights[miNumLights]->GetModel()->UpdateMatrix();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8132]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+8012]
	call	?GetModel@CLight@@QAEPAVCModel@@XZ	; CLight::GetModel
	mov	ecx, eax
	call	?UpdateMatrix@CModel@@QAEXXZ		; CModel::UpdateMatrix

; 908  : 	mpLights[miNumLights]->SetBrightness( 5.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@40a00000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8132]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+8012]
	call	?SetBrightness@CLight@@QAEXM@Z		; CLight::SetBrightness

; 909  : 	mpLights[miNumLights]->SetFade( 2.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8132]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+8012]
	call	?SetFade@CLight@@QAEXM@Z		; CLight::SetFade

; 910  : 
; 911  : 	miNumLights++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8132]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8132], ecx

; 912  : 
; 913  : 	//Light 3 - Disco Light
; 914  : 	
; 915  : 	temp = new CModel;

	push	1936					; 00000790H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T84[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 21		; 00000015H
	cmp	DWORD PTR $T84[ebp], 0
	je	$LN48@BasicItems
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T85[ebp]
	call	??0D3DXVECTOR3@@QAE@MMM@Z		; D3DXVECTOR3::D3DXVECTOR3
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T86[ebp]
	call	??0D3DXVECTOR3@@QAE@MMM@Z		; D3DXVECTOR3::D3DXVECTOR3
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, DWORD PTR $T84[ebp]
	call	??0CModel@@QAE@UD3DXVECTOR3@@0M@Z	; CModel::CModel
	mov	DWORD PTR tv1192[ebp], eax
	jmp	SHORT $LN49@BasicItems
$LN48@BasicItems:
	mov	DWORD PTR tv1192[ebp], 0
$LN49@BasicItems:
	mov	ecx, DWORD PTR tv1192[ebp]
	mov	DWORD PTR $T83[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR $T83[ebp]
	mov	DWORD PTR _temp$[ebp], edx

; 916  : 	mpLights[miNumLights] = new CLight();

	push	92					; 0000005cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T88[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 22		; 00000016H
	cmp	DWORD PTR $T88[ebp], 0
	je	SHORT $LN50@BasicItems
	mov	ecx, DWORD PTR $T88[ebp]
	call	??0CLight@@QAE@XZ			; CLight::CLight
	mov	DWORD PTR tv1204[ebp], eax
	jmp	SHORT $LN51@BasicItems
$LN50@BasicItems:
	mov	DWORD PTR tv1204[ebp], 0
$LN51@BasicItems:
	mov	eax, DWORD PTR tv1204[ebp]
	mov	DWORD PTR $T87[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8132]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T87[ebp]
	mov	DWORD PTR [eax+edx*4+8012], ecx

; 917  : 	if (!temp->	Load( "Sphere.x", mTechniques[0] )) return false;

	push	OFFSET ??_C@_08EEMGLHJD@Sphere?4x?$AA@
	lea	ecx, DWORD PTR $T55[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 23		; 00000017H
	push	0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+24160]
	push	eax
	lea	ecx, DWORD PTR $T55[ebp]
	push	ecx
	mov	ecx, DWORD PTR _temp$[ebp]
	call	?Load@CModel@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUID3D10EffectTechnique@@_N@Z ; CModel::Load
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN52@BasicItems
	mov	DWORD PTR tv1218[ebp], 1
	jmp	SHORT $LN53@BasicItems
$LN52@BasicItems:
	mov	DWORD PTR tv1218[ebp], 0
$LN53@BasicItems:
	mov	al, BYTE PTR tv1218[ebp]
	mov	BYTE PTR $T89[ebp], al
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T55[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	movzx	ecx, BYTE PTR $T89[ebp]
	test	ecx, ecx
	je	SHORT $LN1@BasicItems
	xor	al, al
	jmp	$LN4@BasicItems
$LN1@BasicItems:

; 918  : 	mpLights[miNumLights]->SetModel(temp);

	mov	eax, DWORD PTR _temp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8132]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+8012]
	call	?SetModel@CLight@@QAEXPAVCModel@@@Z	; CLight::SetModel

; 919  : 	mpLights[miNumLights]->SetColour(1.0f, 0.8f, 0.2f);

	push	ecx
	movss	xmm0, DWORD PTR __real@3e4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8132]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+8012]
	call	?SetColour@CLight@@QAEXMMM@Z		; CLight::SetColour

; 920  : 	mpLights[miNumLights]->GetModel()->SetPosition( D3DXVECTOR3(200, 25, 200) );

	push	ecx
	movss	xmm0, DWORD PTR __real@43480000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@41c80000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@43480000
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T57[ebp]
	call	??0D3DXVECTOR3@@QAE@MMM@Z		; D3DXVECTOR3::D3DXVECTOR3
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8132]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+8012]
	call	?GetModel@CLight@@QAEPAVCModel@@XZ	; CLight::GetModel
	mov	ecx, eax
	call	?SetPosition@CModel@@QAEXUD3DXVECTOR3@@@Z ; CModel::SetPosition

; 921  : 	mpLights[miNumLights]->GetModel()->SetScale( 0.2f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3e4ccccd
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8132]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+8012]
	call	?GetModel@CLight@@QAEPAVCModel@@XZ	; CLight::GetModel
	mov	ecx, eax
	call	?SetScale@CModel@@QAEXM@Z		; CModel::SetScale

; 922  : 	mpLights[miNumLights]->GetModel()->UpdateMatrix();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8132]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+8012]
	call	?GetModel@CLight@@QAEPAVCModel@@XZ	; CLight::GetModel
	mov	ecx, eax
	call	?UpdateMatrix@CModel@@QAEXXZ		; CModel::UpdateMatrix

; 923  : 	mpLights[miNumLights]->SetBrightness( 5.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@40a00000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8132]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+8012]
	call	?SetBrightness@CLight@@QAEXM@Z		; CLight::SetBrightness

; 924  : 	mpLights[miNumLights]->SetDisco();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8132]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+8012]
	call	?SetDisco@CLight@@QAEXXZ		; CLight::SetDisco

; 925  : 
; 926  : 	miNumLights++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8132]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8132], ecx

; 927  : 	
; 928  : 	//Light 4 - Cycle, Orbit and Pulse Light - Slightly buggy.
; 929  : 	/*
; 930  : 	temp = new CModel;
; 931  : 	mpLights[miNumLights] = new CLight();
; 932  : 	if (!temp->	Load( "Sphere.x", PlainColourTechnique )) return false;
; 933  : 	mpLights[miNumLights]->SetModel(temp);
; 934  : 	mpLights[miNumLights]->SetColour(1.0f, 0.8f, 0.2f);
; 935  : 	mpLights[miNumLights]->GetModel()->SetPosition( D3DXVECTOR3(200, 25, 200) );
; 936  : 	mpLights[miNumLights]->GetModel()->SetScale( 0.2f );
; 937  : 	mpLights[miNumLights]->GetModel()->UpdateMatrix();
; 938  : 	mpLights[miNumLights]->SetBrightness( 2.0f );
; 939  : 	mpLights[miNumLights]->SetOrbit( mpObjects[5]->GetModel(), 25.0f, 0.5f );
; 940  : 	mpLights[miNumLights]->SetColourCycle( 15.0f );
; 941  : 	mpLights[miNumLights]->SetPulse ( 2.0f );
; 942  : 
; 943  : 	miNumLights++;
; 944  : 	*/
; 945  : 	return true;

	mov	al, 1
$LN4@BasicItems:

; 946  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 1684				; 00000694H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$0:
	mov	eax, DWORD PTR $T33[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$1:
	mov	eax, DWORD PTR $T36[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$2:
	mov	eax, DWORD PTR $T40[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$3:
	mov	eax, DWORD PTR $T42[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$4:
	mov	eax, DWORD PTR $T44[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$5:
	mov	eax, DWORD PTR $T47[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$6:
	mov	eax, DWORD PTR $T50[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$7:
	mov	eax, DWORD PTR $T52[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$8:
	mov	eax, DWORD PTR $T54[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$9:
	mov	eax, DWORD PTR $T58[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$10:
	mov	eax, DWORD PTR $T60[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$11:
	mov	eax, DWORD PTR $T62[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$12:
	mov	eax, DWORD PTR $T64[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$13:
	mov	eax, DWORD PTR $T66[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$14:
	mov	eax, DWORD PTR $T68[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$15:
	mov	eax, DWORD PTR $T70[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$16:
	mov	eax, DWORD PTR $T74[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$17:
	lea	ecx, DWORD PTR $T35[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$18:
	mov	eax, DWORD PTR $T77[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$19:
	mov	eax, DWORD PTR $T81[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$20:
	lea	ecx, DWORD PTR $T45[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$21:
	mov	eax, DWORD PTR $T84[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$22:
	mov	eax, DWORD PTR $T88[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$23:
	lea	ecx, DWORD PTR $T55[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?BasicItems@CScene@@AAE_NXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-1688]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?BasicItems@CScene@@AAE_NXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?BasicItems@CScene@@AAE_NXZ ENDP			; CScene::BasicItems
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_GCRenderObject@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_GCRenderObject@@QAEPAXI@Z PROC			; CRenderObject::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CRenderObject@@QAE@XZ		; CRenderObject::~CRenderObject
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_GCRenderObject@@QAEPAXI@Z ENDP			; CRenderObject::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\game-of-life\renderobject.h
;	COMDAT ?GetOutlineThickness@CRenderObject@@QAEMXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetOutlineThickness@CRenderObject@@QAEMXZ PROC		; CRenderObject::GetOutlineThickness, COMDAT
; _this$ = ecx

; 103  : 	float GetOutlineThickness() { return mOutlineThickness; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+68]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetOutlineThickness@CRenderObject@@QAEMXZ ENDP		; CRenderObject::GetOutlineThickness
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\game-of-life\renderobject.h
;	COMDAT ?GetWiggle@CRenderObject@@QAEMXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetWiggle@CRenderObject@@QAEMXZ PROC			; CRenderObject::GetWiggle, COMDAT
; _this$ = ecx

; 101  : 	float GetWiggle() { return mWiggleValue; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+64]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetWiggle@CRenderObject@@QAEMXZ ENDP			; CRenderObject::GetWiggle
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\game-of-life\renderobject.h
;	COMDAT ?SetWiggle@CRenderObject@@QAEXM@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_rate$ = 8						; size = 4
?SetWiggle@CRenderObject@@QAEXM@Z PROC			; CRenderObject::SetWiggle, COMDAT
; _this$ = ecx

; 99   : 	void SetWiggle( float rate ) { mWiggle = true; mWiggleRate = rate; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+56], 1
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _rate$[ebp]
	movss	DWORD PTR [eax+60], xmm0
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetWiggle@CRenderObject@@QAEXM@Z ENDP			; CRenderObject::SetWiggle
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\game-of-life\renderobject.h
;	COMDAT ?SetSpinZ@CRenderObject@@QAEXM@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_rate$ = 8						; size = 4
?SetSpinZ@CRenderObject@@QAEXM@Z PROC			; CRenderObject::SetSpinZ, COMDAT
; _this$ = ecx

; 93   : 	void SetSpinZ( float rate ) { mSpinZ = true; mSpinZRate = rate; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+43], 1
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _rate$[ebp]
	movss	DWORD PTR [eax+52], xmm0
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetSpinZ@CRenderObject@@QAEXM@Z ENDP			; CRenderObject::SetSpinZ
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\game-of-life\renderobject.h
;	COMDAT ?SetSpinY@CRenderObject@@QAEXM@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_rate$ = 8						; size = 4
?SetSpinY@CRenderObject@@QAEXM@Z PROC			; CRenderObject::SetSpinY, COMDAT
; _this$ = ecx

; 92   : 	void SetSpinY( float rate ) { mSpinY = true; mSpinYRate = rate; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+42], 1
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _rate$[ebp]
	movss	DWORD PTR [eax+48], xmm0
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetSpinY@CRenderObject@@QAEXM@Z ENDP			; CRenderObject::SetSpinY
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\game-of-life\renderobject.h
;	COMDAT ?SetSpinX@CRenderObject@@QAEXM@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_rate$ = 8						; size = 4
?SetSpinX@CRenderObject@@QAEXM@Z PROC			; CRenderObject::SetSpinX, COMDAT
; _this$ = ecx

; 91   : 	void SetSpinX( float rate ) { mSpinX = true; mSpinXRate = rate; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+41], 1
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _rate$[ebp]
	movss	DWORD PTR [eax+44], xmm0
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetSpinX@CRenderObject@@QAEXM@Z ENDP			; CRenderObject::SetSpinX
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\game-of-life\renderobject.h
;	COMDAT ?SetColourCycle@CRenderObject@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?SetColourCycle@CRenderObject@@QAEXXZ PROC		; CRenderObject::SetColourCycle, COMDAT
; _this$ = ecx

; 88   : 	void SetColourCycle() { mColourCycle = true; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+40], 1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SetColourCycle@CRenderObject@@QAEXXZ ENDP		; CRenderObject::SetColourCycle
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\game-of-life\renderobject.h
;	COMDAT ?RenderMirror@CRenderObject@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?RenderMirror@CRenderObject@@QAEXXZ PROC		; CRenderObject::RenderMirror, COMDAT
; _this$ = ecx

; 86   : 	void RenderMirror() { mModel->Render( mMirrorTechnique ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?Render@CModel@@QAEXPAUID3D10EffectTechnique@@@Z ; CModel::Render
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?RenderMirror@CRenderObject@@QAEXXZ ENDP		; CRenderObject::RenderMirror
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\game-of-life\renderobject.h
;	COMDAT ?Render@CRenderObject@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Render@CRenderObject@@QAEXXZ PROC			; CRenderObject::Render, COMDAT
; _this$ = ecx

; 85   : 	void Render() { mModel->Render( mTechnique ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?Render@CModel@@QAEXPAUID3D10EffectTechnique@@@Z ; CModel::Render
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Render@CRenderObject@@QAEXXZ ENDP			; CRenderObject::Render
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\game-of-life\renderobject.h
;	COMDAT ?IsTransparent@CRenderObject@@QAE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?IsTransparent@CRenderObject@@QAE_NXZ PROC		; CRenderObject::IsTransparent, COMDAT
; _this$ = ecx

; 80   : 	bool IsTransparent() { return mIsTransparent; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+33]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsTransparent@CRenderObject@@QAE_NXZ ENDP		; CRenderObject::IsTransparent
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\game-of-life\renderobject.h
;	COMDAT ?IsLit@CRenderObject@@QAE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?IsLit@CRenderObject@@QAE_NXZ PROC			; CRenderObject::IsLit, COMDAT
; _this$ = ecx

; 75   : 	bool IsLit() { return mIsLit; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+32]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsLit@CRenderObject@@QAE_NXZ ENDP			; CRenderObject::IsLit
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\game-of-life\renderobject.h
;	COMDAT ?GetNormalMap@CRenderObject@@QAEPAUID3D10ShaderResourceView@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetNormalMap@CRenderObject@@QAEPAUID3D10ShaderResourceView@@XZ PROC ; CRenderObject::GetNormalMap, COMDAT
; _this$ = ecx

; 72   : 	ID3D10ShaderResourceView* GetNormalMap() { return mNormMap; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+28]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetNormalMap@CRenderObject@@QAEPAUID3D10ShaderResourceView@@XZ ENDP ; CRenderObject::GetNormalMap
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\game-of-life\renderobject.h
;	COMDAT ?GetTexture@CRenderObject@@QAEPAUID3D10ShaderResourceView@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetTexture@CRenderObject@@QAEPAUID3D10ShaderResourceView@@XZ PROC ; CRenderObject::GetTexture, COMDAT
; _this$ = ecx

; 69   : 	ID3D10ShaderResourceView* GetTexture() { return mTexture; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+24]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetTexture@CRenderObject@@QAEPAUID3D10ShaderResourceView@@XZ ENDP ; CRenderObject::GetTexture
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\game-of-life\renderobject.h
;	COMDAT ?GetColourV@CRenderObject@@QAE?AUD3DXVECTOR3@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetColourV@CRenderObject@@QAE?AUD3DXVECTOR3@@XZ PROC	; CRenderObject::GetColourV, COMDAT
; _this$ = ecx

; 59   : 	D3DXVECTOR3 GetColourV(){ return D3DXVECTOR3( mr, mg, mb ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+12]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+8]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+4]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0D3DXVECTOR3@@QAE@MMM@Z		; D3DXVECTOR3::D3DXVECTOR3
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?GetColourV@CRenderObject@@QAE?AUD3DXVECTOR3@@XZ ENDP	; CRenderObject::GetColourV
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\game-of-life\renderobject.h
;	COMDAT ?GetModel@CRenderObject@@QAEPAVCModel@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetModel@CRenderObject@@QAEPAVCModel@@XZ PROC		; CRenderObject::GetModel, COMDAT
; _this$ = ecx

; 54   : 	CModel* GetModel() { return mModel; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetModel@CRenderObject@@QAEPAVCModel@@XZ ENDP		; CRenderObject::GetModel
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_GCLight@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_GCLight@@QAEPAXI@Z PROC				; CLight::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CLight@@QAE@XZ			; CLight::~CLight
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_GCLight@@QAEPAXI@Z ENDP				; CLight::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\game-of-life\light.h
;	COMDAT ?SetDisco@CLight@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?SetDisco@CLight@@QAEXXZ PROC				; CLight::SetDisco, COMDAT
; _this$ = ecx

; 86   : 	void SetDisco() { mDisco = true; mPulse = false; mCycleColour = false;}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+88], 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+68], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+60], 0
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SetDisco@CLight@@QAEXXZ ENDP				; CLight::SetDisco
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\game-of-life\light.h
;	COMDAT ?SetBrightness@CLight@@QAEXM@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_brightness$ = 8					; size = 4
?SetBrightness@CLight@@QAEXM@Z PROC			; CLight::SetBrightness, COMDAT
; _this$ = ecx

; 71   : 	void SetBrightness(float brightness) { mBrightness = brightness; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _brightness$[ebp]
	movss	DWORD PTR [eax+24], xmm0
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetBrightness@CLight@@QAEXM@Z ENDP			; CLight::SetBrightness
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\game-of-life\light.h
;	COMDAT ?GetBrightness@CLight@@QAEMXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetBrightness@CLight@@QAEMXZ PROC			; CLight::GetBrightness, COMDAT
; _this$ = ecx

; 70   : 	float GetBrightness() { return mBrightness; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+24]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetBrightness@CLight@@QAEMXZ ENDP			; CLight::GetBrightness
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\game-of-life\light.h
;	COMDAT ?SetModel@CLight@@QAEXPAVCModel@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_model$ = 8						; size = 4
?SetModel@CLight@@QAEXPAVCModel@@@Z PROC		; CLight::SetModel, COMDAT
; _this$ = ecx

; 68   : 	void SetModel( CModel* model ) { mModel = model; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _model$[ebp]
	mov	DWORD PTR [eax], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetModel@CLight@@QAEXPAVCModel@@@Z ENDP		; CLight::SetModel
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\game-of-life\light.h
;	COMDAT ?GetModel@CLight@@QAEPAVCModel@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetModel@CLight@@QAEPAVCModel@@XZ PROC			; CLight::GetModel, COMDAT
; _this$ = ecx

; 67   : 	CModel* GetModel() { return mModel; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetModel@CLight@@QAEPAVCModel@@XZ ENDP			; CLight::GetModel
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\game-of-life\light.h
;	COMDAT ?GetColourV@CLight@@QAE?AUD3DXVECTOR3@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetColourV@CLight@@QAE?AUD3DXVECTOR3@@XZ PROC		; CLight::GetColourV, COMDAT
; _this$ = ecx

; 56   : 	D3DXVECTOR3 GetColourV(){ return D3DXVECTOR3( mr, mg, mb ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+12]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+8]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+4]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0D3DXVECTOR3@@QAE@MMM@Z		; D3DXVECTOR3::D3DXVECTOR3
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?GetColourV@CLight@@QAE?AUD3DXVECTOR3@@XZ ENDP		; CLight::GetColourV
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\game-of-life\camera.h
;	COMDAT ?SetNearClip@CCamera@@QAEXM@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_nearClip$ = 8						; size = 4
?SetNearClip@CCamera@@QAEXM@Z PROC			; CCamera::SetNearClip, COMDAT
; _this$ = ecx

; 111  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 112  : 		m_NearClip = nearClip;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _nearClip$[ebp]
	movss	DWORD PTR [eax+36], xmm0

; 113  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetNearClip@CCamera@@QAEXM@Z ENDP			; CCamera::SetNearClip
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\game-of-life\camera.h
;	COMDAT ?SetRotation@CCamera@@QAEXUD3DXVECTOR3@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_rotation$ = 8						; size = 12
?SetRotation@CCamera@@QAEXUD3DXVECTOR3@@@Z PROC		; CCamera::SetRotation, COMDAT
; _this$ = ecx

; 103  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 104  : 		m_Rotation = rotation;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _rotation$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _rotation$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _rotation$[ebp+8]
	mov	DWORD PTR [eax+8], ecx

; 105  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?SetRotation@CCamera@@QAEXUD3DXVECTOR3@@@Z ENDP		; CCamera::SetRotation
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\game-of-life\camera.h
;	COMDAT ?SetPosition@CCamera@@QAEXUD3DXVECTOR3@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_position$ = 8						; size = 12
?SetPosition@CCamera@@QAEXUD3DXVECTOR3@@@Z PROC		; CCamera::SetPosition, COMDAT
; _this$ = ecx

; 99   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 100  : 		m_Position = position;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	mov	ecx, DWORD PTR _position$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _position$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _position$[ebp+8]
	mov	DWORD PTR [eax+8], ecx

; 101  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?SetPosition@CCamera@@QAEXUD3DXVECTOR3@@@Z ENDP		; CCamera::SetPosition
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\game-of-life\camera.h
;	COMDAT ?GetProjectionMatrix@CCamera@@QAE?AU_D3DXMATRIXA16@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetProjectionMatrix@CCamera@@QAE?AU_D3DXMATRIXA16@@XZ PROC ; CCamera::GetProjectionMatrix, COMDAT
; _this$ = ecx

; 75   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 76   : 		return m_ProjMatrix;

	mov	esi, DWORD PTR _this$[ebp]
	add	esi, 176				; 000000b0H
	mov	ecx, 16					; 00000010H
	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]
	rep movsd
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 77   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?GetProjectionMatrix@CCamera@@QAE?AU_D3DXMATRIXA16@@XZ ENDP ; CCamera::GetProjectionMatrix
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\game-of-life\camera.h
;	COMDAT ?GetViewMatrix@CCamera@@QAE?AU_D3DXMATRIXA16@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetViewMatrix@CCamera@@QAE?AU_D3DXMATRIXA16@@XZ PROC	; CCamera::GetViewMatrix, COMDAT
; _this$ = ecx

; 71   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 72   : 		return m_ViewMatrix;

	mov	esi, DWORD PTR _this$[ebp]
	add	esi, 112				; 00000070H
	mov	ecx, 16					; 00000010H
	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]
	rep movsd
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 73   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?GetViewMatrix@CCamera@@QAE?AU_D3DXMATRIXA16@@XZ ENDP	; CCamera::GetViewMatrix
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\game-of-life\camera.h
;	COMDAT ?GetPosition@CCamera@@QAE?AUD3DXVECTOR3@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetPosition@CCamera@@QAE?AUD3DXVECTOR3@@XZ PROC	; CCamera::GetPosition, COMDAT
; _this$ = ecx

; 62   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 63   : 		return m_Position;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 64   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?GetPosition@CCamera@@QAE?AUD3DXVECTOR3@@XZ ENDP	; CCamera::GetPosition
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\game-of-life\camera.h
;	COMDAT ?SetViewport@CCamera@@SAXHH@Z
_TEXT	SEGMENT
_width$ = 8						; size = 4
_height$ = 12						; size = 4
?SetViewport@CCamera@@SAXHH@Z PROC			; CCamera::SetViewport, COMDAT

; 48   : 	static void SetViewport( int width, int height ) { mViewportWidth = width; mViewportHeight = height; }

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _width$[ebp]
	mov	DWORD PTR ?mViewportWidth@CCamera@@0HA, eax ; CCamera::mViewportWidth
	mov	eax, DWORD PTR _height$[ebp]
	mov	DWORD PTR ?mViewportHeight@CCamera@@0HA, eax ; CCamera::mViewportHeight
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SetViewport@CCamera@@SAXHH@Z ENDP			; CCamera::SetViewport
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\game-of-life\model.h
;	COMDAT ?SetScale@CModel@@QAEXM@Z
_TEXT	SEGMENT
$T1 = -224						; size = 12
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_scale$ = 8						; size = 4
?SetScale@CModel@@QAEXM@Z PROC				; CModel::SetScale, COMDAT
; _this$ = ecx

; 118  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 119  : 		m_Scale = D3DXVECTOR3( scale, scale, scale );

	push	ecx
	movss	xmm0, DWORD PTR _scale$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _scale$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _scale$[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0D3DXVECTOR3@@QAE@MMM@Z		; D3DXVECTOR3::D3DXVECTOR3
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 120  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?SetScale@CModel@@QAEXM@Z ENDP				; CModel::SetScale
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\game-of-life\model.h
;	COMDAT ?SetRotation@CModel@@QAEXUD3DXVECTOR3@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_rotation$ = 8						; size = 12
?SetRotation@CModel@@QAEXUD3DXVECTOR3@@@Z PROC		; CModel::SetRotation, COMDAT
; _this$ = ecx

; 110  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 111  : 		m_Rotation = rotation;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _rotation$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _rotation$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _rotation$[ebp+8]
	mov	DWORD PTR [eax+8], ecx

; 112  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?SetRotation@CModel@@QAEXUD3DXVECTOR3@@@Z ENDP		; CModel::SetRotation
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\game-of-life\model.h
;	COMDAT ?SetPosition@CModel@@QAEXUD3DXVECTOR3@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_position$ = 8						; size = 12
?SetPosition@CModel@@QAEXUD3DXVECTOR3@@@Z PROC		; CModel::SetPosition, COMDAT
; _this$ = ecx

; 106  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 107  : 		m_Position = position;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	mov	ecx, DWORD PTR _position$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _position$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _position$[ebp+8]
	mov	DWORD PTR [eax+8], ecx

; 108  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?SetPosition@CModel@@QAEXUD3DXVECTOR3@@@Z ENDP		; CModel::SetPosition
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\game-of-life\model.h
;	COMDAT ?GetWorldMatrix@CModel@@QAE?AU_D3DXMATRIXA16@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetWorldMatrix@CModel@@QAE?AU_D3DXMATRIXA16@@XZ PROC	; CModel::GetWorldMatrix, COMDAT
; _this$ = ecx

; 99   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 100  : 		return m_WorldMatrix;

	mov	esi, DWORD PTR _this$[ebp]
	add	esi, 48					; 00000030H
	mov	ecx, 16					; 00000010H
	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]
	rep movsd
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 101  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?GetWorldMatrix@CModel@@QAE?AU_D3DXMATRIXA16@@XZ ENDP	; CModel::GetWorldMatrix
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\game-of-life\model.h
;	COMDAT ?GetPosition@CModel@@QAE?AUD3DXVECTOR3@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetPosition@CModel@@QAE?AUD3DXVECTOR3@@XZ PROC		; CModel::GetPosition, COMDAT
; _this$ = ecx

; 86   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 87   : 		return m_Position;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 88   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?GetPosition@CModel@@QAE?AUD3DXVECTOR3@@XZ ENDP		; CModel::GetPosition
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\game-of-life\model.h
;	COMDAT ?SetDevice@CModel@@SAXPAUID3D10Device@@@Z
_TEXT	SEGMENT
_newDevice$ = 8						; size = 4
?SetDevice@CModel@@SAXPAUID3D10Device@@@Z PROC		; CModel::SetDevice, COMDAT

; 66   : 	static void SetDevice(ID3D10Device* newDevice) { mpd3dDev = newDevice; }

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _newDevice$[ebp]
	mov	DWORD PTR ?mpd3dDev@CModel@@0PAUID3D10Device@@A, eax ; CModel::mpd3dDev
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SetDevice@CModel@@SAXPAUID3D10Device@@@Z ENDP		; CModel::SetDevice
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\game-of-life\defines.h
;	COMDAT ?square@@YAMM@Z
_TEXT	SEGMENT
tv67 = -196						; size = 4
_x$ = 8							; size = 4
?square@@YAMM@Z PROC					; square, COMDAT

; 25   : inline float square (float x) { return x * x; }

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	movss	xmm0, DWORD PTR _x$[ebp]
	mulss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR tv67[ebp], xmm0
	fld	DWORD PTR tv67[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?square@@YAMM@Z ENDP					; square
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\game-of-life\defines.h
;	COMDAT ?ToRadians@@YAMM@Z
_TEXT	SEGMENT
tv68 = -196						; size = 4
_deg$ = 8						; size = 4
?ToRadians@@YAMM@Z PROC					; ToRadians, COMDAT

; 23   : inline float ToRadians( float deg ) { return deg * (float)D3DX_PI / 180.0f; }

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	movss	xmm0, DWORD PTR _deg$[ebp]
	mulss	xmm0, DWORD PTR __real@40490fdb
	divss	xmm0, DWORD PTR __real@43340000
	movss	DWORD PTR tv68[ebp], xmm0
	fld	DWORD PTR tv68[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ToRadians@@YAMM@Z ENDP					; ToRadians
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_G_System_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_G_System_error_category@std@@UAEPAXI@Z PROC		; std::_System_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_System_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_System_error_category@std@@UAEPAXI@Z ENDP		; std::_System_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1_System_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1_System_error_category@std@@UAE@XZ PROC		; std::_System_error_category::~_System_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1_System_error_category@std@@UAE@XZ ENDP		; std::_System_error_category::~_System_error_category
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::_System_error_category::default_error_condition, COMDAT
; _this$ = ecx

; 614  : 		{	// make error_condition for error code (generic if possible)

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 615  : 		if (_Syserror_map(_Errval))

	mov	eax, DWORD PTR __Errval$[ebp]
	push	eax
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@default_er

; 616  : 			return (error_condition(_Errval, generic_category()));

	call	?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category
	push	eax
	mov	eax, DWORD PTR __Errval$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@default_er

; 617  : 		else

	jmp	SHORT $LN3@default_er
$LN2@default_er:

; 618  : 			return (error_condition(_Errval, system_category()));

	call	?system_category@std@@YAABVerror_category@1@XZ ; std::system_category
	push	eax
	mov	eax, DWORD PTR __Errval$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@default_er:

; 619  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::_System_error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
tv69 = -232						; size = 4
$T1 = -224						; size = 4
__Name$ = -20						; size = 4
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_System_error_category::message, COMDAT
; _this$ = ecx

; 607  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 608  : 		const char *_Name = _Winerror_map(_Errcode);

	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	call	?_Winerror_map@std@@YAPBDH@Z		; std::_Winerror_map
	add	esp, 4
	mov	DWORD PTR __Name$[ebp], eax

; 609  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	cmp	DWORD PTR __Name$[ebp], 0
	je	SHORT $LN3@message
	mov	eax, DWORD PTR __Name$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@message
$LN3@message:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
$LN4@message:
	mov	ecx, DWORD PTR tv69[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	edx, DWORD PTR $T1[ebp]
	or	edx, 1
	mov	DWORD PTR $T1[ebp], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 610  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_System_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?name@_System_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?name@_System_error_category@std@@UBEPBDXZ PROC		; std::_System_error_category::name, COMDAT
; _this$ = ecx

; 602  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 603  : 		return ("system");

	mov	eax, OFFSET ??_C@_06FHFOAHML@system?$AA@

; 604  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?name@_System_error_category@std@@UBEPBDXZ ENDP		; std::_System_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??0_System_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0_System_error_category@std@@QAE@XZ PROC		; std::_System_error_category::_System_error_category, COMDAT
; _this$ = ecx

; 597  : 	_System_error_category()

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_System_error_category@std@@6B@

; 598  : 		{	// default constructor
; 599  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0_System_error_category@std@@QAE@XZ ENDP		; std::_System_error_category::_System_error_category
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_G_Iostream_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_G_Iostream_error_category@std@@UAEPAXI@Z PROC	; std::_Iostream_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Iostream_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Iostream_error_category@std@@UAEPAXI@Z ENDP	; std::_Iostream_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1_Iostream_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1_Iostream_error_category@std@@UAE@XZ PROC		; std::_Iostream_error_category::~_Iostream_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Iostream_error_category@std@@UAE@XZ ENDP		; std::_Iostream_error_category::~_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
$T1 = -212						; size = 4
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Iostream_error_category::message, COMDAT
; _this$ = ecx

; 584  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 585  : 		if (_Errcode == (int)io_errc::stream)

	cmp	DWORD PTR __Errcode$[ebp], 1
	jne	SHORT $LN2@message

; 586  : 			return ("iostream stream error");

	push	OFFSET ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@message

; 587  : 		else

	jmp	SHORT $LN3@message
$LN2@message:

; 588  : 			return (_Generic_error_category::message(_Errcode));

	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
	mov	edx, DWORD PTR $T1[ebp]
	or	edx, 1
	mov	DWORD PTR $T1[ebp], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@message:

; 589  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Iostream_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?name@_Iostream_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?name@_Iostream_error_category@std@@UBEPBDXZ PROC	; std::_Iostream_error_category::name, COMDAT
; _this$ = ecx

; 579  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 580  : 		return ("iostream");

	mov	eax, OFFSET ??_C@_08LLGCOLLL@iostream?$AA@

; 581  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?name@_Iostream_error_category@std@@UBEPBDXZ ENDP	; std::_Iostream_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??0_Iostream_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0_Iostream_error_category@std@@QAE@XZ PROC		; std::_Iostream_error_category::_Iostream_error_category, COMDAT
; _this$ = ecx

; 574  : 	_Iostream_error_category()

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_Iostream_error_category@std@@6B@

; 575  : 		{	// default constructor
; 576  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Iostream_error_category@std@@QAE@XZ ENDP		; std::_Iostream_error_category::_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_G_Generic_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_G_Generic_error_category@std@@UAEPAXI@Z PROC		; std::_Generic_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Generic_error_category@std@@UAEPAXI@Z ENDP		; std::_Generic_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1_Generic_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1_Generic_error_category@std@@UAE@XZ PROC		; std::_Generic_error_category::~_Generic_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1error_category@std@@UAE@XZ		; std::error_category::~error_category
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Generic_error_category@std@@UAE@XZ ENDP		; std::_Generic_error_category::~_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
tv69 = -232						; size = 4
$T1 = -224						; size = 4
__Name$ = -20						; size = 4
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Generic_error_category::message, COMDAT
; _this$ = ecx

; 563  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 564  : 		const char *_Name = _Syserror_map(_Errcode);

	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
	add	esp, 4
	mov	DWORD PTR __Name$[ebp], eax

; 565  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	cmp	DWORD PTR __Name$[ebp], 0
	je	SHORT $LN3@message
	mov	eax, DWORD PTR __Name$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@message
$LN3@message:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
$LN4@message:
	mov	ecx, DWORD PTR tv69[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	edx, DWORD PTR $T1[ebp]
	or	edx, 1
	mov	DWORD PTR $T1[ebp], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 566  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Generic_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?name@_Generic_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?name@_Generic_error_category@std@@UBEPBDXZ PROC	; std::_Generic_error_category::name, COMDAT
; _this$ = ecx

; 558  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 559  : 		return ("generic");

	mov	eax, OFFSET ??_C@_07DCLBNMLN@generic?$AA@

; 560  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?name@_Generic_error_category@std@@UBEPBDXZ ENDP	; std::_Generic_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??0_Generic_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0_Generic_error_category@std@@QAE@XZ PROC		; std::_Generic_error_category::_Generic_error_category, COMDAT
; _this$ = ecx

; 553  : 	_Generic_error_category()

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0error_category@std@@QAE@XZ		; std::error_category::error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_Generic_error_category@std@@6B@

; 554  : 		{	// default constructor
; 555  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Generic_error_category@std@@QAE@XZ ENDP		; std::_Generic_error_category::_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??8error_condition@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv78 = -208						; size = 4
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??8error_condition@std@@QBE_NABV01@@Z PROC		; std::error_condition::operator==, COMDAT
; _this$ = ecx

; 352  : 		{	// test if *this == _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 353  : 		return (category() == _Right.category()
; 354  : 			&& value() == _Right.value());

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
	mov	ecx, eax
	call	??8error_category@std@@QBE_NABV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@operator
	mov	ecx, DWORD PTR _this$[ebp]
	call	?value@error_condition@std@@QBEHXZ	; std::error_condition::value
	mov	esi, eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?value@error_condition@std@@QBEHXZ	; std::error_condition::value
	cmp	esi, eax
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv78[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv78[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv78[ebp]

; 355  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??8error_condition@std@@QBE_NABV01@@Z ENDP		; std::error_condition::operator==
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?category@error_condition@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?category@error_condition@std@@QBEABVerror_category@2@XZ PROC ; std::error_condition::category, COMDAT
; _this$ = ecx

; 337  : 		{	// get category

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 338  : 		return (*_Mycat);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 339  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?category@error_condition@std@@QBEABVerror_category@2@XZ ENDP ; std::error_condition::category
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?value@error_condition@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?value@error_condition@std@@QBEHXZ PROC			; std::error_condition::value, COMDAT
; _this$ = ecx

; 332  : 		{	// get error code

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 333  : 		return (_Myval);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 334  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?value@error_condition@std@@QBEHXZ ENDP			; std::error_condition::value
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??0error_condition@std@@QAE@HABVerror_category@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Val$ = 8						; size = 4
__Cat$ = 12						; size = 4
??0error_condition@std@@QAE@HABVerror_category@1@@Z PROC ; std::error_condition::error_condition, COMDAT
; _this$ = ecx

; 299  : 		{	// construct from error code and category

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Cat$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 300  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??0error_condition@std@@QAE@HABVerror_category@1@@Z ENDP ; std::error_condition::error_condition
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?category@error_code@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?category@error_code@std@@QBEABVerror_category@2@XZ PROC ; std::error_code::category, COMDAT
; _this$ = ecx

; 246  : 		{	// get category

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 247  : 		return (*_Mycat);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 248  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?category@error_code@std@@QBEABVerror_category@2@XZ ENDP ; std::error_code::category
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?value@error_code@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?value@error_code@std@@QBEHXZ PROC			; std::error_code::value, COMDAT
; _this$ = ecx

; 241  : 		{	// get error code

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 242  : 		return (_Myval);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 243  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?value@error_code@std@@QBEHXZ ENDP			; std::error_code::value
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_Gerror_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_Gerror_category@std@@UAEPAXI@Z PROC			; std::error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1error_category@std@@UAE@XZ		; std::error_category::~error_category
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gerror_category@std@@UAEPAXI@Z ENDP			; std::error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??8error_category@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv65 = -208						; size = 4
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??8error_category@std@@QBE_NABV01@@Z PROC		; std::error_category::operator==, COMDAT
; _this$ = ecx

; 176  : 		{	// compare categories for equality

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 177  : 		return (this == &_Right);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv65[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv65[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv65[ebp]

; 178  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??8error_category@std@@QBE_NABV01@@Z ENDP		; std::error_category::operator==
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
_TEXT	SEGMENT
tv74 = -208						; size = 4
_this$ = -8						; size = 4
__Code$ = 8						; size = 4
__Errval$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 391  : 	{	// test if conditions same for this category

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 392  : 	return (*this == _Code.category() && _Code.value() == _Errval);

	mov	ecx, DWORD PTR __Code$[ebp]
	call	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8error_category@std@@QBE_NABV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@equivalent
	mov	ecx, DWORD PTR __Code$[ebp]
	call	?value@error_code@std@@QBEHXZ		; std::error_code::value
	cmp	eax, DWORD PTR __Errval$[ebp]
	jne	SHORT $LN3@equivalent
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $LN4@equivalent
$LN3@equivalent:
	mov	DWORD PTR tv74[ebp], 0
$LN4@equivalent:
	mov	al, BYTE PTR tv74[ebp]

; 393  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
_TEXT	SEGMENT
$T1 = -216						; size = 8
_this$ = -8						; size = 4
__Errval$ = 8						; size = 4
__Cond$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 384  : 	{	// test if error code same condition

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 385  : 	return (default_error_condition(_Errval) == _Cond);

	mov	eax, DWORD PTR __Cond$[ebp]
	push	eax
	mov	esi, esp
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, eax
	call	??8error_condition@std@@QBE_NABV01@@Z	; std::error_condition::operator==

; 386  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::error_category::default_error_condition, COMDAT
; _this$ = ecx

; 377  : 	{	// make error_condition for error code

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 378  : 	return (error_condition(_Errval, *this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 379  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??1error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1error_category@std@@UAE@XZ PROC			; std::error_category::~error_category, COMDAT
; _this$ = ecx

; 159  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@

; 160  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1error_category@std@@UAE@XZ ENDP			; std::error_category::~error_category
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??0error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0error_category@std@@QAE@XZ PROC			; std::error_category::error_category, COMDAT
; _this$ = ecx

; 154  : 	error_category()

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@

; 155  : 		{	// default constructor
; 156  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0error_category@std@@QAE@XZ ENDP			; std::error_category::error_category
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?system_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?system_category@std@@YAABVerror_category@1@XZ PROC	; std::system_category, COMDAT

; 652  : 	{	// get system_category

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 653  : 	return (_Error_objects<int>::_System_object);

	mov	eax, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object

; 654  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?system_category@std@@YAABVerror_category@1@XZ ENDP	; std::system_category
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?generic_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?generic_category@std@@YAABVerror_category@1@XZ PROC	; std::generic_category, COMDAT

; 642  : 	{	// get generic_category

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 643  : 	return (_Error_objects<int>::_Generic_object);

	mov	eax, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object

; 644  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?generic_category@std@@YAABVerror_category@1@XZ ENDP	; std::generic_category
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__File$ = 12						; size = 4
__Line$ = 16						; size = 4
??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z PROC		; std::_Debug_pointer<char>, COMDAT

; 545  : 	{	// test iterator for non-singularity, const pointers

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 546  : 	if (_First == 0)

	cmp	DWORD PTR __First$[ebp], 0
	jne	SHORT $LN2@Debug_poin

; 547  : 		_DEBUG_ERROR2("invalid null pointer", _File, _Line);

	mov	eax, DWORD PTR __Line$[ebp]
	push	eax
	mov	ecx, DWORD PTR __File$[ebp]
	push	ecx
	push	OFFSET ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
	call	?_Debug_message@std@@YAXPB_W0I@Z	; std::_Debug_message
	add	esp, 12					; 0000000cH
$LN2@Debug_poin:

; 548  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ENDP		; std::_Debug_pointer<char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
;	COMDAT ??0id@locale@std@@QAE@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Val$ = 8						; size = 4
??0id@locale@std@@QAE@I@Z PROC				; std::locale::id::id, COMDAT
; _this$ = ecx

; 74   : 			{	// construct with specified stamp value

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx

; 75   : 			}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0id@locale@std@@QAE@I@Z ENDP				; std::locale::id::id
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran, COMDAT
; _this$ = ecx

; 2294 : 		{	// report an out_of_range error

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2295 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	?_Xout_of_range@std@@YAXPBD@Z		; std::_Xout_of_range
$LN2@Xran:

; 2296 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT
; _this$ = ecx

; 2289 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2290 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN2@Xlen:

; 2291 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
_TEXT	SEGMENT
$T1 = -233						; size = 1
$T2 = -221						; size = 1
__Ptr$3 = -20						; size = 4
_this$ = -8						; size = 4
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 2272 : 		{	// initialize buffer, deallocating any storage

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2273 : 		if (!_Built)

	movzx	eax, BYTE PTR __Built$[ebp]
	test	eax, eax
	jne	SHORT $LN4@Tidy
	jmp	SHORT $LN3@Tidy
$LN4@Tidy:

; 2274 : 			;
; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 16			; 00000010H
	jb	SHORT $LN3@Tidy

; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Ptr$3[ebp], ecx

; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>

; 2279 : 			if (0 < _Newsize)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN1@Tidy

; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);

	mov	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$3[ebp]
	push	ecx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 4
	push	edx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$LN1@Tidy:

; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR __Ptr$3[ebp]
	push	edx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN3@Tidy:

; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24], 15			; 0000000fH

; 2285 : 		_Eos(_Newsize);

	mov	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 2286 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 2256 : 		{	// test if _Ptr points inside string

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)

	cmp	DWORD PTR __Ptr$[ebp], 0
	je	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	cmp	DWORD PTR __Ptr$[ebp], eax
	jb	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+20]
	cmp	eax, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN3@Inside
$LN2@Inside:

; 2259 : 			return (false);	// don't ask

	xor	al, al
	jmp	SHORT $LN4@Inside

; 2260 : 		else

	jmp	SHORT $LN4@Inside
$LN3@Inside:

; 2261 : 			return (true);

	mov	al, 1
$LN4@Inside:

; 2262 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
_TEXT	SEGMENT
tv136 = -208						; size = 4
tv129 = -208						; size = 4
_this$ = -8						; size = 4
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2243 : 		if (max_size() < _Newsize)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN6@Grow

; 2244 : 			_Xlen();	// result too long

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN6@Grow:

; 2245 : 		if (this->_Myres < _Newsize)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	cmp	ecx, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN5@Grow

; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	mov	edx, DWORD PTR __Newsize$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	jmp	SHORT $LN4@Grow
$LN5@Grow:

; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)

	movzx	eax, BYTE PTR __Trim$[ebp]
	test	eax, eax
	je	SHORT $LN3@Grow
	cmp	DWORD PTR __Newsize$[ebp], 16		; 00000010H
	jae	SHORT $LN3@Grow

; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	cmp	ecx, DWORD PTR [eax+20]
	jae	SHORT $LN9@Grow
	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR tv129[ebp], edx
	jmp	SHORT $LN10@Grow
$LN9@Grow:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR tv129[ebp], ecx
$LN10@Grow:
	mov	edx, DWORD PTR tv129[ebp]
	push	edx
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
	jmp	SHORT $LN4@Grow
$LN3@Grow:

; 2250 : 		else if (_Newsize == 0)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jne	SHORT $LN4@Grow

; 2251 : 			_Eos(0);	// new size is zero, just null terminate

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN4@Grow:

; 2252 : 		return (0 < _Newsize);	// return true only if more work to do

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN11@Grow
	mov	DWORD PTR tv136[ebp], 1
	jmp	SHORT $LN12@Grow
$LN11@Grow:
	mov	DWORD PTR tv136[ebp], 0
$LN12@Grow:
	mov	al, BYTE PTR tv136[ebp]
$LN8@Grow:

; 2253 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
$T1 = -209						; size = 1
_this$ = -8						; size = 4
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 2236 : 		{	// set new length and null terminator

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	BYTE PTR $T1[ebp], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR [eax+20], ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	call	?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign
	add	esp, 8

; 2238 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
_TEXT	SEGMENT
tv205 = -288						; size = 4
tv203 = -288						; size = 4
tv204 = -284						; size = 4
tv202 = -284						; size = 4
$T2 = -273						; size = 1
$T3 = -261						; size = 1
$T4 = -249						; size = 1
__Ptr$ = -48						; size = 4
__Newres$ = -36						; size = 4
_this$ = -24						; size = 4
__$EHRec$ = -16						; size = 16
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 272				; 00000110H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-288]
	mov	ecx, 68					; 00000044H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

	mov	eax, DWORD PTR __Newsize$[ebp]
	or	eax, 15					; 0000000fH
	mov	DWORD PTR __Newres$[ebp], eax

; 2203 : 		if (max_size() < _Newres)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newres$[ebp]
	jae	SHORT $LN9@Copy

; 2204 : 			_Newres = _Newsize;	// undo roundup if too big

	mov	eax, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], eax
	jmp	SHORT $LN8@Copy
$LN9@Copy:

; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)

	mov	eax, DWORD PTR __Newres$[ebp]
	xor	edx, edx
	mov	ecx, 3
	div	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+24]
	shr	ecx, 1
	cmp	ecx, eax
	ja	SHORT $LN7@Copy
	jmp	SHORT $LN8@Copy
$LN7@Copy:

; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)

	mov	eax, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [eax+24]
	shr	esi, 1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	sub	eax, esi
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+24], eax
	ja	SHORT $LN5@Copy

; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	shr	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+24]
	mov	DWORD PTR __Newres$[ebp], ecx

; 2210 : 		else

	jmp	SHORT $LN8@Copy
$LN5@Copy:

; 2211 : 			_Newres = max_size();	// settle for max_size()

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	mov	DWORD PTR __Newres$[ebp], eax
$LN8@Copy:

; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR tv202[ebp], eax
	mov	ecx, DWORD PTR __Newres$[ebp]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR tv202[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR tv203[ebp], eax
	mov	edx, DWORD PTR tv203[ebp]
	mov	DWORD PTR __Ptr$[ebp], edx
	jmp	SHORT $LN12@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:

; 2216 : 		_CATCH_ALL

	mov	DWORD PTR __$EHRec$[ebp], esp

; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

	mov	eax, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], eax

; 2218 : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 2

; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR tv204[ebp], eax
	mov	ecx, DWORD PTR __Newres$[ebp]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR tv204[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR tv205[ebp], eax
	mov	edx, DWORD PTR tv205[ebp]
	mov	DWORD PTR __Ptr$[ebp], edx
	jmp	SHORT $LN14@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1:

; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2222 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 2223 : 			_CATCH_END

	mov	eax, $LN17@Copy
	ret	0
$LN14@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
	jmp	SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2
$LN17@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2:

; 2224 : 		_CATCH_END

	mov	eax, $LN19@Copy
	ret	0
$LN12@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3
$LN19@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3:

; 2225 : 
; 2226 : 		if (0 < _Oldlen)

	cmp	DWORD PTR __Oldlen$[ebp], 0
	jbe	SHORT $LN1@Copy

; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements

	mov	eax, DWORD PTR __Oldlen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$LN1@Copy:

; 2229 : 		_Tidy(true);

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);

	lea	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	push	ecx
	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>

; 2231 : 		this->_Myres = _Newres;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newres$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 2232 : 		_Eos(_Oldlen);

	mov	eax, DWORD PTR __Oldlen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN11@Copy:

; 2233 : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN23@Copy
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 288				; 00000120H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	2
$LN23@Copy:
	DD	1
	DD	$LN22@Copy
$LN22@Copy:
	DD	-48					; ffffffd0H
	DD	4
	DD	$LN20@Copy
$LN20@Copy:
	DB	95					; 0000005fH
	DB	80					; 00000050H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-292]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
tv75 = -232						; size = 4
$T1 = -221						; size = 1
__Num$ = -20						; size = 4
_this$ = -8						; size = 4
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1758 : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1759 : 		size_type _Num = this->_Getal().max_size();

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
	mov	DWORD PTR __Num$[ebp], eax

; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);

	cmp	DWORD PTR __Num$[ebp], 1
	ja	SHORT $LN3@max_size
	mov	DWORD PTR tv75[ebp], 1
	jmp	SHORT $LN4@max_size
$LN3@max_size:
	mov	eax, DWORD PTR __Num$[ebp]
	sub	eax, 1
	mov	DWORD PTR tv75[ebp], eax
$LN4@max_size:
	mov	eax, DWORD PTR tv75[ebp]

; 1761 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1753 : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1754 : 		return (this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+20]

; 1755 : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Newsize$1 = -32					; size = 4
__Ptr$2 = -20						; size = 4
_this$ = -8						; size = 4
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1342 : 		{	// erase elements [_Off, _Off + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1343 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN4@erase

; 1344 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN4@erase:

; 1345 : 		if (this->_Mysize - _Off <= _Count)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR __Off$[ebp]
	cmp	ecx, DWORD PTR __Count$[ebp]
	ja	SHORT $LN3@erase

; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
	jmp	SHORT $LN2@erase
$LN3@erase:

; 1347 : 		else if (0 < _Count)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN2@erase

; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Off$[ebp]
	mov	DWORD PTR __Ptr$2[ebp], eax

; 1350 : 			size_type _Newsize = this->_Mysize - _Count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Newsize$1[ebp], ecx

; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

	mov	eax, DWORD PTR __Newsize$1[ebp]
	sub	eax, DWORD PTR __Off$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$2[ebp]
	add	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$2[ebp]
	push	edx
	call	?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
	add	esp, 12					; 0000000cH

; 1352 : 			_Eos(_Newsize);

	mov	eax, DWORD PTR __Newsize$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@erase:

; 1353 : 			}
; 1354 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN6@erase:

; 1355 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Off$ = 8						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1334 : 		{	// erase elements [_Off, ...)

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1335 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN1@erase

; 1336 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN1@erase:

; 1337 : 		_Eos(_Off);

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 1338 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN3@erase:

; 1339 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1167 : 		{	// assign [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1168 : 		_DEBUG_POINTER(_Ptr);

	push	1168					; 00000490H
	push	OFFSET ??_C@_1IO@JLPDPDPD@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z	; std::_Debug_pointer<char>
	add	esp, 12					; 0000000cH

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	?length@?$char_traits@D@std@@SAIPBD@Z	; std::char_traits<char>::length
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1170 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)

	cmp	DWORD PTR __Count$[ebp], 0
	je	SHORT $LN3@assign

; 1151 : 			_DEBUG_POINTER(_Ptr);

	push	1151					; 0000047fH
	push	OFFSET ??_C@_1IO@JLPDPDPD@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z	; std::_Debug_pointer<char>
	add	esp, 12					; 0000000cH
$LN3@assign:

; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@assign

; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR __Ptr$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	jmp	SHORT $LN4@assign
$LN2@assign:

; 1157 : 
; 1158 : 		if (_Grow(_Count))

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@assign

; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1161 : 			_Eos(_Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN1@assign:

; 1162 : 			}
; 1163 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN4@assign:

; 1164 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Num$ = -20						; size = 4
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1130 : 		if (_Right.size() < _Roff)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	cmp	eax, DWORD PTR __Roff$[ebp]
	jae	SHORT $LN5@assign

; 1131 : 			_Xran();	// _Roff off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN5@assign:

; 1132 : 		size_type _Num = _Right.size() - _Roff;

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	sub	eax, DWORD PTR __Roff$[ebp]
	mov	DWORD PTR __Num$[ebp], eax

; 1133 : 		if (_Count < _Num)

	mov	eax, DWORD PTR __Count$[ebp]
	cmp	eax, DWORD PTR __Num$[ebp]
	jae	SHORT $LN4@assign

; 1134 : 			_Num = _Count;	// trim _Num to size

	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Num$[ebp], eax
$LN4@assign:

; 1135 : 
; 1136 : 		if (this == &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@assign

; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

	mov	eax, DWORD PTR __Roff$[ebp]
	add	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	mov	ecx, DWORD PTR __Roff$[ebp]
	push	ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	jmp	SHORT $LN2@assign
$LN3@assign:

; 1138 : 		else if (_Grow(_Num))

	push	0
	mov	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@assign

; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);

	mov	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Roff$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1142 : 			_Eos(_Num);

	mov	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@assign:

; 1143 : 			}
; 1144 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN7@assign:

; 1145 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 990  : 		{	// destroy the string

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 991  : 		_Tidy(true);

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 992  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
$T2 = -221						; size = 1
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 780  : 		{	// construct from [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 781  : 		_Tidy();

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 782  : 		assign(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 783  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-232]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 683  : 		{	// get reference to allocator

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 684  : 		return (_Alty());

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 685  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__Alproxy$ = -17					; size = 1
_this$ = -8						; size = 4
?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Free_proxy, COMDAT
; _this$ = ecx

; 672  : 		{	// destroy proxy

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 673  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 674  : 			_Alproxy;

	lea	ecx, DWORD PTR __Alproxy$[ebp]
	call	??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>

; 675  : 		this->_Orphan_all();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all

; 676  : 		_Alproxy.destroy(this->_Myproxy);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	ecx, DWORD PTR __Alproxy$[ebp]
	call	??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>

; 677  : 		_Alproxy.deallocate(this->_Myproxy, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	ecx, DWORD PTR __Alproxy$[ebp]
	call	?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate

; 678  : 		this->_Myproxy = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 679  : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Free_proxy
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN5@Free_proxy:
	DD	1
	DD	$LN4@Free_proxy
$LN4@Free_proxy:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN3@Free_proxy
$LN3@Free_proxy:
	DB	95					; 0000005fH
	DB	65					; 00000041H
	DB	108					; 0000006cH
	DB	112					; 00000070H
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	120					; 00000078H
	DB	121					; 00000079H
	DB	0
?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Free_proxy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T1 = -228						; size = 8
__Alproxy$ = -17					; size = 1
_this$ = -8						; size = 4
?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Alloc_proxy, COMDAT
; _this$ = ecx

; 663  : 		{	// construct proxy from _Alval

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 664  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 665  : 			_Alproxy;

	lea	ecx, DWORD PTR __Alproxy$[ebp]
	call	??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>

; 666  : 		this->_Myproxy = _Alproxy.allocate(1);

	push	1
	lea	ecx, DWORD PTR __Alproxy$[ebp]
	call	?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 667  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());

	lea	ecx, DWORD PTR $T1[ebp]
	call	??0_Container_proxy@std@@QAE@XZ		; std::_Container_proxy::_Container_proxy
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	ecx, DWORD PTR __Alproxy$[ebp]
	call	??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>

; 668  : 		this->_Myproxy->_Mycont = this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], edx

; 669  : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Alloc_prox
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN5@Alloc_prox:
	DD	1
	DD	$LN4@Alloc_prox
$LN4@Alloc_prox:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN3@Alloc_prox
$LN3@Alloc_prox:
	DB	95					; 0000005fH
	DB	65					; 00000041H
	DB	108					; 0000006cH
	DB	112					; 00000070H
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	120					; 00000078H
	DB	121					; 00000079H
	DB	0
?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Alloc_proxy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 649  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 650  : 		_Free_proxy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Free_proxy

; 651  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
___formal$ = 8						; size = 4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 643  : 	_String_alloc(const _Alloc& = _Alloc())

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 644  : 		{	// construct allocator from _Al
; 645  : 		_Alloc_proxy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Alloc_proxy

; 646  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
__ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Container_base12@std@@QAE@XZ	; std::_Container_base12::~_Container_base12
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
tv72 = -208						; size = 4
_this$ = -8						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 517  : 		{	// determine current pointer to buffer for nonmutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 518  : 		return (this->_BUF_SIZE <= this->_Myres
; 519  : 			? _STD addressof(*this->_Bx._Ptr)
; 520  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	DWORD PTR tv72[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv72[ebp]

; 521  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
tv72 = -208						; size = 4
_this$ = -8						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 510  : 		{	// determine current pointer to buffer for mutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 511  : 		return (this->_BUF_SIZE <= this->_Myres
; 512  : 			? _STD addressof(*this->_Bx._Ptr)
; 513  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	DWORD PTR tv72[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv72[ebp]

; 514  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 492  : 	_String_val()

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base12@std@@QAE@XZ	; std::_Container_base12::_Container_base12

; 493  : 		{	// initialize values
; 494  : 		_Mysize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 495  : 		_Myres = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24], 0

; 496  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 883  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 884  : 		return (_Mytraits::max_size(*this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
	add	esp, 4

; 885  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::deallocate, COMDAT
; _this$ = ecx

; 857  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 858  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate

; 859  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::allocate, COMDAT
; _this$ = ecx

; 846  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 847  : 		return (_Mybase::allocate(_Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate

; 848  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ PROC	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 801  : 		{	// construct default allocator (do nothing)

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>

; 802  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::allocator_traits<std::allocator<char> >::max_size, COMDAT

; 734  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 735  : 		return (_Al.max_size());

	mov	ecx, DWORD PTR __Al$[ebp]
	call	?max_size@?$allocator@D@std@@QBEIXZ	; std::allocator<char>::max_size

; 736  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?max_size@?$allocator@D@std@@QBEIXZ PROC		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 611  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 612  : 		return ((size_t)(-1) / sizeof (_Ty));

	or	eax, -1

; 613  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 577  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 578  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@D@std@@YAPADIPAD@Z		; std::_Allocate<char>
	add	esp, 8

; 579  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 573  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 574  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 552  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$di	SEGMENT
$T1 = -197						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3451 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ?_Orphan_all@_Container_base12@std@@QAEXXZ
_TEXT	SEGMENT
__Pnext$1 = -32						; size = 4
__Lock$2 = -20						; size = 4
_this$ = -8						; size = 4
?_Orphan_all@_Container_base12@std@@QAEXXZ PROC		; std::_Container_base12::_Orphan_all, COMDAT
; _this$ = ecx

; 214  : 	{	// orphan all iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 215  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 216  : 	if (_Myproxy != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN5@Orphan_all

; 217  : 		{	// proxy allocated, drain it
; 218  : 		_Lockit _Lock(_LOCK_DEBUG);

	push	3
	lea	ecx, DWORD PTR __Lock$2[ebp]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit

; 219  : 
; 220  : 		for (_Iterator_base12 **_Pnext = &_Myproxy->_Myfirstiter;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 4
	mov	DWORD PTR __Pnext$1[ebp], ecx

; 221  : 			*_Pnext != 0; *_Pnext = (*_Pnext)->_Mynextiter)

	jmp	SHORT $LN3@Orphan_all
$LN2@Orphan_all:
	mov	eax, DWORD PTR __Pnext$1[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Pnext$1[ebp]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx], eax
$LN3@Orphan_all:
	mov	eax, DWORD PTR __Pnext$1[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN1@Orphan_all

; 222  : 			(*_Pnext)->_Myproxy = 0;

	mov	eax, DWORD PTR __Pnext$1[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], 0
	jmp	SHORT $LN2@Orphan_all
$LN1@Orphan_all:

; 223  : 		_Myproxy->_Myfirstiter = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [ecx+4], 0

; 224  : 		}

	lea	ecx, DWORD PTR __Lock$2[ebp]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
$LN5@Orphan_all:

; 225  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 226  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN10@Orphan_all
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN10@Orphan_all:
	DD	1
	DD	$LN9@Orphan_all
$LN9@Orphan_all:
	DD	-20					; ffffffecH
	DD	4
	DD	$LN8@Orphan_all
$LN8@Orphan_all:
	DB	95					; 0000005fH
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	0
?_Orphan_all@_Container_base12@std@@QAEXXZ ENDP		; std::_Container_base12::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??1_Container_base12@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1_Container_base12@std@@QAE@XZ PROC			; std::_Container_base12::~_Container_base12, COMDAT
; _this$ = ecx

; 94   : 		{	// destroy the container

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 95   : 		_Orphan_all();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all

; 96   : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Container_base12@std@@QAE@XZ ENDP			; std::_Container_base12::~_Container_base12
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??0_Container_base12@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0_Container_base12@std@@QAE@XZ PROC			; std::_Container_base12::_Container_base12, COMDAT
; _this$ = ecx

; 80   : 		{	// construct childless container

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 81   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Container_base12@std@@QAE@XZ ENDP			; std::_Container_base12::_Container_base12
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??0_Container_proxy@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0_Container_proxy@std@@QAE@XZ PROC			; std::_Container_proxy::_Container_proxy, COMDAT
; _this$ = ecx

; 68   : 		{	// construct from pointers

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 69   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Container_proxy@std@@QAE@XZ ENDP			; std::_Container_proxy::_Container_proxy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$di	SEGMENT
$T1 = -197						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 70   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 563  : 		{	// assign an element

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 564  : 		_Left = _Right;

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 565  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -196						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::move, COMDAT

; 551  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 552  : 		return (_Count == 0 ? _First1
; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN3@move
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@move
$LN3@move:
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
$LN4@move:
	mov	eax, DWORD PTR tv69[ebp]

; 554  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 196				; 000000c4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?move@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -196						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::copy, COMDAT

; 528  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 529  : 		return (_Count == 0 ? _First1
; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN3@copy
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@copy
$LN3@copy:
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
$LN4@copy:
	mov	eax, DWORD PTR tv69[ebp]

; 531  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 196				; 000000c4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
tv68 = -196						; size = 4
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 521  : 		{	// find length of null-terminated string

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 522  : 		return (*_First == 0 ? 0
; 523  : 			: _CSTD strlen(_First));

	mov	eax, DWORD PTR __First$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN3@length
	mov	DWORD PTR tv68[ebp], 0
	jmp	SHORT $LN4@length
$LN3@length:
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR tv68[ebp], eax
$LN4@length:
	mov	eax, DWORD PTR tv68[ebp]

; 524  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 196				; 000000c4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??__F_AtlWinModule@ATL@@YAXXZ
text$yd	SEGMENT
??__F_AtlWinModule@ATL@@YAXXZ PROC			; ATL::`dynamic atexit destructor for '_AtlWinModule'', COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A ; ATL::_AtlWinModule
	call	??1CAtlWinModule@ATL@@QAE@XZ		; ATL::CAtlWinModule::~CAtlWinModule
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__F_AtlWinModule@ATL@@YAXXZ ENDP			; ATL::`dynamic atexit destructor for '_AtlWinModule''
text$yd	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlbase.h
;	COMDAT ??__E_AtlWinModule@ATL@@YAXXZ
text$di	SEGMENT
??__E_AtlWinModule@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for '_AtlWinModule'', COMDAT

; 2821 : __declspec(selectany) CAtlWinModule _AtlWinModule;

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A ; ATL::_AtlWinModule
	call	??0CAtlWinModule@ATL@@QAE@XZ		; ATL::CAtlWinModule::CAtlWinModule
	push	OFFSET ??__F_AtlWinModule@ATL@@YAXXZ	; ATL::`dynamic atexit destructor for '_AtlWinModule''
	call	_atexit
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__E_AtlWinModule@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for '_AtlWinModule''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlbase.h
;	COMDAT ?Term@CAtlWinModule@ATL@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Term@CAtlWinModule@ATL@@QAEXXZ PROC			; ATL::CAtlWinModule::Term, COMDAT
; _this$ = ecx

; 2805 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2806 : 		AtlWinModuleTerm(this, _AtlBaseModule.GetModuleInstance());

	mov	ecx, OFFSET ?_AtlBaseModule@ATL@@3VCAtlBaseModule@1@A ; ATL::_AtlBaseModule
	call	?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ ; ATL::CAtlBaseModule::GetModuleInstance
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z ; ATL::AtlWinModuleTerm

; 2807 : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Term@CAtlWinModule@ATL@@QAEXXZ ENDP			; ATL::CAtlWinModule::Term
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlbase.h
;	COMDAT ??1CAtlWinModule@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1CAtlWinModule@ATL@@QAE@XZ PROC			; ATL::CAtlWinModule::~CAtlWinModule, COMDAT
; _this$ = ecx

; 2800 : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CAtlWinModule@ATL@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2801 : 		Term();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Term@CAtlWinModule@ATL@@QAEXXZ		; ATL::CAtlWinModule::Term

; 2802 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_ATL_WIN_MODULE70@ATL@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CAtlWinModule@ATL@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_ATL_WIN_MODULE70@ATL@@QAE@XZ
__ehhandler$??1CAtlWinModule@ATL@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1CAtlWinModule@ATL@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CAtlWinModule@ATL@@QAE@XZ ENDP			; ATL::CAtlWinModule::~CAtlWinModule
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlbase.h
;	COMDAT ??0CAtlWinModule@ATL@@QAE@XZ
_TEXT	SEGMENT
_hr$ = -20						; size = 4
_this$ = -8						; size = 4
??0CAtlWinModule@ATL@@QAE@XZ PROC			; ATL::CAtlWinModule::CAtlWinModule, COMDAT
; _this$ = ecx

; 2786 : 	CAtlWinModule()

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_ATL_WIN_MODULE70@ATL@@QAE@XZ

; 2787 : 	{
; 2788 : 		cbSize = sizeof(_ATL_WIN_MODULE);

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 44			; 0000002cH

; 2789 : 		HRESULT hr = AtlWinModuleInit(this);

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?AtlWinModuleInit@ATL@@YGJPAU_ATL_WIN_MODULE70@1@@Z ; ATL::AtlWinModuleInit
	mov	DWORD PTR _hr$[ebp], eax

; 2790 : 		if (FAILED(hr))

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $LN2@CAtlWinMod

; 2791 : 		{
; 2792 : 			ATLASSERT(0);

	xor	eax, eax
	jne	SHORT $LN4@CAtlWinMod
	push	OFFSET ??_C@_13COJANIEC@?$AA0?$AA?$AA@
	push	OFFSET ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
	push	0
	push	2792					; 00000ae8H
	push	OFFSET ??_C@_1KA@ELJIHIAD@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	2
	call	__CrtDbgReportW
	add	esp, 24					; 00000018H
	cmp	eax, 1
	jne	SHORT $LN4@CAtlWinMod
	int	3
$LN4@CAtlWinMod:

; 2793 : 			CAtlBaseModule::m_bInitFailed = true;

	mov	BYTE PTR ?m_bInitFailed@CAtlBaseModule@ATL@@2_NA, 1 ; ATL::CAtlBaseModule::m_bInitFailed

; 2794 : 			cbSize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
$LN2@CAtlWinMod:

; 2795 : 			return;
; 2796 : 		}
; 2797 : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0CAtlWinModule@ATL@@QAE@XZ ENDP			; ATL::CAtlWinModule::CAtlWinModule
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??__F_AtlComModule@ATL@@YAXXZ
text$yd	SEGMENT
??__F_AtlComModule@ATL@@YAXXZ PROC			; ATL::`dynamic atexit destructor for '_AtlComModule'', COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET ?_AtlComModule@ATL@@3VCAtlComModule@1@A ; ATL::_AtlComModule
	call	??1CAtlComModule@ATL@@QAE@XZ		; ATL::CAtlComModule::~CAtlComModule
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__F_AtlComModule@ATL@@YAXXZ ENDP			; ATL::`dynamic atexit destructor for '_AtlComModule''
text$yd	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlbase.h
;	COMDAT ??__E_AtlComModule@ATL@@YAXXZ
text$di	SEGMENT
??__E_AtlComModule@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for '_AtlComModule'', COMDAT

; 2565 : __declspec(selectany) CAtlComModule _AtlComModule;

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET ?_AtlComModule@ATL@@3VCAtlComModule@1@A ; ATL::_AtlComModule
	call	??0CAtlComModule@ATL@@QAE@XZ		; ATL::CAtlComModule::CAtlComModule
	push	OFFSET ??__F_AtlComModule@ATL@@YAXXZ	; ATL::`dynamic atexit destructor for '_AtlComModule''
	call	_atexit
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__E_AtlComModule@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for '_AtlComModule''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlbase.h
;	COMDAT ?Term@CAtlComModule@ATL@@QAEXXZ
_TEXT	SEGMENT
_factory$1 = -44					; size = 4
_pCache$2 = -32						; size = 4
_ppEntry$3 = -20					; size = 4
_this$ = -8						; size = 4
?Term@CAtlComModule@ATL@@QAEXXZ PROC			; ATL::CAtlComModule::Term, COMDAT
; _this$ = ecx

; 2462 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2463 : 		if (cbSize == 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN6@Term

; 2464 : 			return;

	jmp	$LN7@Term
$LN6@Term:

; 2465 : 
; 2466 : 		for (_ATL_OBJMAP_ENTRY_EX** ppEntry = m_ppAutoObjMapFirst; ppEntry < m_ppAutoObjMapLast; ppEntry++)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _ppEntry$3[ebp], ecx
	jmp	SHORT $LN5@Term
$LN4@Term:
	mov	eax, DWORD PTR _ppEntry$3[ebp]
	add	eax, 4
	mov	DWORD PTR _ppEntry$3[ebp], eax
$LN5@Term:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _ppEntry$3[ebp]
	cmp	ecx, DWORD PTR [eax+12]
	jae	SHORT $LN3@Term

; 2467 : 		{
; 2468 : 			if (*ppEntry != NULL)

	mov	eax, DWORD PTR _ppEntry$3[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@Term

; 2469 : 			{
; 2470 : 				_ATL_OBJMAP_CACHE* pCache = (**ppEntry).pCache;

	mov	eax, DWORD PTR _ppEntry$3[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _pCache$2[ebp], edx

; 2471 : 				
; 2472 : 				if (pCache->pCF != NULL)

	mov	eax, DWORD PTR _pCache$2[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@Term

; 2473 : 				{
; 2474 : 					// Decode factory pointer if it's not null
; 2475 : 					IUnknown *factory = reinterpret_cast<IUnknown*>(::DecodePointer(pCache->pCF));

	mov	esi, esp
	mov	eax, DWORD PTR _pCache$2[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR __imp__DecodePointer@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _factory$1[ebp], eax

; 2476 : 					_Analysis_assume_(factory != nullptr);
; 2477 : 					factory->Release();					

	mov	eax, DWORD PTR _factory$1[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	esi, esp
	mov	edx, DWORD PTR _factory$1[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+8]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2478 : 					pCache->pCF = NULL;

	mov	eax, DWORD PTR _pCache$2[ebp]
	mov	DWORD PTR [eax], 0
$LN2@Term:

; 2479 : 				}				
; 2480 : 			}
; 2481 : 		}

	jmp	SHORT $LN4@Term
$LN3@Term:

; 2482 : 		m_csObjMap.Term();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?Term@CComCriticalSection@ATL@@QAEJXZ	; ATL::CComCriticalSection::Term

; 2483 : 		// Set to 0 to indicate that this function has been called
; 2484 : 		// At this point no one should be concerned about cbsize
; 2485 : 		// having the correct value
; 2486 : 		cbSize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
$LN7@Term:

; 2487 : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Term@CAtlComModule@ATL@@QAEXXZ ENDP			; ATL::CAtlComModule::Term
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlbase.h
;	COMDAT ??1CAtlComModule@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1CAtlComModule@ATL@@QAE@XZ PROC			; ATL::CAtlComModule::~CAtlComModule, COMDAT
; _this$ = ecx

; 2456 : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CAtlComModule@ATL@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2457 : 		Term();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Term@CAtlComModule@ATL@@QAEXXZ		; ATL::CAtlComModule::Term

; 2458 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_ATL_COM_MODULE70@ATL@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CAtlComModule@ATL@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_ATL_COM_MODULE70@ATL@@QAE@XZ
__ehhandler$??1CAtlComModule@ATL@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1CAtlComModule@ATL@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CAtlComModule@ATL@@QAE@XZ ENDP			; ATL::CAtlComModule::~CAtlComModule
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlbase.h
;	COMDAT ??0CAtlComModule@ATL@@QAE@XZ
_TEXT	SEGMENT
$T1 = -216						; size = 8
_this$ = -8						; size = 4
??0CAtlComModule@ATL@@QAE@XZ PROC			; ATL::CAtlComModule::CAtlComModule, COMDAT
; _this$ = ecx

; 2435 : 	CAtlComModule() throw()

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_ATL_COM_MODULE70@ATL@@QAE@XZ

; 2436 : 	{
; 2437 : 		cbSize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 2438 : 
; 2439 : 		m_hInstTypeLib = reinterpret_cast<HINSTANCE>(&__ImageBase);

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], OFFSET ___ImageBase

; 2440 : 
; 2441 : 		m_ppAutoObjMapFirst = &__pobjMapEntryFirst + 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], OFFSET ___pobjMapEntryFirst+4

; 2442 : 		m_ppAutoObjMapLast = &__pobjMapEntryLast;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], OFFSET ___pobjMapEntryLast

; 2443 : 
; 2444 : 		if (FAILED(m_csObjMap.Init()))

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?Init@CComCriticalSection@ATL@@QAEJXZ	; ATL::CComCriticalSection::Init
	test	eax, eax
	jge	SHORT $LN1@CAtlComMod

; 2445 : 		{
; 2446 : 			ATLTRACE(atlTraceCOM, 0, _T("ERROR : Unable to initialize critical section in CAtlComModule\n"));

	push	OFFSET ??_C@_1IA@KEEOONGN@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?5?$AA?3?$AA?5?$AAU?$AAn?$AAa?$AAb?$AAl?$AAe?$AA?5?$AAt?$AAo?$AA?5?$AAi?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AAi?$AAz?$AAe?$AA?5?$AAc?$AAr?$AAi@
	push	0
	mov	ecx, OFFSET ?atlTraceCOM@ATL@@3V?$CTraceCategoryEx@$01$0A@@1@A ; ATL::atlTraceCOM
	call	??B?$CTraceCategoryEx@$01$0A@@ATL@@QAEIXZ ; ATL::CTraceCategoryEx<2,0>::operator unsigned int
	push	eax
	push	2446					; 0000098eH
	push	OFFSET ??_C@_0FA@ODGKGNGJ@c?3?2program?5files?5?$CIx86?$CJ?2microsoft@
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z ; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
	push	eax
	call	??RCTraceFileAndLineInfo@ATL@@QBAXHIPB_WZZ ; ATL::CTraceFileAndLineInfo::operator()
	add	esp, 16					; 00000010H

; 2447 : 			ATLASSERT(0);

	xor	eax, eax
	jne	SHORT $LN4@CAtlComMod
	push	OFFSET ??_C@_13COJANIEC@?$AA0?$AA?$AA@
	push	OFFSET ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
	push	0
	push	2447					; 0000098fH
	push	OFFSET ??_C@_1KA@ELJIHIAD@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	2
	call	__CrtDbgReportW
	add	esp, 24					; 00000018H
	cmp	eax, 1
	jne	SHORT $LN4@CAtlComMod
	int	3
$LN4@CAtlComMod:

; 2448 : 			CAtlBaseModule::m_bInitFailed = true;

	mov	BYTE PTR ?m_bInitFailed@CAtlBaseModule@ATL@@2_NA, 1 ; ATL::CAtlBaseModule::m_bInitFailed

; 2449 : 			return;

	jmp	SHORT $LN2@CAtlComMod
$LN1@CAtlComMod:

; 2450 : 		}
; 2451 : 		// Set cbSize on success.
; 2452 : 		cbSize = sizeof(_ATL_COM_MODULE);

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 40			; 00000028H
$LN2@CAtlComMod:

; 2453 : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0CAtlComModule@ATL@@QAE@XZ ENDP			; ATL::CAtlComModule::CAtlComModule
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlbase.h
;	COMDAT ?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_pWinModule$ = 8					; size = 4
_hInst$ = 12						; size = 4
?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z PROC ; ATL::AtlWinModuleTerm, COMDAT

; 7673 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 7674 : 	if (pWinModule == NULL)

	cmp	DWORD PTR _pWinModule$[ebp], 0
	jne	SHORT $LN6@AtlWinModu

; 7675 : 		return E_INVALIDARG;

	mov	eax, -2147024809			; 80070057H
	jmp	$LN7@AtlWinModu
$LN6@AtlWinModu:

; 7676 : 	if (pWinModule->cbSize == 0)

	mov	eax, DWORD PTR _pWinModule$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN5@AtlWinModu

; 7677 : 		return S_OK;

	xor	eax, eax
	jmp	SHORT $LN7@AtlWinModu
$LN5@AtlWinModu:

; 7678 : 	if (pWinModule->cbSize != sizeof(_ATL_WIN_MODULE))

	mov	eax, DWORD PTR _pWinModule$[ebp]
	cmp	DWORD PTR [eax], 44			; 0000002cH
	je	SHORT $LN4@AtlWinModu

; 7679 : 		return E_INVALIDARG;

	mov	eax, -2147024809			; 80070057H
	jmp	SHORT $LN7@AtlWinModu
$LN4@AtlWinModu:

; 7680 : 
; 7681 : 	for (int i = 0; i < pWinModule->m_rgWindowClassAtoms.GetSize(); i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN3@AtlWinModu
$LN2@AtlWinModu:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN3@AtlWinModu:
	mov	ecx, DWORD PTR _pWinModule$[ebp]
	add	ecx, 32					; 00000020H
	call	?GetSize@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QBEHXZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::GetSize
	cmp	DWORD PTR _i$1[ebp], eax
	jge	SHORT $LN1@AtlWinModu

; 7682 : 		UnregisterClass((LPCTSTR)pWinModule->m_rgWindowClassAtoms[i], hInst);

	mov	esi, esp
	mov	eax, DWORD PTR _hInst$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pWinModule$[ebp]
	add	ecx, 32					; 00000020H
	call	??A?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEAAGH@Z ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::operator[]
	movzx	edx, WORD PTR [eax]
	push	edx
	call	DWORD PTR __imp__UnregisterClassW@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	SHORT $LN2@AtlWinModu
$LN1@AtlWinModu:

; 7683 : 	pWinModule->m_rgWindowClassAtoms.RemoveAll();

	mov	ecx, DWORD PTR _pWinModule$[ebp]
	add	ecx, 32					; 00000020H
	call	?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll

; 7684 : 	pWinModule->m_csWindowCreate.Term();

	mov	ecx, DWORD PTR _pWinModule$[ebp]
	add	ecx, 4
	call	?Term@CComCriticalSection@ATL@@QAEJXZ	; ATL::CComCriticalSection::Term

; 7685 : 	pWinModule->cbSize = 0;

	mov	eax, DWORD PTR _pWinModule$[ebp]
	mov	DWORD PTR [eax], 0

; 7686 : 	return S_OK;

	xor	eax, eax
$LN7@AtlWinModu:

; 7687 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z ENDP ; ATL::AtlWinModuleTerm
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlbase.h
;	COMDAT ?AtlWinModuleInit@ATL@@YGJPAU_ATL_WIN_MODULE70@1@@Z
_TEXT	SEGMENT
$T1 = -216						; size = 8
_hr$ = -8						; size = 4
_pWinModule$ = 8					; size = 4
?AtlWinModuleInit@ATL@@YGJPAU_ATL_WIN_MODULE70@1@@Z PROC ; ATL::AtlWinModuleInit, COMDAT

; 8417 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 8418 : 	if (pWinModule == NULL)

	cmp	DWORD PTR _pWinModule$[ebp], 0
	jne	SHORT $LN3@AtlWinModu

; 8419 : 		return E_INVALIDARG;

	mov	eax, -2147024809			; 80070057H
	jmp	$LN4@AtlWinModu
$LN3@AtlWinModu:

; 8420 : 
; 8421 : 	// check only in the DLL
; 8422 : 	if (pWinModule->cbSize != sizeof(_ATL_WIN_MODULE))

	mov	eax, DWORD PTR _pWinModule$[ebp]
	cmp	DWORD PTR [eax], 44			; 0000002cH
	je	SHORT $LN2@AtlWinModu

; 8423 : 		return E_INVALIDARG;

	mov	eax, -2147024809			; 80070057H
	jmp	$LN4@AtlWinModu
$LN2@AtlWinModu:

; 8424 : 
; 8425 : 	pWinModule->m_pCreateWndList = NULL;

	mov	eax, DWORD PTR _pWinModule$[ebp]
	mov	DWORD PTR [eax+28], 0

; 8426 : 
; 8427 : 	HRESULT hr = pWinModule->m_csWindowCreate.Init();

	mov	ecx, DWORD PTR _pWinModule$[ebp]
	add	ecx, 4
	call	?Init@CComCriticalSection@ATL@@QAEJXZ	; ATL::CComCriticalSection::Init
	mov	DWORD PTR _hr$[ebp], eax

; 8428 : 	if (FAILED(hr))

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $LN1@AtlWinModu

; 8429 : 	{
; 8430 : 		ATLTRACE(atlTraceWindowing, 0, _T("ERROR : Unable to initialize critical section in AtlWinModuleInit\n"));

	push	OFFSET ??_C@_1IG@OPJAFKJH@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?5?$AA?3?$AA?5?$AAU?$AAn?$AAa?$AAb?$AAl?$AAe?$AA?5?$AAt?$AAo?$AA?5?$AAi?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AAi?$AAz?$AAe?$AA?5?$AAc?$AAr?$AAi@
	push	0
	mov	ecx, OFFSET ?atlTraceWindowing@ATL@@3V?$CTraceCategoryEx@$0CA@$0A@@1@A ; ATL::atlTraceWindowing
	call	??B?$CTraceCategoryEx@$0CA@$0A@@ATL@@QAEIXZ ; ATL::CTraceCategoryEx<32,0>::operator unsigned int
	push	eax
	mov	eax, DWORD PTR ?__LINE__Var@?1??AtlWinModuleInit@ATL@@YGJPAU_ATL_WIN_MODULE70@2@@Z@4JA
	add	eax, 13					; 0000000dH
	push	eax
	push	OFFSET ??_C@_0FA@ODGKGNGJ@c?3?2program?5files?5?$CIx86?$CJ?2microsoft@
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z ; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
	push	eax
	call	??RCTraceFileAndLineInfo@ATL@@QBAXHIPB_WZZ ; ATL::CTraceFileAndLineInfo::operator()
	add	esp, 16					; 00000010H

; 8431 : 		ATLASSERT(0);

	xor	eax, eax
	jne	SHORT $LN1@AtlWinModu
	push	OFFSET ??_C@_13COJANIEC@?$AA0?$AA?$AA@
	push	OFFSET ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
	push	0
	mov	ecx, DWORD PTR ?__LINE__Var@?1??AtlWinModuleInit@ATL@@YGJPAU_ATL_WIN_MODULE70@2@@Z@4JA
	add	ecx, 14					; 0000000eH
	push	ecx
	push	OFFSET ??_C@_1KA@ELJIHIAD@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	2
	call	__CrtDbgReportW
	add	esp, 24					; 00000018H
	cmp	eax, 1
	jne	SHORT $LN1@AtlWinModu
	int	3
$LN1@AtlWinModu:

; 8432 : 	}
; 8433 : 	return hr;

	mov	eax, DWORD PTR _hr$[ebp]
$LN4@AtlWinModu:

; 8434 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?AtlWinModuleInit@ATL@@YGJPAU_ATL_WIN_MODULE70@1@@Z ENDP ; ATL::AtlWinModuleInit
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1_ATL_WIN_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1_ATL_WIN_MODULE70@ATL@@QAE@XZ PROC			; ATL::_ATL_WIN_MODULE70::~_ATL_WIN_MODULE70, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1_ATL_WIN_MODULE70@ATL@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::~CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??1CComCriticalSection@ATL@@QAE@XZ	; ATL::CComCriticalSection::~CComCriticalSection
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1_ATL_WIN_MODULE70@ATL@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1CComCriticalSection@ATL@@QAE@XZ	; ATL::CComCriticalSection::~CComCriticalSection
__ehhandler$??1_ATL_WIN_MODULE70@ATL@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1_ATL_WIN_MODULE70@ATL@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1_ATL_WIN_MODULE70@ATL@@QAE@XZ ENDP			; ATL::_ATL_WIN_MODULE70::~_ATL_WIN_MODULE70
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0_ATL_WIN_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0_ATL_WIN_MODULE70@ATL@@QAE@XZ PROC			; ATL::_ATL_WIN_MODULE70::_ATL_WIN_MODULE70, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0_ATL_WIN_MODULE70@ATL@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??0CComCriticalSection@ATL@@QAE@XZ	; ATL::CComCriticalSection::CComCriticalSection
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0_ATL_WIN_MODULE70@ATL@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1CComCriticalSection@ATL@@QAE@XZ	; ATL::CComCriticalSection::~CComCriticalSection
__ehhandler$??0_ATL_WIN_MODULE70@ATL@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0_ATL_WIN_MODULE70@ATL@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0_ATL_WIN_MODULE70@ATL@@QAE@XZ ENDP			; ATL::_ATL_WIN_MODULE70::_ATL_WIN_MODULE70
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlsimpcoll.h
;	COMDAT ??A?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEAAGH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_nIndex$ = 8						; size = 4
??A?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEAAGH@Z PROC ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::operator[], COMDAT
; _this$ = ecx

; 230  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 231  : 		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);

	cmp	DWORD PTR _nIndex$[ebp], 0
	jl	SHORT $LN5@operator
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nIndex$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jl	SHORT $LN6@operator
$LN5@operator:
	push	OFFSET ??_C@_1EA@JHMKKLFC@?$AAn?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5?$AAm?$AA_?$AAn?$AAS?$AAi?$AAz?$AAe?$AA?$AA@
	push	OFFSET ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
	push	0
	push	231					; 000000e7H
	push	OFFSET ??_C@_1KI@KJKLFHG@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	2
	call	__CrtDbgReportW
	add	esp, 24					; 00000018H
	cmp	eax, 1
	jne	SHORT $LN6@operator
	int	3
$LN6@operator:

; 232  : 		if(nIndex < 0 || nIndex >= m_nSize)

	cmp	DWORD PTR _nIndex$[ebp], 0
	jl	SHORT $LN1@operator
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nIndex$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jl	SHORT $LN2@operator
$LN1@operator:

; 233  : 		{
; 234  : 			_AtlRaiseException((DWORD)EXCEPTION_ARRAY_BOUNDS_EXCEEDED);

	push	1
	push	-1073741684				; c000008cH
	call	?_AtlRaiseException@ATL@@YAXKK@Z	; ATL::_AtlRaiseException
$LN2@operator:

; 235  : 		}
; 236  : 		return m_aT[nIndex];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _nIndex$[ebp]
	lea	eax, DWORD PTR [ecx+edx*2]
$LN4@operator:

; 237  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEAAGH@Z ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlsimpcoll.h
;	COMDAT ?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ
_TEXT	SEGMENT
_i$1 = -20						; size = 4
_this$ = -8						; size = 4
?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ PROC ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll, COMDAT
; _this$ = ecx

; 209  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 210  : 		if(m_aT != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN4@RemoveAll

; 211  : 		{
; 212  : 			for(int i = 0; i < m_nSize; i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN3@RemoveAll
$LN2@RemoveAll:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN3@RemoveAll:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$1[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jge	SHORT $LN1@RemoveAll

; 213  : 				m_aT[i].~T();

	jmp	SHORT $LN2@RemoveAll
$LN1@RemoveAll:

; 214  : 			free(m_aT);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_free
	add	esp, 4

; 215  : 			m_aT = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
$LN4@RemoveAll:

; 216  : 		}
; 217  : 		m_nSize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 218  : 		m_nAllocSize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 219  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlsimpcoll.h
;	COMDAT ?GetSize@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QBEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetSize@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QBEHXZ PROC ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::GetSize, COMDAT
; _this$ = ecx

; 160  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 161  : 		return m_nSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 162  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSize@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QBEHXZ ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::GetSize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlsimpcoll.h
;	COMDAT ??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ PROC ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::~CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >, COMDAT
; _this$ = ecx

; 303  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 304  : 	RemoveAll();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll

; 305  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::~CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlsimpcoll.h
;	COMDAT ??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ PROC ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >, COMDAT
; _this$ = ecx

; 120  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 121  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1_ATL_COM_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1_ATL_COM_MODULE70@ATL@@QAE@XZ PROC			; ATL::_ATL_COM_MODULE70::~_ATL_COM_MODULE70, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??1CComCriticalSection@ATL@@QAE@XZ	; ATL::CComCriticalSection::~CComCriticalSection
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1_ATL_COM_MODULE70@ATL@@QAE@XZ ENDP			; ATL::_ATL_COM_MODULE70::~_ATL_COM_MODULE70
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0_ATL_COM_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0_ATL_COM_MODULE70@ATL@@QAE@XZ PROC			; ATL::_ATL_COM_MODULE70::_ATL_COM_MODULE70, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??0CComCriticalSection@ATL@@QAE@XZ	; ATL::CComCriticalSection::CComCriticalSection
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0_ATL_COM_MODULE70@ATL@@QAE@XZ ENDP			; ATL::_ATL_COM_MODULE70::_ATL_COM_MODULE70
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlcore.h
;	COMDAT ?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ PROC ; ATL::CAtlBaseModule::GetModuleInstance, COMDAT
; _this$ = ecx

; 274  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 275  : 		return m_hInst;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 276  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ ENDP ; ATL::CAtlBaseModule::GetModuleInstance
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlcore.h
;	COMDAT ?Term@CComCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Term@CComCriticalSection@ATL@@QAEJXZ PROC		; ATL::CComCriticalSection::Term, COMDAT
; _this$ = ecx

; 139  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		DeleteCriticalSection(&m_sec);

	mov	eax, DWORD PTR _this$[ebp]
	mov	esi, esp
	push	eax
	call	DWORD PTR __imp__DeleteCriticalSection@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 141  : 		return S_OK;

	xor	eax, eax

; 142  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Term@CComCriticalSection@ATL@@QAEJXZ ENDP		; ATL::CComCriticalSection::Term
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlcore.h
;	COMDAT ?Init@CComCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT
_hRes$ = -20						; size = 4
_this$ = -8						; size = 4
?Init@CComCriticalSection@ATL@@QAEJXZ PROC		; ATL::CComCriticalSection::Init, COMDAT
; _this$ = ecx

; 128  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		HRESULT hRes = S_OK;

	mov	DWORD PTR _hRes$[ebp], 0

; 130  : 		if (!_AtlInitializeCriticalSectionEx(&m_sec, 0, 0))

	push	0
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?_AtlInitializeCriticalSectionEx@ATL@@YAHPAU_RTL_CRITICAL_SECTION@@KK@Z ; ATL::_AtlInitializeCriticalSectionEx
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN1@Init

; 131  : 		{
; 132  : 			hRes = HRESULT_FROM_WIN32(GetLastError());

	mov	esi, esp
	call	DWORD PTR __imp__GetLastError@0
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_HRESULT_FROM_WIN32
	add	esp, 4
	mov	DWORD PTR _hRes$[ebp], eax
$LN1@Init:

; 133  : 		}
; 134  : 
; 135  : 		return hRes;

	mov	eax, DWORD PTR _hRes$[ebp]

; 136  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Init@CComCriticalSection@ATL@@QAEJXZ ENDP		; ATL::CComCriticalSection::Init
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlcore.h
;	COMDAT ??1CComCriticalSection@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1CComCriticalSection@ATL@@QAE@XZ PROC			; ATL::CComCriticalSection::~CComCriticalSection, COMDAT
; _this$ = ecx

; 114  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 115  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1CComCriticalSection@ATL@@QAE@XZ ENDP			; ATL::CComCriticalSection::~CComCriticalSection
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlcore.h
;	COMDAT ??0CComCriticalSection@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0CComCriticalSection@ATL@@QAE@XZ PROC			; ATL::CComCriticalSection::CComCriticalSection, COMDAT
; _this$ = ecx

; 108  : 	CComCriticalSection() throw()

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 109  : 	{
; 110  : 		memset(&m_sec, 0, sizeof(CRITICAL_SECTION));

	push	24					; 00000018H
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 111  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0CComCriticalSection@ATL@@QAE@XZ ENDP			; ATL::CComCriticalSection::CComCriticalSection
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlwinverapi.h
;	COMDAT ?_AtlInitializeCriticalSectionEx@ATL@@YAHPAU_RTL_CRITICAL_SECTION@@KK@Z
_TEXT	SEGMENT
_lpCriticalSection$ = 8					; size = 4
_dwSpinCount$ = 12					; size = 4
_Flags$ = 16						; size = 4
?_AtlInitializeCriticalSectionEx@ATL@@YAHPAU_RTL_CRITICAL_SECTION@@KK@Z PROC ; ATL::_AtlInitializeCriticalSectionEx, COMDAT

; 69   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 70   : 	#if (NTDDI_VERSION >= NTDDI_VISTA) && !defined(_USING_V110_SDK71_) && !defined(_ATL_XP_TARGETING)
; 71   : 		// InitializeCriticalSectionEx is available in Vista or later, desktop or store apps
; 72   : 		return ::InitializeCriticalSectionEx(lpCriticalSection, dwSpinCount, Flags);

	mov	esi, esp
	mov	eax, DWORD PTR _Flags$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dwSpinCount$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCriticalSection$[ebp]
	push	edx
	call	DWORD PTR __imp__InitializeCriticalSectionEx@12
	cmp	esi, esp
	call	__RTC_CheckEsp

; 73   : 	#else
; 74   : 		UNREFERENCED_PARAMETER(Flags);
; 75   : 
; 76   : 		// ...otherwise fall back to using InitializeCriticalSectionAndSpinCount.
; 77   : 		return ::InitializeCriticalSectionAndSpinCount(lpCriticalSection, dwSpinCount);
; 78   : 	#endif
; 79   : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_AtlInitializeCriticalSectionEx@ATL@@YAHPAU_RTL_CRITICAL_SECTION@@KK@Z ENDP ; ATL::_AtlInitializeCriticalSectionEx
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlexcept.h
;	COMDAT ?AtlThrowLastWin32@ATL@@YGXXZ
_TEXT	SEGMENT
_dwError$ = -8						; size = 4
?AtlThrowLastWin32@ATL@@YGXXZ PROC			; ATL::AtlThrowLastWin32, COMDAT

; 84   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 85   : 	DWORD dwError = ::GetLastError();

	mov	esi, esp
	call	DWORD PTR __imp__GetLastError@0
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _dwError$[ebp], eax

; 86   : 	AtlThrow( HRESULT_FROM_WIN32( dwError ) );

	mov	eax, DWORD PTR _dwError$[ebp]
	push	eax
	call	_HRESULT_FROM_WIN32
	add	esp, 4
	push	eax
	call	?AtlThrowImpl@ATL@@YGXJ@Z		; ATL::AtlThrowImpl
$LN2@AtlThrowLa:

; 87   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?AtlThrowLastWin32@ATL@@YGXXZ ENDP			; ATL::AtlThrowLastWin32
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlexcept.h
;	COMDAT ?AtlThrowImpl@ATL@@YGXJ@Z
_TEXT	SEGMENT
$T1 = -228						; size = 8
$T2 = -212						; size = 4
$T3 = -200						; size = 4
_hr$ = 8						; size = 4
?AtlThrowImpl@ATL@@YGXJ@Z PROC				; ATL::AtlThrowImpl, COMDAT

; 65   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 66   : 	ATLTRACE(atlTraceException, 0, _T("AtlThrow: hr = 0x%x\n"), hr );

	mov	eax, DWORD PTR _hr$[ebp]
	push	eax
	push	OFFSET ??_C@_1CK@DFMKPFAK@?$AAA?$AAt?$AAl?$AAT?$AAh?$AAr?$AAo?$AAw?$AA?3?$AA?5?$AAh?$AAr?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?6?$AA?$AA@
	push	0
	mov	ecx, OFFSET ?atlTraceException@ATL@@3V?$CTraceCategoryEx@$0CAAA@$0A@@1@A ; ATL::atlTraceException
	call	??B?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAEIXZ ; ATL::CTraceCategoryEx<8192,0>::operator unsigned int
	push	eax
	mov	ecx, DWORD PTR ?__LINE__Var@?1??AtlThrowImpl@ATL@@YGXJ@Z@4JA
	add	ecx, 1
	push	ecx
	push	OFFSET ??_C@_0FC@OFGMOGKO@c?3?2program?5files?5?$CIx86?$CJ?2microsoft@
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z ; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
	push	eax
	call	??RCTraceFileAndLineInfo@ATL@@QBAXHIPB_WZZ ; ATL::CTraceFileAndLineInfo::operator()
	add	esp, 20					; 00000014H

; 67   : #ifdef _AFX
; 68   : 	if( hr == E_OUTOFMEMORY )
; 69   : 	{
; 70   : 		AfxThrowMemoryException();
; 71   : 	}
; 72   : 	else
; 73   : 	{
; 74   : 		AfxThrowOleException( hr );
; 75   : 	}
; 76   : #else
; 77   : 	throw CAtlException( hr );

	mov	eax, DWORD PTR _hr$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	call	??0CAtlException@ATL@@QAE@J@Z		; ATL::CAtlException::CAtlException
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T2[ebp], ecx
	push	OFFSET __TI1?AVCAtlException@ATL@@
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	call	__CxxThrowException@8
$LN2@AtlThrowIm:

; 78   : #endif
; 79   : };

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?AtlThrowImpl@ATL@@YGXJ@Z ENDP				; ATL::AtlThrowImpl
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlexcept.h
;	COMDAT ??0CAtlException@ATL@@QAE@J@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_hr$ = 8						; size = 4
??0CAtlException@ATL@@QAE@J@Z PROC			; ATL::CAtlException::CAtlException, COMDAT
; _this$ = ecx

; 44   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _hr$[ebp]
	mov	DWORD PTR [eax], ecx

; 45   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0CAtlException@ATL@@QAE@J@Z ENDP			; ATL::CAtlException::CAtlException
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlexcept.h
;	COMDAT ?_AtlRaiseException@ATL@@YAXKK@Z
_TEXT	SEGMENT
_dwExceptionCode$ = 8					; size = 4
_dwExceptionFlags$ = 12					; size = 4
?_AtlRaiseException@ATL@@YAXKK@Z PROC			; ATL::_AtlRaiseException, COMDAT

; 30   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 31   : 	RaiseException( dwExceptionCode, dwExceptionFlags, 0, NULL );

	mov	esi, esp
	push	0
	push	0
	mov	eax, DWORD PTR _dwExceptionFlags$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dwExceptionCode$[ebp]
	push	ecx
	call	DWORD PTR __imp__RaiseException@16
	cmp	esi, esp
	call	__RTC_CheckEsp

; 32   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_AtlRaiseException@ATL@@YAXKK@Z ENDP			; ATL::_AtlRaiseException
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??RCTraceFileAndLineInfo@ATL@@QBAXHIPB_WZZ
_TEXT	SEGMENT
_ptr$ = -8						; size = 4
_this$ = 8						; size = 4
_dwCategory$ = 12					; size = 4
_nLevel$ = 16						; size = 4
_pszFmt$ = 20						; size = 4
??RCTraceFileAndLineInfo@ATL@@QBAXHIPB_WZZ PROC		; ATL::CTraceFileAndLineInfo::operator(), COMDAT

; 385  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 386  : 		va_list ptr; va_start(ptr, pszFmt);

	lea	eax, DWORD PTR _pszFmt$[ebp+4]
	mov	DWORD PTR _ptr$[ebp], eax

; 387  : 		ATL::CTrace::TraceV(m_pszFileName, m_nLineNo, dwCategory, nLevel, pszFmt, ptr);

	mov	eax, DWORD PTR _ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pszFmt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _nLevel$[ebp]
	push	edx
	mov	eax, DWORD PTR _dwCategory$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?TraceV@CTrace@ATL@@SAXPBDHIIPB_WPAD@Z	; ATL::CTrace::TraceV
	add	esp, 24					; 00000018H

; 388  : 		va_end(ptr);

	mov	DWORD PTR _ptr$[ebp], 0

; 389  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??RCTraceFileAndLineInfo@ATL@@QBAXHIPB_WZZ ENDP		; ATL::CTraceFileAndLineInfo::operator()
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pszFileName$ = 8					; size = 4
_nLineNo$ = 12						; size = 4
??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z PROC		; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo, COMDAT
; _this$ = ecx

; 361  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pszFileName$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nLineNo$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 362  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z ENDP		; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ PROC	; ATL::CHeapPtr<wchar_t,ATL::CCRTAllocator>::~CHeapPtr<wchar_t,ATL::CCRTAllocator>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::~CHeapPtrBase<wchar_t,ATL::CCRTAllocator>
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ ENDP	; ATL::CHeapPtr<wchar_t,ATL::CCRTAllocator>::~CHeapPtr<wchar_t,ATL::CCRTAllocator>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ?Allocate@?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE_NI@Z
_TEXT	SEGMENT
_nBytes$ = -20						; size = 4
_this$ = -8						; size = 4
_nElements$ = 8						; size = 4
?Allocate@?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE_NI@Z PROC ; ATL::CHeapPtr<wchar_t,ATL::CCRTAllocator>::Allocate, COMDAT
; _this$ = ecx

; 470  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 471  : 		size_t nBytes=0;

	mov	DWORD PTR _nBytes$[ebp], 0

; 472  : 		if(FAILED(::ATL::AtlMultiply(&nBytes, nElements, sizeof(T))))

	push	2
	mov	eax, DWORD PTR _nElements$[ebp]
	push	eax
	lea	ecx, DWORD PTR _nBytes$[ebp]
	push	ecx
	call	??$AtlMultiply@I@ATL@@YAJPAIII@Z	; ATL::AtlMultiply<unsigned int>
	add	esp, 12					; 0000000cH
	test	eax, eax
	jge	SHORT $LN1@Allocate

; 473  : 		{
; 474  : 			return false;

	xor	al, al
	jmp	SHORT $LN2@Allocate
$LN1@Allocate:

; 475  : 		}
; 476  : 		return AllocateBytes(nBytes);

	mov	eax, DWORD PTR _nBytes$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AllocateBytes@?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QAE_NI@Z ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::AllocateBytes
$LN2@Allocate:

; 477  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@Allocate
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	1
$LN6@Allocate:
	DD	1
	DD	$LN5@Allocate
$LN5@Allocate:
	DD	-20					; ffffffecH
	DD	4
	DD	$LN4@Allocate
$LN4@Allocate:
	DB	110					; 0000006eH
	DB	66					; 00000042H
	DB	121					; 00000079H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	0
?Allocate@?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE_NI@Z ENDP ; ATL::CHeapPtr<wchar_t,ATL::CCRTAllocator>::Allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ??0?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ PROC	; ATL::CHeapPtr<wchar_t,ATL::CCRTAllocator>::CHeapPtr<wchar_t,ATL::CCRTAllocator>, COMDAT
; _this$ = ecx

; 449  : 	CHeapPtr() throw()

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@IAE@XZ ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>

; 450  : 	{
; 451  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ ENDP	; ATL::CHeapPtr<wchar_t,ATL::CCRTAllocator>::CHeapPtr<wchar_t,ATL::CCRTAllocator>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ?Free@?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Free@?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QAEXXZ PROC ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::Free, COMDAT
; _this$ = ecx

; 422  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 423  : 		Allocator::Free(m_pData);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?Free@CCRTAllocator@ATL@@SAXPAX@Z	; ATL::CCRTAllocator::Free
	add	esp, 4

; 424  : 		m_pData = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 425  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Free@?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QAEXXZ ENDP ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::Free
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ?AllocateBytes@?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QAE_NI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_nBytes$ = 8						; size = 4
?AllocateBytes@?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QAE_NI@Z PROC ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::AllocateBytes, COMDAT
; _this$ = ecx

; 396  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 397  : 		ATLASSERT(m_pData == NULL);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN4@AllocateBy
	push	OFFSET ??_C@_1BK@NHECDDNK@?$AAm?$AA_?$AAp?$AAD?$AAa?$AAt?$AAa?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@
	push	OFFSET ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
	push	0
	push	397					; 0000018dH
	push	OFFSET ??_C@_1KC@BHGECGBJ@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	2
	call	__CrtDbgReportW
	add	esp, 24					; 00000018H
	cmp	eax, 1
	jne	SHORT $LN4@AllocateBy
	int	3
$LN4@AllocateBy:

; 398  : 		m_pData = static_cast<T*>(Allocator::Allocate(nBytes));

	mov	eax, DWORD PTR _nBytes$[ebp]
	push	eax
	call	?Allocate@CCRTAllocator@ATL@@SAPAXI@Z	; ATL::CCRTAllocator::Allocate
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 399  : 		if (m_pData == NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN1@AllocateBy

; 400  : 			return false;

	xor	al, al
	jmp	SHORT $LN2@AllocateBy
$LN1@AllocateBy:

; 401  : 
; 402  : 		return true;

	mov	al, 1
$LN2@AllocateBy:

; 403  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?AllocateBytes@?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QAE_NI@Z ENDP ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::AllocateBytes
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ??B?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QBEPA_WXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??B?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QBEPA_WXZ PROC ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::operator wchar_t *, COMDAT
; _this$ = ecx

; 378  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 379  : 		return m_pData;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 380  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??B?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QBEPA_WXZ ENDP ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::operator wchar_t *
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ??1?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ PROC ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::~CHeapPtrBase<wchar_t,ATL::CCRTAllocator>, COMDAT
; _this$ = ecx

; 364  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 365  : 		Free();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Free@?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QAEXXZ ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::Free

; 366  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::~CHeapPtrBase<wchar_t,ATL::CCRTAllocator>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ??0?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@IAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@IAE@XZ PROC ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>, COMDAT
; _this$ = ecx

; 351  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 352  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@IAE@XZ ENDP ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ?RegisterCategory@CTrace@ATL@@SAXPB_WI@Z
_TEXT	SEGMENT
_pszCategory$ = 8					; size = 4
_nCategory$ = 12					; size = 4
?RegisterCategory@CTrace@ATL@@SAXPB_WI@Z PROC		; ATL::CTrace::RegisterCategory, COMDAT

; 300  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 301  : 		if (pszCategory == nullptr)

	cmp	DWORD PTR _pszCategory$[ebp], 0
	jne	SHORT $LN2@RegisterCa

; 302  : 		{
; 303  : 			return;

	jmp	SHORT $LN3@RegisterCa
$LN2@RegisterCa:

; 304  : 		}
; 305  : 
; 306  : 		if (m_nLastCategory >= MaxCategoryArray) 

	cmp	DWORD PTR ?m_nLastCategory@CTrace@ATL@@1IA, 32 ; ATL::CTrace::m_nLastCategory, 00000020H
	jb	SHORT $LN1@RegisterCa

; 307  : 		{
; 308  : 			ATLASSERT(false && "Too many categories defined");

	xor	eax, eax
	jne	SHORT $LN5@RegisterCa
	push	OFFSET ??_C@_1EO@EBPPKGOM@?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAT?$AAo?$AAo?$AA?5?$AAm?$AAa?$AAn?$AAy?$AA?5?$AAc?$AAa?$AAt?$AAe?$AAg?$AAo?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAd?$AAe@
	push	OFFSET ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
	push	0
	push	308					; 00000134H
	push	OFFSET ??_C@_1KC@GEMPEEJK@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	2
	call	__CrtDbgReportW
	add	esp, 24					; 00000018H
	cmp	eax, 1
	jne	SHORT $LN5@RegisterCa
	int	3
$LN5@RegisterCa:

; 309  : 			return;

	jmp	SHORT $LN3@RegisterCa
$LN1@RegisterCa:

; 310  : 		}
; 311  : 
; 312  : 		m_nMap[m_nLastCategory].nCategory = nCategory;

	imul	eax, DWORD PTR ?m_nLastCategory@CTrace@ATL@@1IA, 260 ; ATL::CTrace::m_nLastCategory
	mov	ecx, DWORD PTR _nCategory$[ebp]
	mov	DWORD PTR ?m_nMap@CTrace@ATL@@1PAUCategoryMap@12@A[eax], ecx

; 313  : #ifdef _UNICODE
; 314  : 		wcscpy_s(m_nMap[m_nLastCategory].categryName, MaxLengthOfCategoryName - 1, pszCategory);

	mov	eax, DWORD PTR _pszCategory$[ebp]
	push	eax
	push	127					; 0000007fH
	imul	ecx, DWORD PTR ?m_nLastCategory@CTrace@ATL@@1IA, 260 ; ATL::CTrace::m_nLastCategory
	add	ecx, OFFSET ?m_nMap@CTrace@ATL@@1PAUCategoryMap@12@A+4
	push	ecx
	call	_wcscpy_s
	add	esp, 12					; 0000000cH

; 315  : #else
; 316  : 		wchar_t buffer[MaxLengthOfCategoryName] = { 0 };	
; 317  : 		swprintf_s(buffer, MaxLengthOfCategoryName - 1, L"%S", pszCategory);
; 318  : 		wcscpy_s(m_nMap[m_nLastCategory].categryName, MaxLengthOfCategoryName - 1, buffer);
; 319  : #endif
; 320  : 	
; 321  : 		m_nLastCategory++;

	mov	eax, DWORD PTR ?m_nLastCategory@CTrace@ATL@@1IA ; ATL::CTrace::m_nLastCategory
	add	eax, 1
	mov	DWORD PTR ?m_nLastCategory@CTrace@ATL@@1IA, eax ; ATL::CTrace::m_nLastCategory
$LN3@RegisterCa:

; 322  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?RegisterCategory@CTrace@ATL@@SAXPB_WI@Z ENDP		; ATL::CTrace::RegisterCategory
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ?TraceV@CTrace@ATL@@SAXPBDHIIPB_WPAD@Z
_TEXT	SEGMENT
_wszBuf$ = -32						; size = 4
_cchNeeded$ = -20					; size = 4
__$EHRec$ = -12						; size = 12
_pszFileName$ = 8					; size = 4
_nLine$ = 12						; size = 4
_dwCategory$ = 16					; size = 4
_nLevel$ = 20						; size = 4
_pwszFmt$ = 24						; size = 4
_args$ = 28						; size = 4
?TraceV@CTrace@ATL@@SAXPBDHIIPB_WPAD@Z PROC		; ATL::CTrace::TraceV, COMDAT

; 276  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?TraceV@CTrace@ATL@@SAXPBDHIIPB_WPAD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 277  : 		int cchNeeded = _vscwprintf(pwszFmt, args);

	mov	eax, DWORD PTR _args$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pwszFmt$[ebp]
	push	ecx
	call	__vscwprintf
	add	esp, 8
	mov	DWORD PTR _cchNeeded$[ebp], eax

; 278  : 		if (cchNeeded < 0)

	cmp	DWORD PTR _cchNeeded$[ebp], 0
	jge	SHORT $LN3@TraceV

; 279  : 		{
; 280  : 			return;

	jmp	$LN4@TraceV
$LN3@TraceV:

; 281  : 		}
; 282  : 
; 283  : 		CHeapPtr<wchar_t> wszBuf;

	lea	ecx, DWORD PTR _wszBuf$[ebp]
	call	??0?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CHeapPtr<wchar_t,ATL::CCRTAllocator>::CHeapPtr<wchar_t,ATL::CCRTAllocator>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 284  : 		if (!wszBuf.Allocate(cchNeeded + 1))

	mov	eax, DWORD PTR _cchNeeded$[ebp]
	add	eax, 1
	push	eax
	lea	ecx, DWORD PTR _wszBuf$[ebp]
	call	?Allocate@?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE_NI@Z ; ATL::CHeapPtr<wchar_t,ATL::CCRTAllocator>::Allocate
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN2@TraceV

; 285  : 		{
; 286  : 			return;

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _wszBuf$[ebp]
	call	??1?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ
	jmp	$LN4@TraceV
$LN2@TraceV:

; 287  : 		}
; 288  : 
; 289  : 		wszBuf[0] = '\0';

	lea	ecx, DWORD PTR _wszBuf$[ebp]
	call	??B?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QBEPA_WXZ ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::operator wchar_t *
	mov	ecx, 2
	imul	edx, ecx, 0
	xor	ecx, ecx
	mov	WORD PTR [eax+edx], cx

; 290  : 
; 291  : 		if (_vsnwprintf_s(wszBuf, cchNeeded + 1, cchNeeded, pwszFmt, args) == -1)

	mov	eax, DWORD PTR _args$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pwszFmt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cchNeeded$[ebp]
	push	edx
	mov	eax, DWORD PTR _cchNeeded$[ebp]
	add	eax, 1
	push	eax
	lea	ecx, DWORD PTR _wszBuf$[ebp]
	call	??B?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QBEPA_WXZ ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::operator wchar_t *
	push	eax
	call	__vsnwprintf_s
	add	esp, 20					; 00000014H
	cmp	eax, -1
	jne	SHORT $LN1@TraceV

; 292  : 		{
; 293  : 			return;

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _wszBuf$[ebp]
	call	??1?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ
	jmp	SHORT $LN4@TraceV
$LN1@TraceV:

; 294  : 		}
; 295  : 
; 296  : 		TraceV(pszFileName, nLine, dwCategory, nLevel, wszBuf);

	lea	ecx, DWORD PTR _wszBuf$[ebp]
	call	??B?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QBEPA_WXZ ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::operator wchar_t *
	push	eax
	mov	eax, DWORD PTR _nLevel$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dwCategory$[ebp]
	push	ecx
	mov	edx, DWORD PTR _nLine$[ebp]
	push	edx
	mov	eax, DWORD PTR _pszFileName$[ebp]
	push	eax
	call	?TraceV@CTrace@ATL@@CAXPBDHIIPB_W@Z	; ATL::CTrace::TraceV
	add	esp, 20					; 00000014H

; 297  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _wszBuf$[ebp]
	call	??1?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ
$LN4@TraceV:
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN10@TraceV
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@TraceV:
	DD	1
	DD	$LN9@TraceV
$LN9@TraceV:
	DD	-32					; ffffffe0H
	DD	4
	DD	$LN7@TraceV
$LN7@TraceV:
	DB	119					; 00000077H
	DB	115					; 00000073H
	DB	122					; 0000007aH
	DB	66					; 00000042H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?TraceV@CTrace@ATL@@SAXPBDHIIPB_WPAD@Z$0:
	lea	ecx, DWORD PTR _wszBuf$[ebp]
	jmp	??1?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ
__ehhandler$?TraceV@CTrace@ATL@@SAXPBDHIIPB_WPAD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-232]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?TraceV@CTrace@ATL@@SAXPBDHIIPB_WPAD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?TraceV@CTrace@ATL@@SAXPBDHIIPB_WPAD@Z ENDP		; ATL::CTrace::TraceV
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ?TraceV@CTrace@ATL@@CAXPBDHIIPB_W@Z
_TEXT	SEGMENT
_fileName$ = -2632					; size = 520
_wszBuf$ = -2104					; size = 4
_chCount$ = -2092					; size = 4
_pwszCategoryName$ = -2080				; size = 4
_categoryLength$ = -2068				; size = 4
_wszCategory$ = -2056					; size = 2048
__$ArrayPad$ = -4					; size = 4
_pszFileName$ = 8					; size = 4
_nLine$ = 12						; size = 4
_dwCategory$ = 16					; size = 4
_nLevel$ = 20						; size = 4
_pwszMessage$ = 24					; size = 4
?TraceV@CTrace@ATL@@CAXPBDHIIPB_W@Z PROC		; ATL::CTrace::TraceV, COMDAT

; 149  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 2828				; 00000b0cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-2828]
	mov	ecx, 707				; 000002c3H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 150  : 		if (CTrace::m_nLevel == CTrace::DisableTracing || CTrace::m_nLevel < nLevel || (CTrace::m_nCategory & dwCategory) == 0)

	cmp	DWORD PTR ?m_nLevel@CTrace@ATL@@1IA, -1	; ATL::CTrace::m_nLevel
	je	SHORT $LN8@TraceV
	mov	eax, DWORD PTR ?m_nLevel@CTrace@ATL@@1IA ; ATL::CTrace::m_nLevel
	cmp	eax, DWORD PTR _nLevel$[ebp]
	jb	SHORT $LN8@TraceV
	mov	eax, DWORD PTR ?m_nCategory@CTrace@ATL@@1IA ; ATL::CTrace::m_nCategory
	and	eax, DWORD PTR _dwCategory$[ebp]
	jne	SHORT $LN9@TraceV
$LN8@TraceV:

; 151  : 		{
; 152  : 			return;

	jmp	$LN10@TraceV
$LN9@TraceV:

; 153  : 		}
; 154  : 
; 155  : 		wchar_t wszCategory[TraceBufferSize] = {'\0'};

	xor	eax, eax
	mov	WORD PTR _wszCategory$[ebp], ax
	push	2046					; 000007feH
	push	0
	lea	eax, DWORD PTR _wszCategory$[ebp+2]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 156  : 		int categoryLength = 0;

	mov	DWORD PTR _categoryLength$[ebp], 0

; 157  : 		const wchar_t *const pwszCategoryName = GetCategoryName(dwCategory);

	mov	eax, DWORD PTR _dwCategory$[ebp]
	push	eax
	call	?GetCategoryName@CTrace@ATL@@CAPA_WI@Z	; ATL::CTrace::GetCategoryName
	add	esp, 4
	mov	DWORD PTR _pwszCategoryName$[ebp], eax

; 158  : 		if (pwszCategoryName != nullptr)

	cmp	DWORD PTR _pwszCategoryName$[ebp], 0
	je	SHORT $LN7@TraceV

; 159  : 		{
; 160  : 			if ((categoryLength = swprintf_s(wszCategory, TraceBufferSize, L"%s - ", pwszCategoryName)) == -1)

	mov	eax, DWORD PTR _pwszCategoryName$[ebp]
	push	eax
	push	OFFSET ??_C@_1M@PLLAHAGD@?$AA?$CF?$AAs?$AA?5?$AA?9?$AA?5?$AA?$AA@
	push	1024					; 00000400H
	lea	ecx, DWORD PTR _wszCategory$[ebp]
	push	ecx
	call	_swprintf_s
	add	esp, 16					; 00000010H
	mov	DWORD PTR _categoryLength$[ebp], eax
	cmp	DWORD PTR _categoryLength$[ebp], -1
	jne	SHORT $LN6@TraceV

; 161  : 			{
; 162  : 				return;

	jmp	$LN10@TraceV
$LN6@TraceV:

; 163  : 			}
; 164  : 		}
; 165  : 		else

	jmp	SHORT $LN5@TraceV
$LN7@TraceV:

; 166  : 		{
; 167  : 			if ((categoryLength = swprintf_s(wszCategory, TraceBufferSize, L"%u - ", dwCategory)) == -1)

	mov	eax, DWORD PTR _dwCategory$[ebp]
	push	eax
	push	OFFSET ??_C@_1M@PGKOAACE@?$AA?$CF?$AAu?$AA?5?$AA?9?$AA?5?$AA?$AA@
	push	1024					; 00000400H
	lea	ecx, DWORD PTR _wszCategory$[ebp]
	push	ecx
	call	_swprintf_s
	add	esp, 16					; 00000010H
	mov	DWORD PTR _categoryLength$[ebp], eax
	cmp	DWORD PTR _categoryLength$[ebp], -1
	jne	SHORT $LN5@TraceV

; 168  : 			{
; 169  : 				return;

	jmp	$LN10@TraceV
$LN5@TraceV:

; 170  : 			}
; 171  : 		}
; 172  : 
; 173  : 		int chCount = (int)wcslen(pwszMessage) + categoryLength + 1;

	mov	eax, DWORD PTR _pwszMessage$[ebp]
	push	eax
	call	_wcslen
	add	esp, 4
	mov	ecx, DWORD PTR _categoryLength$[ebp]
	lea	edx, DWORD PTR [eax+ecx+1]
	mov	DWORD PTR _chCount$[ebp], edx

; 174  : 		CHeapPtr<wchar_t> wszBuf;

	lea	ecx, DWORD PTR _wszBuf$[ebp]
	call	??0?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CHeapPtr<wchar_t,ATL::CCRTAllocator>::CHeapPtr<wchar_t,ATL::CCRTAllocator>

; 175  : 		if (!wszBuf.Allocate(chCount))

	mov	eax, DWORD PTR _chCount$[ebp]
	push	eax
	lea	ecx, DWORD PTR _wszBuf$[ebp]
	call	?Allocate@?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE_NI@Z ; ATL::CHeapPtr<wchar_t,ATL::CCRTAllocator>::Allocate
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@TraceV

; 176  : 		{
; 177  : 			return;

	lea	ecx, DWORD PTR _wszBuf$[ebp]
	call	??1?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ
	jmp	$LN10@TraceV
$LN3@TraceV:

; 178  : 		}
; 179  : 
; 180  : 		wszBuf[0] = '\0';

	lea	ecx, DWORD PTR _wszBuf$[ebp]
	call	??B?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QBEPA_WXZ ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::operator wchar_t *
	mov	ecx, 2
	imul	edx, ecx, 0
	xor	ecx, ecx
	mov	WORD PTR [eax+edx], cx

; 181  : 
; 182  : 		if (swprintf_s(wszBuf, chCount, L"%s%s", wszCategory, pwszMessage) == -1)

	mov	eax, DWORD PTR _pwszMessage$[ebp]
	push	eax
	lea	ecx, DWORD PTR _wszCategory$[ebp]
	push	ecx
	push	OFFSET ??_C@_19LJDFFCJJ@?$AA?$CF?$AAs?$AA?$CF?$AAs?$AA?$AA@
	mov	edx, DWORD PTR _chCount$[ebp]
	push	edx
	lea	ecx, DWORD PTR _wszBuf$[ebp]
	call	??B?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QBEPA_WXZ ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::operator wchar_t *
	push	eax
	call	_swprintf_s
	add	esp, 20					; 00000014H
	cmp	eax, -1
	jne	SHORT $LN2@TraceV

; 183  : 		{
; 184  : 			return;

	lea	ecx, DWORD PTR _wszBuf$[ebp]
	call	??1?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ
	jmp	SHORT $LN10@TraceV
$LN2@TraceV:

; 185  : 		}
; 186  : 
; 187  : 		wchar_t fileName[_MAX_PATH] = {'\0'};	

	xor	eax, eax
	mov	WORD PTR _fileName$[ebp], ax
	push	518					; 00000206H
	push	0
	lea	eax, DWORD PTR _fileName$[ebp+2]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 188  : 		if (swprintf_s(fileName, _MAX_PATH, L"%S", pszFileName) == -1)

	mov	eax, DWORD PTR _pszFileName$[ebp]
	push	eax
	push	OFFSET ??_C@_15MAOEGKJF@?$AA?$CF?$AAS?$AA?$AA@
	push	260					; 00000104H
	lea	ecx, DWORD PTR _fileName$[ebp]
	push	ecx
	call	_swprintf_s
	add	esp, 16					; 00000010H
	cmp	eax, -1
	jne	SHORT $LN1@TraceV

; 189  : 		{
; 190  : 			return;

	lea	ecx, DWORD PTR _wszBuf$[ebp]
	call	??1?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ
	jmp	SHORT $LN10@TraceV
$LN1@TraceV:

; 191  : 		}
; 192  : 
; 193  : 		_CrtDbgReportW(_CRT_WARN, fileName, nLine, nullptr, L"%s", wszBuf);

	mov	eax, DWORD PTR _wszBuf$[ebp]
	push	eax
	push	OFFSET ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
	push	0
	mov	ecx, DWORD PTR _nLine$[ebp]
	push	ecx
	lea	edx, DWORD PTR _fileName$[ebp]
	push	edx
	push	0
	call	__CrtDbgReportW
	add	esp, 24					; 00000018H

; 194  : 	}

	lea	ecx, DWORD PTR _wszBuf$[ebp]
	call	??1?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ
$LN10@TraceV:
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN17@TraceV
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 2828				; 00000b0cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN17@TraceV:
	DD	3
	DD	$LN16@TraceV
$LN16@TraceV:
	DD	-2056					; fffff7f8H
	DD	2048					; 00000800H
	DD	$LN13@TraceV
	DD	-2104					; fffff7c8H
	DD	4
	DD	$LN14@TraceV
	DD	-2632					; fffff5b8H
	DD	520					; 00000208H
	DD	$LN15@TraceV
$LN15@TraceV:
	DB	102					; 00000066H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	78					; 0000004eH
	DB	97					; 00000061H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	0
$LN14@TraceV:
	DB	119					; 00000077H
	DB	115					; 00000073H
	DB	122					; 0000007aH
	DB	66					; 00000042H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	0
$LN13@TraceV:
	DB	119					; 00000077H
	DB	115					; 00000073H
	DB	122					; 0000007aH
	DB	67					; 00000043H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	103					; 00000067H
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	121					; 00000079H
	DB	0
?TraceV@CTrace@ATL@@CAXPBDHIIPB_W@Z ENDP		; ATL::CTrace::TraceV
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ?GetCategoryName@CTrace@ATL@@CAPA_WI@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_nCategory$ = 8						; size = 4
?GetCategoryName@CTrace@ATL@@CAPA_WI@Z PROC		; ATL::CTrace::GetCategoryName, COMDAT

; 131  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 132  : 		for(unsigned int i = 0; i < m_nLastCategory; i++) 

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@GetCategor
$LN3@GetCategor:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@GetCategor:
	mov	eax, DWORD PTR _i$1[ebp]
	cmp	eax, DWORD PTR ?m_nLastCategory@CTrace@ATL@@1IA ; ATL::CTrace::m_nLastCategory
	jae	SHORT $LN2@GetCategor

; 133  : 		{
; 134  : 			if (m_nMap[i].nCategory == nCategory)

	imul	eax, DWORD PTR _i$1[ebp], 260
	mov	ecx, DWORD PTR ?m_nMap@CTrace@ATL@@1PAUCategoryMap@12@A[eax]
	cmp	ecx, DWORD PTR _nCategory$[ebp]
	jne	SHORT $LN1@GetCategor

; 135  : 			{
; 136  : 				return m_nMap[i].categryName;

	imul	eax, DWORD PTR _i$1[ebp], 260
	add	eax, OFFSET ?m_nMap@CTrace@ATL@@1PAUCategoryMap@12@A+4
	jmp	SHORT $LN5@GetCategor
$LN1@GetCategor:

; 137  : 			}
; 138  : 		}

	jmp	SHORT $LN3@GetCategor
$LN2@GetCategor:

; 139  : 
; 140  : 		return nullptr;

	xor	eax, eax
$LN5@GetCategor:

; 141  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetCategoryName@CTrace@ATL@@CAPA_WI@Z ENDP		; ATL::CTrace::GetCategoryName
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceISAPI@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceISAPI@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceISAPI'', COMDAT

; 118  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceISAPI> atlTraceISAPI(_T("atlTraceISAPI"));

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	OFFSET ??_C@_1BM@FHAEDBFK@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAI?$AAS?$AAA?$AAP?$AAI?$AA?$AA@
	mov	ecx, OFFSET ?atlTraceISAPI@ATL@@3V?$CTraceCategoryEx@$0EAAAAA@$0A@@1@A ; ATL::atlTraceISAPI
	call	??0?$CTraceCategoryEx@$0EAAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<4194304,0>::CTraceCategoryEx<4194304,0>
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__EatlTraceISAPI@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceISAPI''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0EAAAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0EAAAAA@$0A@@ATL@@QAE@PB_W@Z PROC ; ATL::CTraceCategoryEx<4194304,0>::CTraceCategoryEx<4194304,0>, COMDAT
; _this$ = ecx

; 426  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 427  : 	CTrace::RegisterCategory(pszCategoryName, traceCategory);

	push	4194304					; 00400000H
	mov	eax, DWORD PTR _pszCategoryName$[ebp]
	push	eax
	call	?RegisterCategory@CTrace@ATL@@SAXPB_WI@Z ; ATL::CTrace::RegisterCategory
	add	esp, 8

; 428  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CTraceCategoryEx@$0EAAAAA@$0A@@ATL@@QAE@PB_W@Z ENDP ; ATL::CTraceCategoryEx<4194304,0>::CTraceCategoryEx<4194304,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceSync@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceSync@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceSync'', COMDAT

; 117  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceSync> atlTraceSync(_T("atlTraceSync"));

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	OFFSET ??_C@_1BK@OPAPOCAL@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAS?$AAy?$AAn?$AAc?$AA?$AA@
	mov	ecx, OFFSET ?atlTraceSync@ATL@@3V?$CTraceCategoryEx@$0CAAAAA@$0A@@1@A ; ATL::atlTraceSync
	call	??0?$CTraceCategoryEx@$0CAAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<2097152,0>::CTraceCategoryEx<2097152,0>
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__EatlTraceSync@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceSync''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0CAAAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0CAAAAA@$0A@@ATL@@QAE@PB_W@Z PROC ; ATL::CTraceCategoryEx<2097152,0>::CTraceCategoryEx<2097152,0>, COMDAT
; _this$ = ecx

; 426  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 427  : 	CTrace::RegisterCategory(pszCategoryName, traceCategory);

	push	2097152					; 00200000H
	mov	eax, DWORD PTR _pszCategoryName$[ebp]
	push	eax
	call	?RegisterCategory@CTrace@ATL@@SAXPB_WI@Z ; ATL::CTrace::RegisterCategory
	add	esp, 8

; 428  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CTraceCategoryEx@$0CAAAAA@$0A@@ATL@@QAE@PB_W@Z ENDP ; ATL::CTraceCategoryEx<2097152,0>::CTraceCategoryEx<2097152,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceSecurity@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceSecurity@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceSecurity'', COMDAT

; 116  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceSecurity> atlTraceSecurity(_T("atlTraceSecurity"));

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	OFFSET ??_C@_1CC@DMMBNCFG@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAS?$AAe?$AAc?$AAu?$AAr?$AAi?$AAt?$AAy?$AA?$AA@
	mov	ecx, OFFSET ?atlTraceSecurity@ATL@@3V?$CTraceCategoryEx@$0BAAAAA@$0A@@1@A ; ATL::atlTraceSecurity
	call	??0?$CTraceCategoryEx@$0BAAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<1048576,0>::CTraceCategoryEx<1048576,0>
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__EatlTraceSecurity@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceSecurity''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0BAAAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0BAAAAA@$0A@@ATL@@QAE@PB_W@Z PROC ; ATL::CTraceCategoryEx<1048576,0>::CTraceCategoryEx<1048576,0>, COMDAT
; _this$ = ecx

; 426  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 427  : 	CTrace::RegisterCategory(pszCategoryName, traceCategory);

	push	1048576					; 00100000H
	mov	eax, DWORD PTR _pszCategoryName$[ebp]
	push	eax
	call	?RegisterCategory@CTrace@ATL@@SAXPB_WI@Z ; ATL::CTrace::RegisterCategory
	add	esp, 8

; 428  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CTraceCategoryEx@$0BAAAAA@$0A@@ATL@@QAE@PB_W@Z ENDP ; ATL::CTraceCategoryEx<1048576,0>::CTraceCategoryEx<1048576,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceUtil@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceUtil@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceUtil'', COMDAT

; 115  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceUtil> atlTraceUtil(_T("atlTraceUtil"));

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	OFFSET ??_C@_1BK@DMHCKHHD@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAU?$AAt?$AAi?$AAl?$AA?$AA@
	mov	ecx, OFFSET ?atlTraceUtil@ATL@@3V?$CTraceCategoryEx@$0IAAAA@$0A@@1@A ; ATL::atlTraceUtil
	call	??0?$CTraceCategoryEx@$0IAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<524288,0>::CTraceCategoryEx<524288,0>
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__EatlTraceUtil@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceUtil''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceMap@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceMap@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceMap'', COMDAT

; 114  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceMap> atlTraceMap(_T("atlTraceMap"));

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	OFFSET ??_C@_1BI@OKDLCIEM@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAM?$AAa?$AAp?$AA?$AA@
	mov	ecx, OFFSET ?atlTraceMap@ATL@@3V?$CTraceCategoryEx@$0EAAAA@$0A@@1@A ; ATL::atlTraceMap
	call	??0?$CTraceCategoryEx@$0EAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<262144,0>::CTraceCategoryEx<262144,0>
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__EatlTraceMap@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceMap''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0EAAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0EAAAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<262144,0>::CTraceCategoryEx<262144,0>, COMDAT
; _this$ = ecx

; 426  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 427  : 	CTrace::RegisterCategory(pszCategoryName, traceCategory);

	push	262144					; 00040000H
	mov	eax, DWORD PTR _pszCategoryName$[ebp]
	push	eax
	call	?RegisterCategory@CTrace@ATL@@SAXPB_WI@Z ; ATL::CTrace::RegisterCategory
	add	esp, 8

; 428  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CTraceCategoryEx@$0EAAAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<262144,0>::CTraceCategoryEx<262144,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceString@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceString@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceString'', COMDAT

; 113  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceString> atlTraceString(_T("atlTraceString"));

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	OFFSET ??_C@_1BO@GMLILNDJ@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAS?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?$AA@
	mov	ecx, OFFSET ?atlTraceString@ATL@@3V?$CTraceCategoryEx@$0CAAAA@$0A@@1@A ; ATL::atlTraceString
	call	??0?$CTraceCategoryEx@$0CAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<131072,0>::CTraceCategoryEx<131072,0>
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__EatlTraceString@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceString''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0CAAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0CAAAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<131072,0>::CTraceCategoryEx<131072,0>, COMDAT
; _this$ = ecx

; 426  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 427  : 	CTrace::RegisterCategory(pszCategoryName, traceCategory);

	push	131072					; 00020000H
	mov	eax, DWORD PTR _pszCategoryName$[ebp]
	push	eax
	call	?RegisterCategory@CTrace@ATL@@SAXPB_WI@Z ; ATL::CTrace::RegisterCategory
	add	esp, 8

; 428  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CTraceCategoryEx@$0CAAAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<131072,0>::CTraceCategoryEx<131072,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceStencil@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceStencil@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceStencil'', COMDAT

; 112  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceStencil> atlTraceStencil(_T("atlTraceStencil"));

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	OFFSET ??_C@_1CA@PBPHANCD@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAS?$AAt?$AAe?$AAn?$AAc?$AAi?$AAl?$AA?$AA@
	mov	ecx, OFFSET ?atlTraceStencil@ATL@@3V?$CTraceCategoryEx@$0BAAAA@$0A@@1@A ; ATL::atlTraceStencil
	call	??0?$CTraceCategoryEx@$0BAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<65536,0>::CTraceCategoryEx<65536,0>
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__EatlTraceStencil@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceStencil''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0BAAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0BAAAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<65536,0>::CTraceCategoryEx<65536,0>, COMDAT
; _this$ = ecx

; 426  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 427  : 	CTrace::RegisterCategory(pszCategoryName, traceCategory);

	push	65536					; 00010000H
	mov	eax, DWORD PTR _pszCategoryName$[ebp]
	push	eax
	call	?RegisterCategory@CTrace@ATL@@SAXPB_WI@Z ; ATL::CTrace::RegisterCategory
	add	esp, 8

; 428  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CTraceCategoryEx@$0BAAAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<65536,0>::CTraceCategoryEx<65536,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceCache@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceCache@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceCache'', COMDAT

; 111  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceCache> atlTraceCache(_T("atlTraceCache"));

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	OFFSET ??_C@_1BM@GIKLHLFD@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAC?$AAa?$AAc?$AAh?$AAe?$AA?$AA@
	mov	ecx, OFFSET ?atlTraceCache@ATL@@3V?$CTraceCategoryEx@$0IAAA@$0A@@1@A ; ATL::atlTraceCache
	call	??0?$CTraceCategoryEx@$0IAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<32768,0>::CTraceCategoryEx<32768,0>
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__EatlTraceCache@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceCache''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0IAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0IAAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<32768,0>::CTraceCategoryEx<32768,0>, COMDAT
; _this$ = ecx

; 426  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 427  : 	CTrace::RegisterCategory(pszCategoryName, traceCategory);

	push	32768					; 00008000H
	mov	eax, DWORD PTR _pszCategoryName$[ebp]
	push	eax
	call	?RegisterCategory@CTrace@ATL@@SAXPB_WI@Z ; ATL::CTrace::RegisterCategory
	add	esp, 8

; 428  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CTraceCategoryEx@$0IAAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<32768,0>::CTraceCategoryEx<32768,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceTime@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceTime@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceTime'', COMDAT

; 110  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceTime> atlTraceTime(_T("atlTraceTime"));

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	OFFSET ??_C@_1BK@NCJHOFCL@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAT?$AAi?$AAm?$AAe?$AA?$AA@
	mov	ecx, OFFSET ?atlTraceTime@ATL@@3V?$CTraceCategoryEx@$0EAAA@$0A@@1@A ; ATL::atlTraceTime
	call	??0?$CTraceCategoryEx@$0EAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<16384,0>::CTraceCategoryEx<16384,0>
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__EatlTraceTime@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceTime''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0EAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0EAAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<16384,0>::CTraceCategoryEx<16384,0>, COMDAT
; _this$ = ecx

; 426  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 427  : 	CTrace::RegisterCategory(pszCategoryName, traceCategory);

	push	16384					; 00004000H
	mov	eax, DWORD PTR _pszCategoryName$[ebp]
	push	eax
	call	?RegisterCategory@CTrace@ATL@@SAXPB_WI@Z ; ATL::CTrace::RegisterCategory
	add	esp, 8

; 428  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CTraceCategoryEx@$0EAAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<16384,0>::CTraceCategoryEx<16384,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceException@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceException@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceException'', COMDAT

; 109  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceException> atlTraceException(_T("atlTraceException"));

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	OFFSET ??_C@_1CE@IMMADNAP@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAE?$AAx?$AAc?$AAe?$AAp?$AAt?$AAi?$AAo?$AAn?$AA?$AA@
	mov	ecx, OFFSET ?atlTraceException@ATL@@3V?$CTraceCategoryEx@$0CAAA@$0A@@1@A ; ATL::atlTraceException
	call	??0?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<8192,0>::CTraceCategoryEx<8192,0>
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__EatlTraceException@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceException''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??B?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??B?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAEIXZ PROC	; ATL::CTraceCategoryEx<8192,0>::operator unsigned int, COMDAT
; _this$ = ecx

; 78   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 79   : #ifdef _DEBUG
; 80   : 		return traceCategory;

	mov	eax, 8192				; 00002000H

; 81   : #else
; 82   : 		return 0;
; 83   : #endif
; 84   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??B?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAEIXZ ENDP	; ATL::CTraceCategoryEx<8192,0>::operator unsigned int
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<8192,0>::CTraceCategoryEx<8192,0>, COMDAT
; _this$ = ecx

; 426  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 427  : 	CTrace::RegisterCategory(pszCategoryName, traceCategory);

	push	8192					; 00002000H
	mov	eax, DWORD PTR _pszCategoryName$[ebp]
	push	eax
	call	?RegisterCategory@CTrace@ATL@@SAXPB_WI@Z ; ATL::CTrace::RegisterCategory
	add	esp, 8

; 428  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<8192,0>::CTraceCategoryEx<8192,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceAllocation@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceAllocation@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceAllocation'', COMDAT

; 108  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceAllocation> atlTraceAllocation(_T("atlTraceAllocation"));

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	OFFSET ??_C@_1CG@KFEEMCDH@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?$AA@
	mov	ecx, OFFSET ?atlTraceAllocation@ATL@@3V?$CTraceCategoryEx@$0BAAA@$0A@@1@A ; ATL::atlTraceAllocation
	call	??0?$CTraceCategoryEx@$0BAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<4096,0>::CTraceCategoryEx<4096,0>
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__EatlTraceAllocation@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceAllocation''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0BAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0BAAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<4096,0>::CTraceCategoryEx<4096,0>, COMDAT
; _this$ = ecx

; 426  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 427  : 	CTrace::RegisterCategory(pszCategoryName, traceCategory);

	push	4096					; 00001000H
	mov	eax, DWORD PTR _pszCategoryName$[ebp]
	push	eax
	call	?RegisterCategory@CTrace@ATL@@SAXPB_WI@Z ; ATL::CTrace::RegisterCategory
	add	esp, 8

; 428  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CTraceCategoryEx@$0BAAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<4096,0>::CTraceCategoryEx<4096,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceNotImpl@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceNotImpl@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceNotImpl'', COMDAT

; 107  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceNotImpl> atlTraceNotImpl(_T("atlTraceNotImpl"));

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	OFFSET ??_C@_1CA@DMHPIODO@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAN?$AAo?$AAt?$AAI?$AAm?$AAp?$AAl?$AA?$AA@
	mov	ecx, OFFSET ?atlTraceNotImpl@ATL@@3V?$CTraceCategoryEx@$0IAA@$0A@@1@A ; ATL::atlTraceNotImpl
	call	??0?$CTraceCategoryEx@$0IAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<2048,0>::CTraceCategoryEx<2048,0>
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__EatlTraceNotImpl@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceNotImpl''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0IAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0IAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<2048,0>::CTraceCategoryEx<2048,0>, COMDAT
; _this$ = ecx

; 426  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 427  : 	CTrace::RegisterCategory(pszCategoryName, traceCategory);

	push	2048					; 00000800H
	mov	eax, DWORD PTR _pszCategoryName$[ebp]
	push	eax
	call	?RegisterCategory@CTrace@ATL@@SAXPB_WI@Z ; ATL::CTrace::RegisterCategory
	add	esp, 8

; 428  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CTraceCategoryEx@$0IAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<2048,0>::CTraceCategoryEx<2048,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceSnapin@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceSnapin@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceSnapin'', COMDAT

; 106  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceSnapin> atlTraceSnapin(_T("atlTraceSnapin"));

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	OFFSET ??_C@_1BO@EFPHNHHN@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAS?$AAn?$AAa?$AAp?$AAi?$AAn?$AA?$AA@
	mov	ecx, OFFSET ?atlTraceSnapin@ATL@@3V?$CTraceCategoryEx@$0EAA@$0A@@1@A ; ATL::atlTraceSnapin
	call	??0?$CTraceCategoryEx@$0EAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<1024,0>::CTraceCategoryEx<1024,0>
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__EatlTraceSnapin@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceSnapin''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0EAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0EAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<1024,0>::CTraceCategoryEx<1024,0>, COMDAT
; _this$ = ecx

; 426  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 427  : 	CTrace::RegisterCategory(pszCategoryName, traceCategory);

	push	1024					; 00000400H
	mov	eax, DWORD PTR _pszCategoryName$[ebp]
	push	eax
	call	?RegisterCategory@CTrace@ATL@@SAXPB_WI@Z ; ATL::CTrace::RegisterCategory
	add	esp, 8

; 428  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CTraceCategoryEx@$0EAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<1024,0>::CTraceCategoryEx<1024,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceDBProvider@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceDBProvider@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceDBProvider'', COMDAT

; 105  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceDBProvider> atlTraceDBProvider(_T("atlTraceDBProvider"));

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	OFFSET ??_C@_1CG@MNMMIOOI@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAD?$AAB?$AAP?$AAr?$AAo?$AAv?$AAi?$AAd?$AAe?$AAr?$AA?$AA@
	mov	ecx, OFFSET ?atlTraceDBProvider@ATL@@3V?$CTraceCategoryEx@$0CAA@$0A@@1@A ; ATL::atlTraceDBProvider
	call	??0?$CTraceCategoryEx@$0CAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<512,0>::CTraceCategoryEx<512,0>
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__EatlTraceDBProvider@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceDBProvider''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0CAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0CAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<512,0>::CTraceCategoryEx<512,0>, COMDAT
; _this$ = ecx

; 426  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 427  : 	CTrace::RegisterCategory(pszCategoryName, traceCategory);

	push	512					; 00000200H
	mov	eax, DWORD PTR _pszCategoryName$[ebp]
	push	eax
	call	?RegisterCategory@CTrace@ATL@@SAXPB_WI@Z ; ATL::CTrace::RegisterCategory
	add	esp, 8

; 428  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CTraceCategoryEx@$0CAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<512,0>::CTraceCategoryEx<512,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceDBClient@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceDBClient@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceDBClient'', COMDAT

; 104  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceDBClient> atlTraceDBClient(_T("atlTraceDBClient"));

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	OFFSET ??_C@_1CC@JNJJDOOH@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAD?$AAB?$AAC?$AAl?$AAi?$AAe?$AAn?$AAt?$AA?$AA@
	mov	ecx, OFFSET ?atlTraceDBClient@ATL@@3V?$CTraceCategoryEx@$0BAA@$0A@@1@A ; ATL::atlTraceDBClient
	call	??0?$CTraceCategoryEx@$0BAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<256,0>::CTraceCategoryEx<256,0>
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__EatlTraceDBClient@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceDBClient''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0BAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0BAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<256,0>::CTraceCategoryEx<256,0>, COMDAT
; _this$ = ecx

; 426  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 427  : 	CTrace::RegisterCategory(pszCategoryName, traceCategory);

	push	256					; 00000100H
	mov	eax, DWORD PTR _pszCategoryName$[ebp]
	push	eax
	call	?RegisterCategory@CTrace@ATL@@SAXPB_WI@Z ; ATL::CTrace::RegisterCategory
	add	esp, 8

; 428  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CTraceCategoryEx@$0BAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<256,0>::CTraceCategoryEx<256,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceHosting@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceHosting@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceHosting'', COMDAT

; 103  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceHosting> atlTraceHosting(_T("atlTraceHosting"));

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	OFFSET ??_C@_1CA@OMOMONMN@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAH?$AAo?$AAs?$AAt?$AAi?$AAn?$AAg?$AA?$AA@
	mov	ecx, OFFSET ?atlTraceHosting@ATL@@3V?$CTraceCategoryEx@$0IA@$0A@@1@A ; ATL::atlTraceHosting
	call	??0?$CTraceCategoryEx@$0IA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<128,0>::CTraceCategoryEx<128,0>
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__EatlTraceHosting@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceHosting''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0IA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0IA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<128,0>::CTraceCategoryEx<128,0>, COMDAT
; _this$ = ecx

; 426  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 427  : 	CTrace::RegisterCategory(pszCategoryName, traceCategory);

	push	128					; 00000080H
	mov	eax, DWORD PTR _pszCategoryName$[ebp]
	push	eax
	call	?RegisterCategory@CTrace@ATL@@SAXPB_WI@Z ; ATL::CTrace::RegisterCategory
	add	esp, 8

; 428  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CTraceCategoryEx@$0IA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<128,0>::CTraceCategoryEx<128,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceControls@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceControls@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceControls'', COMDAT

; 102  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceControls> atlTraceControls(_T("atlTraceControls"));

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	OFFSET ??_C@_1CC@IMNJGBED@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAC?$AAo?$AAn?$AAt?$AAr?$AAo?$AAl?$AAs?$AA?$AA@
	mov	ecx, OFFSET ?atlTraceControls@ATL@@3V?$CTraceCategoryEx@$0EA@$0A@@1@A ; ATL::atlTraceControls
	call	??0?$CTraceCategoryEx@$0EA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<64,0>::CTraceCategoryEx<64,0>
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__EatlTraceControls@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceControls''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0EA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0EA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<64,0>::CTraceCategoryEx<64,0>, COMDAT
; _this$ = ecx

; 426  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 427  : 	CTrace::RegisterCategory(pszCategoryName, traceCategory);

	push	64					; 00000040H
	mov	eax, DWORD PTR _pszCategoryName$[ebp]
	push	eax
	call	?RegisterCategory@CTrace@ATL@@SAXPB_WI@Z ; ATL::CTrace::RegisterCategory
	add	esp, 8

; 428  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CTraceCategoryEx@$0EA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<64,0>::CTraceCategoryEx<64,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceWindowing@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceWindowing@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceWindowing'', COMDAT

; 101  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceWindowing> atlTraceWindowing(_T("atlTraceWindowing"));

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	OFFSET ??_C@_1CE@NAJDPMNB@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AAi?$AAn?$AAg?$AA?$AA@
	mov	ecx, OFFSET ?atlTraceWindowing@ATL@@3V?$CTraceCategoryEx@$0CA@$0A@@1@A ; ATL::atlTraceWindowing
	call	??0?$CTraceCategoryEx@$0CA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<32,0>::CTraceCategoryEx<32,0>
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__EatlTraceWindowing@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceWindowing''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??B?$CTraceCategoryEx@$0CA@$0A@@ATL@@QAEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??B?$CTraceCategoryEx@$0CA@$0A@@ATL@@QAEIXZ PROC	; ATL::CTraceCategoryEx<32,0>::operator unsigned int, COMDAT
; _this$ = ecx

; 78   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 79   : #ifdef _DEBUG
; 80   : 		return traceCategory;

	mov	eax, 32					; 00000020H

; 81   : #else
; 82   : 		return 0;
; 83   : #endif
; 84   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??B?$CTraceCategoryEx@$0CA@$0A@@ATL@@QAEIXZ ENDP	; ATL::CTraceCategoryEx<32,0>::operator unsigned int
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0CA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0CA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<32,0>::CTraceCategoryEx<32,0>, COMDAT
; _this$ = ecx

; 426  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 427  : 	CTrace::RegisterCategory(pszCategoryName, traceCategory);

	push	32					; 00000020H
	mov	eax, DWORD PTR _pszCategoryName$[ebp]
	push	eax
	call	?RegisterCategory@CTrace@ATL@@SAXPB_WI@Z ; ATL::CTrace::RegisterCategory
	add	esp, 8

; 428  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CTraceCategoryEx@$0CA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<32,0>::CTraceCategoryEx<32,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceRefcount@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceRefcount@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceRefcount'', COMDAT

; 100  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceRefcount> atlTraceRefcount(_T("atlTraceRefcount"));

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	OFFSET ??_C@_1CC@BNHGJFNK@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAR?$AAe?$AAf?$AAc?$AAo?$AAu?$AAn?$AAt?$AA?$AA@
	mov	ecx, OFFSET ?atlTraceRefcount@ATL@@3V?$CTraceCategoryEx@$0BA@$0A@@1@A ; ATL::atlTraceRefcount
	call	??0?$CTraceCategoryEx@$0BA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<16,0>::CTraceCategoryEx<16,0>
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__EatlTraceRefcount@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceRefcount''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0BA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0BA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<16,0>::CTraceCategoryEx<16,0>, COMDAT
; _this$ = ecx

; 426  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 427  : 	CTrace::RegisterCategory(pszCategoryName, traceCategory);

	push	16					; 00000010H
	mov	eax, DWORD PTR _pszCategoryName$[ebp]
	push	eax
	call	?RegisterCategory@CTrace@ATL@@SAXPB_WI@Z ; ATL::CTrace::RegisterCategory
	add	esp, 8

; 428  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CTraceCategoryEx@$0BA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<16,0>::CTraceCategoryEx<16,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceRegistrar@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceRegistrar@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceRegistrar'', COMDAT

; 99   : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceRegistrar> atlTraceRegistrar(_T("atlTraceRegistrar"));

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	OFFSET ??_C@_1CE@NIAEAIDK@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAR?$AAe?$AAg?$AAi?$AAs?$AAt?$AAr?$AAa?$AAr?$AA?$AA@
	mov	ecx, OFFSET ?atlTraceRegistrar@ATL@@3V?$CTraceCategoryEx@$07$0A@@1@A ; ATL::atlTraceRegistrar
	call	??0?$CTraceCategoryEx@$07$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<8,0>::CTraceCategoryEx<8,0>
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__EatlTraceRegistrar@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceRegistrar''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$07$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$07$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<8,0>::CTraceCategoryEx<8,0>, COMDAT
; _this$ = ecx

; 426  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 427  : 	CTrace::RegisterCategory(pszCategoryName, traceCategory);

	push	8
	mov	eax, DWORD PTR _pszCategoryName$[ebp]
	push	eax
	call	?RegisterCategory@CTrace@ATL@@SAXPB_WI@Z ; ATL::CTrace::RegisterCategory
	add	esp, 8

; 428  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CTraceCategoryEx@$07$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<8,0>::CTraceCategoryEx<8,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceQI@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceQI@ATL@@YAXXZ PROC				; ATL::`dynamic initializer for 'atlTraceQI'', COMDAT

; 98   : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceQI> atlTraceQI(_T("atlTraceQI"));

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	OFFSET ??_C@_1BG@FPLJJEMF@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAQ?$AAI?$AA?$AA@
	mov	ecx, OFFSET ?atlTraceQI@ATL@@3V?$CTraceCategoryEx@$03$0A@@1@A ; ATL::atlTraceQI
	call	??0?$CTraceCategoryEx@$03$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<4,0>::CTraceCategoryEx<4,0>
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__EatlTraceQI@ATL@@YAXXZ ENDP				; ATL::`dynamic initializer for 'atlTraceQI''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$03$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$03$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<4,0>::CTraceCategoryEx<4,0>, COMDAT
; _this$ = ecx

; 426  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 427  : 	CTrace::RegisterCategory(pszCategoryName, traceCategory);

	push	4
	mov	eax, DWORD PTR _pszCategoryName$[ebp]
	push	eax
	call	?RegisterCategory@CTrace@ATL@@SAXPB_WI@Z ; ATL::CTrace::RegisterCategory
	add	esp, 8

; 428  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CTraceCategoryEx@$03$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<4,0>::CTraceCategoryEx<4,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceCOM@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceCOM@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceCOM'', COMDAT

; 97   : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceCom> atlTraceCOM(_T("atlTraceCOM"));

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	OFFSET ??_C@_1BI@MAFGHOEE@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAC?$AAO?$AAM?$AA?$AA@
	mov	ecx, OFFSET ?atlTraceCOM@ATL@@3V?$CTraceCategoryEx@$01$0A@@1@A ; ATL::atlTraceCOM
	call	??0?$CTraceCategoryEx@$01$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<2,0>::CTraceCategoryEx<2,0>
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__EatlTraceCOM@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceCOM''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??B?$CTraceCategoryEx@$01$0A@@ATL@@QAEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??B?$CTraceCategoryEx@$01$0A@@ATL@@QAEIXZ PROC		; ATL::CTraceCategoryEx<2,0>::operator unsigned int, COMDAT
; _this$ = ecx

; 78   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 79   : #ifdef _DEBUG
; 80   : 		return traceCategory;

	mov	eax, 2

; 81   : #else
; 82   : 		return 0;
; 83   : #endif
; 84   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??B?$CTraceCategoryEx@$01$0A@@ATL@@QAEIXZ ENDP		; ATL::CTraceCategoryEx<2,0>::operator unsigned int
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$01$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$01$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<2,0>::CTraceCategoryEx<2,0>, COMDAT
; _this$ = ecx

; 426  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 427  : 	CTrace::RegisterCategory(pszCategoryName, traceCategory);

	push	2
	mov	eax, DWORD PTR _pszCategoryName$[ebp]
	push	eax
	call	?RegisterCategory@CTrace@ATL@@SAXPB_WI@Z ; ATL::CTrace::RegisterCategory
	add	esp, 8

; 428  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CTraceCategoryEx@$01$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<2,0>::CTraceCategoryEx<2,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceGeneral@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceGeneral@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceGeneral'', COMDAT

; 96   : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceGeneral> atlTraceGeneral(_T("atlTraceGeneral"));

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	OFFSET ??_C@_1CA@ONGMEOAB@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAG?$AAe?$AAn?$AAe?$AAr?$AAa?$AAl?$AA?$AA@
	mov	ecx, OFFSET ?atlTraceGeneral@ATL@@3V?$CTraceCategoryEx@$00$0A@@1@A ; ATL::atlTraceGeneral
	call	??0?$CTraceCategoryEx@$00$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<1,0>::CTraceCategoryEx<1,0>
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__EatlTraceGeneral@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceGeneral''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$00$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$00$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<1,0>::CTraceCategoryEx<1,0>, COMDAT
; _this$ = ecx

; 426  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 427  : 	CTrace::RegisterCategory(pszCategoryName, traceCategory);

	push	1
	mov	eax, DWORD PTR _pszCategoryName$[ebp]
	push	eax
	call	?RegisterCategory@CTrace@ATL@@SAXPB_WI@Z ; ATL::CTrace::RegisterCategory
	add	esp, 8

; 428  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CTraceCategoryEx@$00$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<1,0>::CTraceCategoryEx<1,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0IAAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0IAAAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<524288,0>::CTraceCategoryEx<524288,0>, COMDAT
; _this$ = ecx

; 426  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 427  : 	CTrace::RegisterCategory(pszCategoryName, traceCategory);

	push	524288					; 00080000H
	mov	eax, DWORD PTR _pszCategoryName$[ebp]
	push	eax
	call	?RegisterCategory@CTrace@ATL@@SAXPB_WI@Z ; ATL::CTrace::RegisterCategory
	add	esp, 8

; 428  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CTraceCategoryEx@$0IAAAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<524288,0>::CTraceCategoryEx<524288,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlconv.h
;	COMDAT ?_AtlGetConversionACP@ATL@@YGIXZ
_TEXT	SEGMENT
?_AtlGetConversionACP@ATL@@YGIXZ PROC			; ATL::_AtlGetConversionACP, COMDAT

; 105  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 106  : #ifdef _CONVERSION_DONT_USE_THREAD_LOCALE
; 107  : 	return CP_ACP;
; 108  : #else
; 109  : 	return CP_THREAD_ACP;

	mov	eax, 3

; 110  : #endif
; 111  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?_AtlGetConversionACP@ATL@@YGIXZ ENDP			; ATL::_AtlGetConversionACP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ?Free@CCRTAllocator@ATL@@SAXPAX@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?Free@CCRTAllocator@ATL@@SAXPAX@Z PROC			; ATL::CCRTAllocator::Free, COMDAT

; 281  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 282  : 		free(p);

	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	call	_free
	add	esp, 4

; 283  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Free@CCRTAllocator@ATL@@SAXPAX@Z ENDP			; ATL::CCRTAllocator::Free
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ?Allocate@CCRTAllocator@ATL@@SAPAXI@Z
_TEXT	SEGMENT
_nBytes$ = 8						; size = 4
?Allocate@CCRTAllocator@ATL@@SAPAXI@Z PROC		; ATL::CCRTAllocator::Allocate, COMDAT

; 276  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 277  : 		return malloc(nBytes);

	mov	eax, DWORD PTR _nBytes$[ebp]
	push	eax
	call	_malloc
	add	esp, 4

; 278  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Allocate@CCRTAllocator@ATL@@SAPAXI@Z ENDP		; ATL::CCRTAllocator::Allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ??$AtlMultiply@I@ATL@@YAJPAIII@Z
_TEXT	SEGMENT
_i64Result$ = -12					; size = 8
_piResult$ = 8						; size = 4
_iLeft$ = 12						; size = 4
_iRight$ = 16						; size = 4
??$AtlMultiply@I@ATL@@YAJPAIII@Z PROC			; ATL::AtlMultiply<unsigned int>, COMDAT

; 150  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 151  : 	unsigned __int64 i64Result=static_cast<unsigned __int64>(iLeft) * static_cast<unsigned __int64>(iRight);

	mov	eax, DWORD PTR _iLeft$[ebp]
	mul	DWORD PTR _iRight$[ebp]
	mov	DWORD PTR _i64Result$[ebp], eax
	mov	DWORD PTR _i64Result$[ebp+4], edx

; 152  : 	if(i64Result>UINT_MAX)

	cmp	DWORD PTR _i64Result$[ebp+4], 0
	ja	SHORT $LN4@AtlMultipl
	cmp	DWORD PTR _i64Result$[ebp], -1
	jbe	SHORT $LN1@AtlMultipl
$LN4@AtlMultipl:

; 153  : 	{
; 154  : 		return HRESULT_FROM_WIN32(ERROR_ARITHMETIC_OVERFLOW);

	push	534					; 00000216H
	call	_HRESULT_FROM_WIN32
	add	esp, 4
	jmp	SHORT $LN2@AtlMultipl
$LN1@AtlMultipl:

; 155  : 	}
; 156  : 	*piResult=static_cast<unsigned int _ATL_W64>(i64Result);

	mov	eax, DWORD PTR _i64Result$[ebp]
	mov	ecx, DWORD PTR _piResult$[ebp]
	mov	DWORD PTR [ecx], eax

; 157  : 	return S_OK;

	xor	eax, eax
$LN2@AtlMultipl:

; 158  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$AtlMultiply@I@ATL@@YAJPAIII@Z ENDP			; ATL::AtlMultiply<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\new.h
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 105  :         {return; }

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 103  :         {return (_Where); }

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR __Where$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
;	COMDAT ??BD3DXMATRIX@@QAEPAMXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??BD3DXMATRIX@@QAEPAMXZ PROC				; D3DXMATRIX::operator float *, COMDAT
; _this$ = ecx

; 815  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 816  :     return (FLOAT *) &_11;

	mov	eax, DWORD PTR _this$[ebp]

; 817  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??BD3DXMATRIX@@QAEPAMXZ ENDP				; D3DXMATRIX::operator float *
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
;	COMDAT ??0D3DXVECTOR4@@QAE@MMMM@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_fx$ = 8						; size = 4
_fy$ = 12						; size = 4
_fz$ = 16						; size = 4
_fw$ = 20						; size = 4
??0D3DXVECTOR4@@QAE@MMMM@Z PROC				; D3DXVECTOR4::D3DXVECTOR4, COMDAT
; _this$ = ecx

; 553  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 554  :     x = fx;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _fx$[ebp]
	movss	DWORD PTR [eax], xmm0

; 555  :     y = fy;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _fy$[ebp]
	movss	DWORD PTR [eax+4], xmm0

; 556  :     z = fz;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _fz$[ebp]
	movss	DWORD PTR [eax+8], xmm0

; 557  :     w = fw;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _fw$[ebp]
	movss	DWORD PTR [eax+12], xmm0

; 558  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
??0D3DXVECTOR4@@QAE@MMMM@Z ENDP				; D3DXVECTOR4::D3DXVECTOR4
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
;	COMDAT ??0D3DXVECTOR4@@QAE@ABU_D3DVECTOR@@M@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_v$ = 8							; size = 4
_f$ = 12						; size = 4
??0D3DXVECTOR4@@QAE@ABU_D3DVECTOR@@M@Z PROC		; D3DXVECTOR4::D3DXVECTOR4, COMDAT
; _this$ = ecx

; 544  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 545  :     x = v.x;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 546  :     y = v.y;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx

; 547  :     z = v.z;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx

; 548  :     w = f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _f$[ebp]
	movss	DWORD PTR [eax+12], xmm0

; 549  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??0D3DXVECTOR4@@QAE@ABU_D3DVECTOR@@M@Z ENDP		; D3DXVECTOR4::D3DXVECTOR4
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.h
;	COMDAT ??0D3DXVECTOR4@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0D3DXVECTOR4@@QAE@XZ PROC				; D3DXVECTOR4::D3DXVECTOR4, COMDAT
; _this$ = ecx

; 273  :     D3DXVECTOR4() {};

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0D3DXVECTOR4@@QAE@XZ ENDP				; D3DXVECTOR4::D3DXVECTOR4
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
;	COMDAT ??BD3DXVECTOR3@@QAEPAMXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??BD3DXVECTOR3@@QAEPAMXZ PROC				; D3DXVECTOR3::operator float *, COMDAT
; _this$ = ecx

; 330  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 331  :     return (FLOAT *) &x;

	mov	eax, DWORD PTR _this$[ebp]

; 332  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??BD3DXVECTOR3@@QAEPAMXZ ENDP				; D3DXVECTOR3::operator float *
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
;	COMDAT ??0D3DXVECTOR3@@QAE@MMM@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_fx$ = 8						; size = 4
_fy$ = 12						; size = 4
_fz$ = 16						; size = 4
??0D3DXVECTOR3@@QAE@MMM@Z PROC				; D3DXVECTOR3::D3DXVECTOR3, COMDAT
; _this$ = ecx

; 320  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 321  :     x = fx;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _fx$[ebp]
	movss	DWORD PTR [eax], xmm0

; 322  :     y = fy;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _fy$[ebp]
	movss	DWORD PTR [eax+4], xmm0

; 323  :     z = fz;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _fz$[ebp]
	movss	DWORD PTR [eax+8], xmm0

; 324  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??0D3DXVECTOR3@@QAE@MMM@Z ENDP				; D3DXVECTOR3::D3DXVECTOR3
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.h
;	COMDAT ??0D3DXVECTOR3@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0D3DXVECTOR3@@QAE@XZ PROC				; D3DXVECTOR3::D3DXVECTOR3, COMDAT
; _this$ = ecx

; 198  :     D3DXVECTOR3() {};

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0D3DXVECTOR3@@QAE@XZ ENDP				; D3DXVECTOR3::D3DXVECTOR3
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
;	COMDAT _hypot
_TEXT	SEGMENT
__X$ = 8						; size = 8
__Y$ = 16						; size = 8
_hypot	PROC						; COMDAT

; 556  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 557  :     return _hypot(_X, _Y);

	sub	esp, 8
	movsd	xmm0, QWORD PTR __Y$[ebp]
	movsd	QWORD PTR [esp], xmm0
	sub	esp, 8
	movsd	xmm0, QWORD PTR __X$[ebp]
	movsd	QWORD PTR [esp], xmm0
	call	__hypot
	add	esp, 16					; 00000010H

; 558  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_hypot	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\8.1\include\shared\winerror.h
;	COMDAT _HRESULT_FROM_WIN32
_TEXT	SEGMENT
tv68 = -196						; size = 4
_x$ = 8							; size = 4
_HRESULT_FROM_WIN32 PROC				; COMDAT

; 26297: FORCEINLINE HRESULT HRESULT_FROM_WIN32(unsigned long x) { return (HRESULT)(x) <= 0 ? (HRESULT)(x) : (HRESULT) (((x) & 0x0000FFFF) | (FACILITY_WIN32 << 16) | 0x80000000);}

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	cmp	DWORD PTR _x$[ebp], 0
	jg	SHORT $LN3@HRESULT_FR
	mov	eax, DWORD PTR _x$[ebp]
	mov	DWORD PTR tv68[ebp], eax
	jmp	SHORT $LN4@HRESULT_FR
$LN3@HRESULT_FR:
	mov	ecx, DWORD PTR _x$[ebp]
	and	ecx, 65535				; 0000ffffH
	or	ecx, 458752				; 00070000H
	or	ecx, -2147483648			; 80000000H
	mov	DWORD PTR tv68[ebp], ecx
$LN4@HRESULT_FR:
	mov	eax, DWORD PTR tv68[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_HRESULT_FROM_WIN32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
$LN2@vector:
	mov	eax, DWORD PTR ___n$[ebp]
	sub	eax, 1
	mov	DWORD PTR ___n$[ebp], eax
	js	SHORT $LN3@vector
	mov	esi, esp
	mov	ecx, DWORD PTR ___t$[ebp]
	call	DWORD PTR ___f$[ebp]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	eax, DWORD PTR ___t$[ebp]
	add	eax, DWORD PTR ___s$[ebp]
	mov	DWORD PTR ___t$[ebp], eax
	jmp	SHORT $LN2@vector
$LN3@vector:
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
